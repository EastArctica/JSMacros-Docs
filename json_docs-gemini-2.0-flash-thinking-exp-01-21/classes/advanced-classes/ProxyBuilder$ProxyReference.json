{
  "name": "ProxyBuilder$ProxyReference",
  "fullClassName": "xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder$ProxyReference",
  "since": "JSMacros 1.6.0",
  "description": "The `ProxyReference` class provides a reference mechanism for accessing the original (parent) implementation within proxy method handlers. When creating dynamic proxies with ProxyBuilder, ProxyReference allows proxy methods to call through to the original method implementation, enabling method interception, decoration, and selective overriding of behavior.",
  "overview": "The ProxyReference class serves as a bridge between proxy method implementations and the original underlying object or method. It enables:\n- Calling original method implementations from proxy methods\n- Method interception and decoration patterns\n- Conditional method overriding based on runtime logic\n- Access to super/parent functionality in dynamic proxies\n- Method chaining and delegation patterns\nThis class is typically passed as the first parameter to proxy method handlers, providing access to the original implementation while allowing custom behavior to be added before, after, or instead of the original call.\n\nPurpose and Use Cases\n\nMethod Interception\nProxyReference enables intercepting method calls to add logging, validation, caching, or other cross-cutting concerns:\n\nConditional Method Overriding\nSelectively override method behavior based on conditions:\n\nMethod Decoration\nWrap original method calls with additional functionality:\n\nThe ProxyReference automatically matches the correct method signature based on how the proxy method was defined.",
  "constructors": [],
  "methods": [
    {
      "name": "parent",
      "signature": "parent(methodArgs: Array<any>): any",
      "returnType": "any",
      "description": "A function reference to the original method implementation. When available, this function can be called with an array of parameters that would be passed to the original method, to invoke the parent implementation.",
      "parameters": [
        {
          "name": "methodArgs",
          "type": "Array<any>",
          "description": "An array containing the arguments to pass to the original method. These should match the expected parameters of the original method being proxied."
        }
      ],
      "static": false,
      "examples": [
        "// Check if parent method is available\nif (ref.parent) {\n    // Call original method with parameters\n    const result = ref.parent(param1, param2, param3);\n} else {\n    // Handle case where no parent implementation exists\n}",
        "// Method signature: \"toString()Ljava/lang/String;\"\nbuilder.addMethod(\"toString()Ljava/lang/String;\", JavaWrapper.methodToJava((ref, args) => {\n    // ref.parent will match the toString() method\n    return ref.parent ? ref.parent() : \"default string\";\n}));",
        "// Method signature: \"add(Ljava/lang/Object;)Z\"\nbuilder.addMethod(\"add(Ljava/lang/Object;)Z\", JavaWrapper.methodToJava((ref, args) => {\n    // ref.parent will match the add(Object) method\n    return ref.parent ? ref.parent(args[0]) : false;\n}));",
        "const builder = new ProxyBuilder(ArrayList.class, []);\n\nbuilder.addMethod(\"add(Ljava/lang/Object;)Z\", JavaWrapper.methodToJava((ref, args) => {\n    const item = args[0];\n\n    // Pre-processing: Log the addition\n    Chat.log(`Adding item to list: ${item}`);\n\n    // Call original method through proxy reference\n    const result = ref.parent ? ref.parent([item]) : false;\n\n    // Post-processing: Log success\n    if (result) {\n        Chat.log(`Successfully added item: ${item}`);\n    }\n\n    return result;\n}));",
        "const builder = new ProxyBuilder(StringBuilder.class, []);\n\nbuilder.addMethod(\"append(Ljava/lang/String;)Ljava/lang/StringBuilder;\",\n    JavaWrapper.methodToJava((ref, args) => {\n        const str = args[0];\n\n        // Only append certain strings\n        if (str && str.toString().includes(\"important\")) {\n            Chat.log(`Appending important data: ${str}`);\n            return ref.parent ? ref.parent([str]) : null;\n        } else {\n            Chat.log(`Skipping non-important data: ${str}`);\n            return null; // Don't call original method\n        }\n    }));",
        "const builder = new ProxyBuilder(HashMap.class, []);\n\nbuilder.addMethod(\"put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\",\n    JavaWrapper.methodToJava((ref, args) => {\n        const key = args[0];\n        const value = args[1];\n\n        // Pre-call validation\n        if (key === null) {\n            throw new Error(\"Null keys not allowed\");\n        }\n\n        // Measure execution time\n        const startTime = Date.now();\n        const result = ref.parent ? ref.parent([key, value]) : null;\n        const endTime = Date.now();\n\n        Chat.log(`Put operation took ${endTime - startTime}ms`);\n        return result;\n    }));",
        "// Override add() with logging\n    builder.addMethod(\"add(Ljava/lang/Object;)Z\", JavaWrapper.methodToJava((ref, args) => {\n        const item = args[0];\n        Chat.log(`[LIST] Adding item: ${item}`);\n\n        // Call original add method\n        const result = ref.parent ? ref.parent([item]) : false;\n\n        if (result) {\n            Chat.log(`[LIST] Successfully added: ${item}`);\n        } else {\n            Chat.log(`[LIST] Failed to add: ${item}`);\n        }\n\n        return result;\n    }));\n\n    // Override get() with bounds checking\n    builder.addMethod(\"get(I)Ljava/lang/Object;\", JavaWrapper.methodToJava((ref, args) => {\n        const index = args[0];\n\n        // Custom bounds checking\n        if (index < 0) {\n            throw new Error(\"Index cannot be negative\");\n        }\n\n        // Call original get method\n        try {\n            const result = ref.parent ? ref.parent([index]) : null;\n            Chat.log(`[LIST] Retrieved item at index ${index}: ${result}`);\n            return result;\n        } catch (e) {\n            Chat.log(`[LIST] Error retrieving item at index ${index}: ${e.message}`);\n            throw e;\n        }\n    }));",
        "// Create a cached function proxy\n    builder.addMethod(\"apply(Ljava/lang/Object;)Ljava/lang/Object;\",\n        JavaWrapper.methodToJava((ref, args) => {\n            const input = args[0];\n            const cacheKey = input.toString();\n\n            // Check cache first\n            if (cache.has(cacheKey)) {\n                Chat.log(`Cache hit for: ${input}`);\n                return cache.get(cacheKey);\n            }\n\n            Chat.log(`Cache miss for: ${input}, computing...`);\n\n            // Call expensive computation (if parent exists)\n            const result = ref.parent ? ref.parent([input]) : `Processed: ${input}`;\n\n            // Cache the result\n            cache.set(cacheKey, result);\n            Chat.log(`Cached result for: ${input}`);\n\n            return result;\n        }));",
        "// Create a chain of method calls with validation\n    builder.addMethod(\"append(Ljava/lang/String;)Ljava/lang/StringBuilder;\",\n        JavaWrapper.methodToJava((ref, args) => {\n            const str = args[0];\n\n            // Input validation\n            if (str === null) {\n                throw new Error(\"Cannot append null string\");\n            }\n\n            const strValue = str.toString();\n            if (strValue.length === 0) {\n                Chat.log(\"[CHAIN] Skipping empty string\");\n                return ref.parent; // Return current instance without calling parent\n            }\n\n            // Pre-processing\n            Chat.log(`[CHAIN] Appending: \"${strValue}\" (length: ${strValue.length})`);\n\n            // Call original method\n            const result = ref.parent ? ref.parent([str]) : null;\n\n            // Post-processing\n            if (result) {\n                const newLength = result.invokeMethod(\"length\");\n                Chat.log(`[CHAIN] New string length: ${newLength}`);\n            }\n\n            return result;\n        }));",
        "// Robust get() method with error handling\n    builder.addMethod(\"get(Ljava/lang/Object;)Ljava/lang/Object;\",\n        JavaWrapper.methodToJava((ref, args) => {\n            const key = args[0];\n\n            try {\n                // Try to call original method\n                if (ref.parent) {\n                    return ref.parent([key]);\n                }\n            } catch (error) {\n                Chat.log(`[ROBUST] Error getting key ${key}: ${error.message}`);\n            }\n\n            // Fallback behavior\n            Chat.log(`[ROBUST] Using fallback for key ${key}`);\n            return `FALLBACK_VALUE_FOR_${key}`;\n        }));",
        "builder.addMethod(\"someMethod()Ljava/lang/Object;\",\n    JavaWrapper.methodToJava((ref, args) => {\n        // Always check if parent method is available\n        if (ref.parent) {\n            try {\n                return ref.parent();\n            } catch (error) {\n                Chat.log(`Error calling parent method: ${error.message}`);\n                // Fallback or rethrow as appropriate\n            }\n        } else {\n            Chat.log(\"No parent implementation available\");\n            // Provide default behavior\n        }\n\n        return null; // Default return value\n    }));",
        "builder.addMethod(\"methodWithParams(IILjava/lang/String;)V\",\n    JavaWrapper.methodToJava((ref, args) => {\n        const int1 = args[0];\n        const int2 = args[1];\n        const str = args[2];\n\n        // Call parent with same parameters in same order\n        if (ref.parent) {\n            ref.parent([int1, int2, str]); // Maintain original order\n        }\n    }));"
      ]
    }
  ]
}