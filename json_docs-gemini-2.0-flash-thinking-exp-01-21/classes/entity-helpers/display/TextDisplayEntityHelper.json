{
  "name": "TextDisplayEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.display.TextDisplayEntityHelper",
  "extends": "DisplayEntityHelper<TextDisplayEntity>",
  "since": "JSMacros 1.9.1",
  "description": "The `TextDisplayEntityHelper` class is a specialized wrapper for Minecraft text display entities (introduced in 1.19.4), providing access to text-specific properties such as text content, alignment, colors, background, and visual effects. Text display entities allow you to display formatted text in the world with advanced customization options for positioning, rotation, scaling, and text styling.",
  "overview": "Text display entities are special entities used to show customizable text in the 3D world, perfect for creating signs, labels, floating text, HUD elements, or decorative text displays. This class is typically obtained through entity-related events, world queries with text display filtering, or by casting from a generic EntityHelper.",
  "constructors": [
    {
      "signature": "",
      "description": "TextDisplayEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through: Entity-related events (e.g., `EntitySpawn`, `EntityInteract`), World entity queries with text display filtering, Methods that return entities and can be cast to text display entities, or Entity type checking with `entity.is(\"minecraft:text_display\")`.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "getData",
      "signature": "getData(): TextDisplayDataHelper",
      "returnType": "TextDisplayDataHelper",
      "description": "Returns a `TextDisplayDataHelper` object, which provides access to all text-specific properties and display settings of the text display entity. This includes text content, alignment, colors, background, and visual effects. This method may return `null` if the entity is in an invalid state or the text data is not available.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Find all text display entities in range\nfunction findTextDisplayEntities(range = 50) {\n    const player = Player.getPlayer();\n    if (!player) return [];\n\n    const entities = World.getEntities();\n    const textDisplays = [];\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= range && entity.is(\"minecraft:text_display\")) {\n            textDisplays.push(entity);\n        }\n    });\n\n    return textDisplays;\n}\n\n// Log all nearby text display entities\nconst textDisplays = findTextDisplayEntities();\nChat.log(`Found ${textDisplays.length} text display entities:`);\n\ntextDisplays.forEach((entity, index) => {\n    const pos = entity.getPos();\n    const textDisplay = entity.asTextDisplay();\n    const data = textDisplay.getData();\n\n    if (data) {\n        const text = data.getText().getString();\n        const alignment = data.getAlignment();\n\n        Chat.log(`${index + 1}. \"${text}\" (${alignment}) at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n    }\n});",
        "// Create comprehensive information panel for text display entities\nfunction getTextDisplayInfo(entity) {\n    const textDisplay = entity.asTextDisplay();\n    const data = textDisplay.getData();\n\n    if (!data) return [\"No text data available\"];\n\n    const text = data.getText().getString();\n    const alignment = data.getAlignment();\n    const lineWidth = data.getLineWidth();\n    const opacity = data.getTextOpacity();\n    const bgColor = data.getBackgroundColor();\n    const hasShadow = data.hasShadowFlag();\n    const isSeeThrough = data.hasSeeThroughFlag();\n    const hasDefaultBg = data.hasDefaultBackgroundFlag();\n\n    let info = [];\n    info.push(`=== Text Display: \"${text}\" ===`);\n    info.push(`Alignment: ${alignment}`);\n    info.push(`Line Width: ${lineWidth}px`);\n    info.push(`Opacity: ${opacity}/255 (${(opacity/255*100).toFixed(1)}%)`);\n\n    // Background information\n    if (hasDefaultBg) {\n        info.push(`Background: Default dark background`);\n    } else if (bgColor !== 0) {\n        const alpha = (bgColor >> 24) & 0xFF;\n        const red = (bgColor >> 16) & 0xFF;\n        const green = (bgColor >> 8) & 0xFF;\n        const blue = bgColor & 0xFF;\n        info.push(`Background: Custom #${((1<<24)+(red<<16)+(green<<8)+blue).toString(16).slice(1).toUpperCase()}`);\n    } else {\n        info.push(`Background: None`);\n    }\n\n    // Effects\n    const effects = [];\n    if (hasShadow) effects.push(\"Shadow\");\n    if (isSeeThrough) effects.push(\"See-through\");\n    if (effects.length > 0) {\n        info.push(`Effects: ${effects.join(\", \")}`);\n    }\n\n    return info;\n}\n\n// Display information for the nearest text display entity\nconst player = Player.getPlayer();\nif (player) {\n    const textDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:text_display\"));\n\n    let nearest = null;\n    let minDistance = Infinity;\n\n    textDisplays.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance < minDistance) {\n            minDistance = distance;\n            nearest = entity;\n        }\n    });\n\n    if (nearest && minDistance <= 20) {\n        const info = getTextDisplayInfo(nearest);\n        info.forEach(line => Chat.log(line));\n        Chat.log(`Distance: ${minDistance.toFixed(1)} blocks`);\n    } else {\n        Chat.log(\"No text display entities found within 20 blocks\");\n    }\n}",
        "// Analyze all text display entities in the world\nfunction analyzeTextDisplays() {\n    const textDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:text_display\"));\n\n    const stats = {\n        total: textDisplays.length,\n        byAlignment: { center: 0, left: 0, right: 0 },\n        withBackground: 0,\n        withShadow: 0,\n        seeThrough: 0,\n        averageLineWidth: 0,\n        empty: 0\n    };\n\n    const allLineWidths = [];\n    const textContents = [];\n\n    textDisplays.forEach(entity => {\n        const textDisplay = entity.asTextDisplay();\n        const data = textDisplay.getData();\n\n        if (data) {\n            const alignment = data.getAlignment();\n            const lineWidth = data.getLineWidth();\n            const text = data.getText().getString();\n            const hasDefaultBg = data.hasDefaultBackgroundFlag();\n            const hasCustomBg = data.getBackgroundColor() !== 0;\n            const hasShadow = data.hasShadowFlag();\n            const isSeeThrough = data.hasSeeThroughFlag();\n\n            // Update statistics\n            stats.byAlignment[alignment]++;\n            stats.averageLineWidth += lineWidth;\n            allLineWidths.push(lineWidth);\n\n            if (hasDefaultBg || hasCustomBg) stats.withBackground++;\n            if (hasShadow) stats.withShadow++;\n            if (isSeeThrough) stats.seeThrough++;\n\n            if (!text || text.trim() === \"\") {\n                stats.empty++;\n            } else {\n                textContents.push(text);\n            }\n        }\n    });\n\n    // Calculate averages\n    if (textDisplays.length > 0) {\n        stats.averageLineWidth = stats.averageLineWidth / textDisplays.length;\n    }\n\n    // Display results\n    Chat.log(\"=== Text Display Analytics ===\");\n    Chat.log(`Total text displays: ${stats.total}`);\n    Chat.log(`Empty text displays: ${stats.empty}`);\n    Chat.log(`Non-empty text displays: ${stats.total - stats.empty}`);\n\n    Chat.log(\"\\nBy Alignment:\");\n    Chat.log(`  Center: ${stats.byAlignment.center}`);\n    Chat.log(`  Left: ${stats.byAlignment.left}`);\n    Chat.log(`  Right: ${stats.byAlignment.right}`);\n\n    Chat.log(\"\\nVisual Features:\");\n    Chat.log(`  With background: ${stats.withBackground} (${(stats.withBackground/stats.total*100).toFixed(1)}%)`);\n    Chat.log(`  With shadow: ${stats.withShadow} (${(stats.withShadow/stats.total*100).toFixed(1)}%)`);\n    Chat.log(`  See-through: ${stats.seeThrough} (${(stats.seeThrough/stats.total*100).toFixed(1)}%)`);\n\n    if (allLineWidths.length > 0) {\n        const minWidth = Math.min(...allLineWidths);\n        const maxWidth = Math.max(...allLineWidths);\n        Chat.log(`\\nLine width statistics:`);\n        Chat.log(`  Average: ${stats.averageLineWidth.toFixed(0)}px`);\n        Chat.log(`  Range: ${minWidth}px - ${maxWidth}px`);\n    }\n\n    // Display sample text contents\n    if (textContents.length > 0) {\n        Chat.log(\"\\nSample text contents:\");\n        textContents.slice(0, 5).forEach((text, index) => {\n            Chat.log(`  ${index + 1}. \"${text}\"`);\n        });\n        if (textContents.length > 5) {\n            Chat.log(`  ... and ${textContents.length - 5} more`);\n        }\n    }\n}\n\nanalyzeTextDisplays();",
        "// Monitor text display entities for potential issues\nfunction checkTextDisplayQuality(entity) {\n    const textDisplay = entity.asTextDisplay();\n    const data = textDisplay.getData();\n\n    if (!data) return [];\n\n    const issues = [];\n    const suggestions = [];\n\n    const text = data.getText().getString();\n    const alignment = data.getAlignment();\n    const lineWidth = data.getLineWidth();\n    const opacity = data.getTextOpacity();\n    const hasDefaultBg = data.hasDefaultBackgroundFlag();\n    const hasCustomBg = data.getBackgroundColor() !== 0;\n    const hasShadow = data.hasShadowFlag();\n\n    // Check for common issues\n    if (!text || text.trim() === \"\") {\n        issues.push(\"Text is empty - consider removing the entity or adding content\");\n    }\n\n    if (opacity < 50) {\n        issues.push(\"Text is very transparent - might be hard to read\");\n    } else if (opacity < 128) {\n        suggestions.push(\"Text is semi-transparent - ensure good contrast with background\");\n    }\n\n    if (!hasDefaultBg && !hasCustomBg && !hasShadow) {\n        suggestions.push(\"Consider adding shadow or background for better readability\");\n    }\n\n    if (lineWidth > 0 && lineWidth < 100) {\n        suggestions.push(\"Line width is quite narrow - text might appear cramped\");\n    } else if (lineWidth > 400) {\n        suggestions.push(\"Line width is very wide - consider using multiple lines or center alignment\");\n    }\n\n    // Alignment-specific suggestions\n    if (alignment === \"center\" && lineWidth > 300) {\n        suggestions.push(\"Consider left alignment for very wide text to improve readability\");\n    }\n\n    if (alignment === \"right\" && !hasShadow) {\n        suggestions.push(\"Right-aligned text often benefits from shadow for better edge definition\");\n    }\n\n    return { issues, suggestions };\n}\n\n// Check quality of all text displays\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        const textDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:text_display\"));\n\n        textDisplays.forEach(entity => {\n            const quality = checkTextDisplayQuality(entity);\n            const pos = entity.getPos();\n\n            if (quality.issues.length > 0) {\n                Chat.log(`&cIssues with text display at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]:`);\n                quality.issues.forEach(issue => Chat.log(`  - ${issue}`));\n            }\n\n            if (quality.suggestions.length > 0) {\n                Chat.log(`&eSuggestions for text display at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]:`);\n                quality.suggestions.forEach(suggestion => Chat.log(`  - ${suggestion}`));\n            }\n        });\n    }\n}));",
        "// Track changes in text display entities over time\nclass TextDisplayTracker {\n    constructor() {\n        this.trackedEntities = new Map();\n    }\n\n    startTracking(entity) {\n        const uuid = entity.getUUID();\n        const textDisplay = entity.asTextDisplay();\n        const data = textDisplay.getData();\n\n        if (data) {\n            const text = data.getText().getString();\n            this.trackedEntities.set(uuid, {\n                entity: entity,\n                lastText: text,\n                lastUpdate: Client.getTime(),\n                changeCount: 0\n            });\n\n            Chat.log(`Started tracking text display: \"${text}\"`);\n        }\n    }\n\n    updateTracking() {\n        for (const [uuid, data] of this.trackedEntities) {\n            if (!data.entity.isAlive()) {\n                Chat.log(`Tracked text display has been removed`);\n                this.trackedEntities.delete(uuid);\n                continue;\n            }\n\n            const textDisplay = data.entity.asTextDisplay();\n            const currentData = textDisplay.getData();\n\n            if (currentData) {\n                const currentText = currentData.getText().getString();\n\n                if (currentText !== data.lastText) {\n                    Chat.log(`Text display content changed:`);\n                    Chat.log(`  From: \"${data.lastText}\"`);\n                    Chat.log(`  To: \"${currentText}\"`);\n\n                    data.lastText = currentText;\n                    data.lastUpdate = Client.getTime();\n                    data.changeCount++;\n                }\n            }\n        }\n    }\n\n    getTrackedEntityCount() {\n        return this.trackedEntities.size;\n    }\n\n    getTotalChanges() {\n        let total = 0;\n        for (const [, data] of this.trackedEntities) {\n            total += data.changeCount;\n        }\n        return total;\n    }\n}\n\nconst tracker = new TextDisplayTracker();\n\n// Track text displays when they spawn\nevents.on(\"EntitySpawn\", JavaWrapper.methodToJavaAsync((event) => {\n    const entity = event.getEntity();\n\n    if (entity.is(\"minecraft:text_display\")) {\n        tracker.startTracking(entity);\n    }\n}));\n\n// Update tracking every second\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 20 === 0) { // Every 20 ticks\n        tracker.updateTracking();\n\n        if (tracker.getTrackedEntityCount() > 0) {\n            Chat.actionbar(`Tracking ${tracker.getTrackedEntityCount()} text displays, ${tracker.getTotalChanges()} total changes`);\n        }\n    }\n}));"
      ]
    }
  ]
}