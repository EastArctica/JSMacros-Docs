{
  "name": "ItemDisplayEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.display.ItemDisplayEntityHelper",
  "extends": "DisplayEntityHelper<DisplayEntity.ItemDisplayEntity>",
  "since": "1.9.1",
  "description": "The `ItemDisplayEntityHelper` class is a specialized wrapper for Minecraft item display entities (introduced in 1.19.4), providing access to item-specific properties and display settings. This class extends `DisplayEntityHelper` and adds methods for retrieving the displayed item stack and transformation mode that control how the item is presented in the world.",
  "overview": "Item display entities are special entities used to display items in the world with advanced customization options for positioning, rotation, scaling, and visual effects. They are commonly used for item showcases, floating item displays, custom item frames, and decorative item presentations. This class is typically obtained through entity-related events, world queries, or when specifically filtering for item display entity types.",
  "constructors": [],
  "methods": [
    {
      "name": "getItem",
      "signature": "getItem()",
      "returnType": "ItemStackHelper",
      "description": "Retrieves the item stack displayed by this entity. The returned item stack provides full access to item properties including NBT data, enchantments, and custom names.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Find all item display entities in range\nfunction findItemDisplayEntities(range = 50) {\n    const player = Player.getPlayer();\n    if (!player) return [];\n\n    const entities = World.getEntities();\n    const itemDisplays = [];\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= range && entity.is(\"minecraft:item_display\")) {\n            itemDisplays.push(entity);\n        }\n    });\n\n    return itemDisplays;\n}\n\n// Comprehensive item display analysis\nfunction analyzeItemDisplay(entity) {\n    const item = entity.getItem();\n    const transform = entity.getTransform();\n    const pos = entity.getPos();\n    const billboardMode = entity.getBillboardMode();\n    const glowColor = entity.getGlowColorOverride();\n\n    let analysis = [];\n    analysis.push(`=== Item Display: ${item.getName()} ===`);\n    analysis.push(`Position: [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n    analysis.push(`Count: ${item.getCount()}`);\n    analysis.push(`Transform: ${transform || \"default\"}`);\n    analysis.push(`Billboard: ${billboardMode}`);\n\n    if (glowColor !== 0) {\n        analysis.push(`Glow: #${glowColor.toString(16).padStart(6, '0').toUpperCase()}`);\n    }\n\n    // Item-specific analysis\n    if (item.isDamaged()) {\n        const durabilityPercent = ((item.getMaxDamage() - item.getDamage()) / item.getMaxDamage()) * 100;\n        analysis.push(`Durability: ${durabilityPercent.toFixed(1)}%`);\n    }\n\n    if (item.hasEnchantments()) {\n        const enchCount = item.getEnchantments().size();\n        analysis.push(`Enchantments: ${enchCount}`);\n    }\n\n    if (item.hasCustomName()) {\n        analysis.push(`Custom Name: ${item.getCustomName().getString()}`);\n    }\n\n    return analysis;\n}\n\n// Display all item displays in range\nconst itemDisplays = findItemDisplayEntities();\nChat.log(`Found ${itemDisplays.length} item display entities:`);\n\nitemDisplays.forEach((entity, index) => {\n    const analysis = analyzeItemDisplay(entity);\n    analysis.forEach(line => Chat.log(line));\n    Chat.log(\"\");\n});",
        "// Create a system to showcase items with different transforms\nclass ItemShowcase {\n    constructor() {\n        this.showcases = [];\n    }\n\n    // Analyze existing showcases\n    scanShowcases() {\n        const itemDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:item_display\"));\n\n        this.showcases = itemDisplays.map(entity => {\n            const item = entity.getItem();\n            const transform = entity.getTransform();\n            const pos = entity.getPos();\n\n            return {\n                entity: entity,\n                item: item,\n                transform: transform || \"default\",\n                position: pos,\n                itemName: item.getName(),\n                description: this.generateDescription(entity)\n            };\n        });\n\n        return this.showcases;\n    }\n\n    generateDescription(entity) {\n        const item = entity.getItem();\n        const transform = entity.getTransform();\n\n        let desc = [];\n\n        // Basic info\n        desc.push(`${item.getName()} x${item.getCount()}`);\n\n        // Transform description\n        if (transform) {\n            switch (transform) {\n                case \"head\":\n                    desc.push(\"Wearable display\");\n                    break;\n                case \"thirdperson_righthand\":\n                    desc.push(\"Held in right hand\");\n                    break;\n                case \"thirdperson_lefthand\":\n                    desc.push(\"Held in left hand\");\n                    break;\n                case \"gui\":\n                    desc.push(\"Flat GUI display\");\n                    break;\n                case \"ground\":\n                    desc.push(\"Ground-spawned appearance\");\n                    break;\n                default:\n                    desc.push(`Transform: ${transform}`);\n            }\n        }\n\n        // Special properties\n        if (item.hasEnchantments()) {\n            const enchNames = item.getEnchantments().map(e => e.getName()).join(\", \");\n            desc.push(`Enchanted: ${enchNames}`);\n        }\n\n        if (item.hasCustomName()) {\n            desc.push(`Named: ${item.getCustomName().getString()}`);\n        }\n\n        return desc.join(\" • \");\n    }\n\n    // Find showcases by item type\n    findShowcasesByItem(itemId) {\n        return this.showcases.filter(showcase => showcase.item.getId() === itemId);\n    }\n\n    // Find showcases by transform type\n    findShowcasesByTransform(transform) {\n        return this.showcases.filter(showcase => showcase.transform === transform);\n    }\n\n    // Display showcase summary\n    displaySummary() {\n        if (this.showcases.length === 0) {\n            Chat.log(\"No item display showcases found.\");\n            return;\n        }\n\n        Chat.log(`=== Item Showcase Summary ===`);\n        Chat.log(`Total showcases: ${this.showcases.length}`);\n\n        // Group by transform type\n        const transformGroups = {};\n        this.showcases.forEach(showcase => {\n            const transform = showcase.transform;\n            if (!transformGroups[transform]) {\n                transformGroups[transform] = [];\n            }\n            transformGroups[transform].push(showcase);\n        });\n\n        Object.entries(transformGroups).forEach(([transform, showcases]) => {\n            Chat.log(`\\n${transform.toUpperCase()} (${showcases.length}):`);\n            showcases.forEach(showcase => {\n                const pos = showcase.position;\n                Chat.log(`  • ${showcase.itemName} at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            });\n        });\n\n        Chat.log(\"=============================\");\n    }\n}\n\n// Usage example\nconst showcase = new ItemShowcase();\nshowcase.scanShowcases();\nshowcase.displaySummary();\n\n// Find specific showcase types\nconst headDisplays = showcase.findShowcasesByTransform(\"head\");\nChat.log(`Found ${headDisplays.length} head displays`);\n\nconst swordShowcases = showcase.findShowcasesByItem(\"minecraft:diamond_sword\");\nChat.log(`Found ${swordShowcases.length} diamond sword showcases`);",
        "// Compare different item display transformations\nfunction compareItemTransforms() {\n    const itemDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:item_display\"));\n\n    if (itemDisplays.length < 2) {\n        Chat.log(\"Need at least 2 item display entities to compare\");\n        return;\n    }\n\n    // Group by item type for fair comparison\n    const itemGroups = {};\n    itemDisplays.forEach(entity => {\n        const itemId = entity.getItem().getId();\n        if (!itemGroups[itemId]) {\n            itemGroups[itemId] = [];\n        }\n        itemGroups[itemId].push(entity);\n    });\n\n    Chat.log(\"=== Item Display Transform Comparison ===\");\n\n    Object.entries(itemGroups).forEach(([itemId, entities]) => {\n        if (entities.length > 1) {\n            const itemName = entities[0].getItem().getName();\n            Chat.log(`\\n${itemName} variations:`);\n\n            entities.forEach(entity => {\n                const transform = entity.getTransform() || \"default\";\n                const pos = entity.getPos();\n                const billboard = entity.getBillboardMode();\n                const glow = entity.getGlowColorOverride();\n\n                let details = [`  ${transform}:`];\n                details.push(`    Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n                details.push(`    Billboard: ${billboard}`);\n\n                if (glow !== 0) {\n                    details.push(`    Glow: #${glow.toString(16).padStart(6, '0').toUpperCase()}`);\n                }\n\n                details.forEach(detail => Chat.log(detail));\n            });\n        }\n    });\n\n    Chat.log(\"========================================\");\n}\n\n// Analyze item display effectiveness\nfunction analyzeDisplayEffectiveness() {\n    const itemDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:item_display\"));\n    const player = Player.getPlayer();\n\n    if (!player) return;\n\n    Chat.log(\"=== Item Display Effectiveness Analysis ===\");\n\n    itemDisplays.forEach(entity => {\n        const item = entity.getItem();\n        const pos = entity.getPos();\n        const distance = player.distanceTo(entity);\n        const viewRange = entity.getViewRange();\n        const transform = entity.getTransform();\n        const glow = entity.getGlowColorOverride();\n\n        let effectiveness = 0;\n        let notes = [];\n\n        // Distance factor\n        if (distance <= viewRange) {\n            effectiveness += 30;\n            notes.push(\"Within view range\");\n        } else {\n            notes.push(\"Outside view range\");\n        }\n\n        // Transform appropriateness\n        if (transform === \"head\" && item.getItem().isWearable()) {\n            effectiveness += 20;\n            notes.push(\"Appropriate head display\");\n        } else if (transform === \"thirdperson_righthand\" && item.getItem().isTool()) {\n            effectiveness += 15;\n            notes.push(\"Appropriate hand display\");\n        }\n\n        // Glow effect\n        if (glow !== 0) {\n            effectiveness += 25;\n            notes.push(\"Has glow effect\");\n        }\n\n        // Billboard mode\n        const billboard = entity.getBillboardMode();\n        if (billboard === \"center\" || billboard === \"fixed\") {\n            effectiveness += 15;\n            notes.push(\"Good billboard mode\");\n        }\n\n        // Rarity/value factor\n        if (item.hasEnchantments()) {\n            effectiveness += 10;\n            notes.push(\"Enchanted item\");\n        }\n\n        // Results\n        const itemInfo = `${item.getName()} at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`;\n        const effectivenessLevel = effectiveness >= 70 ? \"Excellent\" :\n                                effectiveness >= 50 ? \"Good\" :\n                                effectiveness >= 30 ? \"Fair\" : \"Poor\";\n\n        Chat.log(`\\n${itemInfo}`);\n        Chat.log(`Effectiveness: ${effectivenessLevel} (${effectiveness}/100)`);\n        Chat.log(`Notes: ${notes.join(\", \")}`);\n    });\n\n    Chat.log(\"===========================================\");\n}\n\n// Run analyses\ncompareItemTransforms();\nanalyzeDisplayEffectiveness();",
        "// Monitor item display entities for changes\nclass ItemDisplayMonitor {\n    constructor() {\n        this.lastSeen = new Map();\n        this.changes = [];\n    }\n\n    // Take a snapshot of current item displays\n    takeSnapshot() {\n        const itemDisplays = World.getEntities().filter(entity => entity.is(\"minecraft:item_display\"));\n        const current = new Map();\n\n        itemDisplays.forEach(entity => {\n            const uuid = entity.getUUID();\n            const item = entity.getItem();\n            const transform = entity.getTransform();\n\n            current.set(uuid, {\n                entity: entity,\n                itemName: item.getName(),\n                itemCount: item.getCount(),\n                transform: transform || \"default\",\n                position: entity.getPos(),\n                damaged: item.isDamaged(),\n                enchanted: item.hasEnchantments(),\n                named: item.hasCustomName()\n            });\n        });\n\n        // Check for changes\n        this.detectChanges(this.lastSeen, current);\n        this.lastSeen = current;\n    }\n\n    detectChanges(previous, current) {\n        // New displays\n        for (const [uuid, data] of current) {\n            if (!previous.has(uuid)) {\n                this.changes.push({\n                    type: \"spawned\",\n                    uuid: uuid,\n                    data: data\n                });\n            }\n        }\n\n        // Removed displays\n        for (const [uuid, data] of previous) {\n            if (!current.has(uuid)) {\n                this.changes.push({\n                    type: \"removed\",\n                    uuid: uuid,\n                    data: data\n                });\n            }\n        }\n\n        // Modified displays\n        for (const [uuid, currentData] of current) {\n            const previousData = previous.get(uuid);\n            if (previousData) {\n                const changes = [];\n\n                if (previousData.itemName !== currentData.itemName) {\n                    changes.push(`Item changed: ${previousData.itemName} → ${currentData.itemName}`);\n                }\n\n                if (previousData.itemCount !== currentData.itemCount) {\n                    changes.push(`Count changed: ${previousData.itemCount} → ${currentData.itemCount}`);\n                }\n\n                if (previousData.transform !== currentData.transform) {\n                    changes.push(`Transform changed: ${previousData.transform} → ${currentData.transform}`);\n                }\n\n                if (Math.abs(previousData.position.x - currentData.position.x) > 0.1 ||\n                    Math.abs(previousData.position.y - currentData.position.y) > 0.1 ||\n                    Math.abs(previousData.position.z - currentData.position.z) > 0.1) {\n                    changes.push(\"Position moved\");\n                }\n\n                if (previousData.damaged !== currentData.damaged) {\n                    changes.push(`Damage status changed: ${currentData.damaged ? \"Now damaged\" : \"Now undamaged\"}`);\n                }\n\n                if (previousData.enchanted !== currentData.enchanted) {\n                    changes.push(`Enchantment status changed: ${currentData.enchanted ? \"Now enchanted\" : \"Enchantments removed\"}`);\n                }\n\n                if (changes.length > 0) {\n                    this.changes.push({\n                        type: \"modified\",\n                        uuid: uuid,\n                        data: currentData,\n                        changes: changes\n                    });\n                }\n            }\n        }\n    }\n\n    // Report recent changes\n    reportChanges() {\n        if (this.changes.length === 0) {\n            Chat.log(\"No changes detected in item displays\");\n            return;\n        }\n\n        Chat.log(`=== Item Display Changes (${this.changes.length}) ===`);\n\n        this.changes.forEach(change => {\n            const data = change.data;\n\n            switch (change.type) {\n                case \"spawned\":\n                    Chat.log(`+ Spawned: ${data.itemName} at [${data.position.x.toFixed(0)}, ${data.position.y.toFixed(0)}, ${data.position.z.toFixed(0)}]`);\n                    break;\n\n                case \"removed\":\n                    Chat.log(`- Removed: ${data.itemName} (was at [${data.position.x.toFixed(0)}, ${data.position.y.toFixed(0)}, ${data.position.z.toFixed(0)}])`);\n                    break;\n\n                case \"modified\":\n                    Chat.log(`~ Modified: ${data.itemName}`);\n                    change.changes.forEach(changeDetail => {\n                        Chat.log(`  • ${changeDetail}`);\n                    });\n                    break;\n            }\n        });\n\n        Chat.log(\"=======================================\");\n        this.changes = []; // Clear changes after reporting\n    }\n}\n\n// Set up monitoring\nconst monitor = new ItemDisplayMonitor();\n\n// Initial snapshot\nmonitor.takeSnapshot();\n\n// Monitor every 5 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 100 === 0) { // Every 5 seconds (100 ticks)\n        monitor.takeSnapshot();\n        monitor.reportChanges();\n    }\n}));"
      ]
    },
    {
      "name": "getTransform",
      "signature": "getTransform()",
      "returnType": "String",
      "description": "Retrieves the transformation mode that controls how the item is presented in the world (e.g., 'head', 'thirdperson_righthand', 'gui', 'ground'). This method may return `null` for entities that use the default transformation mode.",
      "parameters": [],
      "static": false,
      "examples": []
    }
  ]
}