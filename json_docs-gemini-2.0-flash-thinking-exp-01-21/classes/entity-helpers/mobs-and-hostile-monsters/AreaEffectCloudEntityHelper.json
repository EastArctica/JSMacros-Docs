{
  "name": "AreaEffectCloudEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.other.AreaEffectCloudEntityHelper",
  "extends": "EntityHelper<AreaEffectCloudEntity>",
  "since": "JsMacros 1.8.4",
  "description": "The `AreaEffectCloudEntityHelper` class provides specialized access to Minecraft area effect cloud entities (also known as lingering potions). These entities are created when splash potions or lingering potions are thrown, creating a cloud that applies effects to entities passing through them. This helper extends the base `EntityHelper` class and adds specific functionality for inspecting cloud properties like radius, color, particle effects, and waiting state.",
  "overview": "Area effect clouds are commonly used in combat, area denial, and status effect application in Minecraft. They persist for a duration and can affect multiple entities within their radius with various potion effects.",
  "constructors": [
    {
      "signature": "AreaEffectCloudEntityHelper()",
      "description": "AreaEffectCloudEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through: Entity-related events when the entity is an area effect cloud; World entity queries and searches for lingering potion clouds; Entity casting using type checking with `is(\"minecraft:area_effect_cloud\")`.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "getRadius",
      "signature": "float getRadius()",
      "returnType": "float",
      "description": "Returns the current radius of the area effect cloud.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "getColor",
      "signature": "int getColor()",
      "returnType": "int",
      "description": "Returns the color of the area effect cloud as an ARGB integer.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "getColor",
      "signature": "int getColor()",
      "returnType": "int",
      "description": "Returns the color of the area effect cloud as an ARGB integer.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "getParticleType",
      "signature": "String getParticleType()",
      "returnType": "String",
      "description": "Returns the type of particles emitted by the area effect cloud as a string identifier.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));"
      ]
    },
    {
      "name": "isWaiting",
      "signature": "boolean isWaiting()",
      "returnType": "boolean",
      "description": "Checks if the area effect cloud is currently in a waiting state before applying effects.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "isWaiting",
      "signature": "boolean isWaiting()",
      "returnType": "boolean",
      "description": "Checks if the area effect cloud is currently in a waiting state before applying effects.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "getPos",
      "signature": "Pos3D getPos()",
      "returnType": "Pos3D",
      "description": "Returns the cloud's position as `Pos3D`.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));",
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "getBlockPos",
      "signature": "BlockPosHelper getBlockPos()",
      "returnType": "BlockPosHelper",
      "description": "Returns the cloud's block position as `BlockPosHelper`.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getX",
      "signature": "double getX()",
      "returnType": "double",
      "description": "Returns the X coordinate value of the cloud's position.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getY",
      "signature": "double getY()",
      "returnType": "double",
      "description": "Returns the Y coordinate value of the cloud's position.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getZ",
      "signature": "double getZ()",
      "returnType": "double",
      "description": "Returns the Z coordinate value of the cloud's position.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getVelocity",
      "signature": "Vec3d getVelocity()",
      "returnType": "Vec3d",
      "description": "Returns the cloud's movement velocity.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getName",
      "signature": "TextHelper getName()",
      "returnType": "TextHelper",
      "description": "Returns the cloud's name as `TextHelper`.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getType",
      "signature": "String getType()",
      "returnType": "String",
      "description": "Returns the entity type as string.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getUUID",
      "signature": "String getUUID()",
      "returnType": "String",
      "description": "Returns the unique identifier of the cloud.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Track area effect cloud creation, changes, and removal\nconst cloudLifecycles = new Map();\n\nfunction trackCloudLifecycles() {\n    const entities = World.getEntities();\n    const currentClouds = new Set();\n\n    // Find current clouds and track changes\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const uuid = entity.getUUID();\n            const cloud = entity;\n            const pos = entity.getPos();\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const isWaiting = cloud.isWaiting();\n\n            currentClouds.add(uuid);\n\n            if (!cloudLifecycles.has(uuid)) {\n                // New cloud detected\n                Chat.log(`&aNew area effect cloud created at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n                Chat.log(`  Radius: ${radius.toFixed(1)}m, Color: #${color.toString(16).padStart(6, '0')}`);\n\n                cloudLifecycles.set(uuid, {\n                    startTime: Client.getTime(),\n                    startPosition: pos,\n                    initialRadius: radius,\n                    initialColor: color,\n                    lastRadius: radius,\n                    lastColor: color,\n                    lastState: isWaiting,\n                    stateChanges: 0,\n                    maxRadius: radius,\n                    minRadius: radius\n                });\n            } else {\n                // Existing cloud - track changes\n                const lifecycle = cloudLifecycles.get(uuid);\n                let hasChanges = false;\n\n                // Track radius changes\n                if (Math.abs(radius - lifecycle.lastRadius) > 0.1) {\n                    Chat.log(`&eCloud radius changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: ${lifecycle.lastRadius.toFixed(1)} → ${radius.toFixed(1)}m`);\n                    lifecycle.lastRadius = radius;\n                    hasChanges = true;\n\n                    // Update min/max radius\n                    lifecycle.maxRadius = Math.max(lifecycle.maxRadius, radius);\n                    lifecycle.minRadius = Math.min(lifecycle.minRadius, radius);\n                }\n\n                // Track color changes\n                if (color !== lifecycle.lastColor) {\n                    Chat.log(`&eCloud color changed at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]: #${lifecycle.lastColor.toString(16).padStart(6, '0')} → #${color.toString(16).padStart(6, '0')}`);\n                    lifecycle.lastColor = color;\n                    hasChanges = true;\n                }\n\n                // Track state changes\n                if (isWaiting !== lifecycle.lastState) {\n                    lifecycle.stateChanges++;\n                    lifecycle.lastState = isWaiting;\n                    hasChanges = true;\n                }\n\n                if (hasChanges) {\n                    const age = (Client.getTime() - lifecycle.startTime) / 20;\n                    Chat.log(`  Cloud age: ${age.toFixed(1)} seconds, State changes: ${lifecycle.stateChanges}`);\n                }\n            }\n        }\n    });\n\n    // Check for removed clouds\n    for (const [uuid, lifecycle] of cloudLifecycles.entries()) {\n        if (!currentClouds.has(uuid)) {\n            const age = (Client.getTime() - lifecycle.startTime) / 20;\n            Chat.log(`&cArea effect cloud removed after ${age.toFixed(1)} seconds`);\n            Chat.log(`  Initial position: [${lifecycle.startPosition.x.toFixed(1)}, ${lifecycle.startPosition.y.toFixed(1)}, ${lifecycle.startPosition.z.toFixed(1)}]`);\n            Chat.log(`  Radius range: ${lifecycle.minRadius.toFixed(1)} - ${lifecycle.maxRadius.toFixed(1)}m`);\n            Chat.log(`  State changes: ${lifecycle.stateChanges}`);\n\n            cloudLifecycles.delete(uuid);\n        }\n    }\n\n    // Display summary\n    if (Client.getTime() % 200 === 0) { // Every 10 seconds\n        Chat.log(`&7Currently tracking ${cloudLifecycles.size} area effect clouds`);\n    }\n}\n\n// Continuous lifecycle tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 5 === 0) { // Every 0.25 seconds for responsive tracking\n        trackCloudLifecycles();\n    }\n}));"
      ]
    },
    {
      "name": "isAlive",
      "signature": "boolean isAlive()",
      "returnType": "boolean",
      "description": "Checks if the cloud is still active.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "setGlowing",
      "signature": "void setGlowing(boolean glowing)",
      "returnType": "void",
      "description": "Sets whether the cloud should glow.",
      "parameters": [
        {
          "name": "glowing",
          "type": "boolean",
          "description": "True to make the cloud glow, false otherwise."
        }
      ],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));"
      ]
    },
    {
      "name": "setGlowingColor",
      "signature": "void setGlowingColor(int color)",
      "returnType": "void",
      "description": "Sets the glowing effect color.",
      "parameters": [
        {
          "name": "color",
          "type": "int",
          "description": "The ARGB color integer for the glowing effect."
        }
      ],
      "static": false,
      "examples": [
        "// Complete area effect cloud analysis system\nfunction scanAllClouds() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const clouds = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const radius = cloud.getRadius();\n            const color = cloud.getColor();\n            const particleType = cloud.getParticleType();\n            const isWaiting = cloud.isWaiting();\n\n            const cloudData = {\n                entity: entity,\n                position: pos,\n                distance: distance,\n                radius: radius,\n                color: color,\n                hexColor: `#${color.toString(16).padStart(6, '0')}`,\n                particleType: particleType,\n                isWaiting: isWaiting,\n                isInRange: distance <= radius + 1,\n                dangerLevel: 0\n            };\n\n            // Calculate danger level\n            if (cloudData.hexColor.includes(\"ff0000\")) cloudData.dangerLevel = 10; // Harming\n            else if (cloudData.hexColor.includes(\"00ff00\")) cloudData.dangerLevel = 8;  // Poison\n            else if (cloudData.hexColor.includes(\"0000ff\")) cloudData.dangerLevel = 5; // Slowness\n            else if (cloudData.hexColor.includes(\"ffffff\")) cloudData.dangerLevel = -3; // Healing\n\n            clouds.push(cloudData);\n        }\n    });\n\n    // Sort by danger level and distance\n    clouds.sort((a, b) => {\n        if (b.dangerLevel !== a.dangerLevel) {\n            return b.dangerLevel - a.dangerLevel;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display results\n    Chat.log(\"=== Area Effect Cloud Scan ===\");\n    Chat.log(`Found ${clouds.length} area effect clouds`);\n\n    clouds.forEach((cloud, index) => {\n        const status = cloud.isWaiting ? \"Waiting\" : \"Active\";\n        const danger = cloud.dangerLevel > 0 ? `&cDanger: ${cloud.dangerLevel}` :\n                     cloud.dangerLevel < 0 ? `&aBeneficial: ${Math.abs(cloud.dangerLevel)}` :\n                     \"&fNeutral\";\n\n        Chat.log(`${index + 1}. ${cloud.hexColor} cloud (${status})`);\n        Chat.log(`   Position: [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]`);\n        Chat.log(`   Distance: ${cloud.distance.toFixed(1)}m, Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`   Particles: ${cloud.particleType}`);\n        Chat.log(`   ${danger}`);\n        Chat.log(`   In range: ${cloud.isInRange ? \"&aYes\" : \"&fNo\"}`);\n\n        // Set appropriate glow effect\n        if (cloud.dangerLevel > 5) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF0000); // Red for very dangerous\n        } else if (cloud.dangerLevel > 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0xFF8800); // Orange for moderately dangerous\n        } else if (cloud.dangerLevel < 0) {\n            cloud.entity.setGlowing(true);\n            cloud.entity.setGlowingColor(0x00FF00); // Green for beneficial\n        }\n    });\n\n    return clouds;\n}\n\n// Run scan every few seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 60 === 0) { // Every 3 seconds\n        scanAllClouds();\n    }\n}));",
        "// Predict which entities will be affected by area effect clouds\nfunction predictCloudEffects() {\n    const entities = World.getEntities();\n    const clouds = [];\n    const affectedEntities = [];\n\n    // Find all area effect clouds\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:area_effect_cloud\")) {\n            const cloud = entity;\n            clouds.push({\n                entity: cloud,\n                position: entity.getPos(),\n                radius: cloud.getRadius(),\n                color: cloud.getColor(),\n                isWaiting: cloud.isWaiting(),\n                hexColor: `#${cloud.getColor().toString(16).padStart(6, '0')}`\n            });\n        }\n    });\n\n    // Find entities that might be affected\n    entities.forEach(entity => {\n        if (!entity.is(\"minecraft:area_effect_cloud\") && entity.isAlive()) {\n            const entityPos = entity.getPos();\n            const entityType = entity.getType();\n            const entityName = entity.getName().getString();\n\n            clouds.forEach(cloud => {\n                const distance = Math.sqrt(\n                    Math.pow(entityPos.x - cloud.position.x, 2) +\n                    Math.pow(entityPos.y - cloud.position.y, 2) +\n                    Math.pow(entityPos.z - cloud.position.z, 2)\n                );\n\n                if (distance <= cloud.radius && !cloud.isWaiting) {\n                    affectedEntities.push({\n                        entity: entity,\n                        cloud: cloud,\n                        distance: distance,\n                        entityType: entityType,\n                        entityName: entityName\n                    });\n                }\n            });\n        }\n    });\n\n    // Display predictions\n    Chat.log(\"=== Cloud Effect Predictions ===\");\n    Chat.log(`Analyzing ${clouds.length} clouds and their effects...`);\n\n    clouds.forEach(cloud => {\n        const affected = affectedEntities.filter(ae => ae.cloud === cloud);\n        const effect = getEffectDescription(cloud.hexColor);\n\n        Chat.log(`\\nCloud at [${cloud.position.x.toFixed(1)}, ${cloud.position.y.toFixed(1)}, ${cloud.position.z.toFixed(1)}]:`);\n        Chat.log(`  Effect: ${effect} (${cloud.hexColor})`);\n        Chat.log(`  Radius: ${cloud.radius.toFixed(1)}m`);\n        Chat.log(`  Status: ${cloud.isWaiting ? \"Waiting\" : \"Active\"}`);\n        Chat.log(`  Entities affected: ${affected.length}`);\n\n        affected.forEach(ae => {\n            Chat.log(`    - ${ae.entityName} (${ae.entityType}) at ${ae.distance.toFixed(1)}m from center`);\n\n            // Highlight affected entities\n            if (ae.entityType === \"minecraft:player\") {\n                ae.entity.setGlowing(true);\n                ae.entity.setGlowingColor(cloud.color | 0xFF000000);\n            }\n        });\n    });\n\n    return affectedEntities;\n}\n\nfunction getEffectDescription(hexColor) {\n    if (hexColor.includes(\"ff0000\")) return \"Harming/Strength\";\n    if (hexColor.includes(\"00ff00\")) return \"Poison\";\n    if (hexColor.includes(\"0000ff\")) return \"Slowness\";\n    if (hexColor.includes(\"ffffff\")) return \"Healing/Regeneration\";\n    if (hexColor.includes(\"ff8800\") || hexColor.includes(\"ffa500\")) return \"Weakness/Fire Resistance\";\n    return \"Unknown Effect\";\n}\n\n// Periodic effect prediction\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 40 === 0) { // Every 2 seconds\n        predictCloudEffects();\n    }\n}));"
      ]
    },
    {
      "name": "resetGlowing",
      "signature": "void resetGlowing()",
      "returnType": "void",
      "description": "Resets the glowing effect to default.",
      "parameters": [],
      "static": false,
      "examples": []
    }
  ]
}