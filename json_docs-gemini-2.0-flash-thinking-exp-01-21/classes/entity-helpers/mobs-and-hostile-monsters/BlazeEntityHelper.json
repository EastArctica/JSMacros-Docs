{
  "name": "BlazeEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.BlazeEntityHelper<T extends BlazeEntity>",
  "extends": "MobEntityHelper<T>",
  "since": "JsMacros 1.8.4",
  "description": "Represents a blaze entity in the world. BlazeEntityHelper provides access to blaze-specific properties and behaviors, particularly their fire state which affects their combat abilities. Blazes are hostile mobs from the Nether that shoot fireballs at players and are immune to fire damage.",
  "overview": "Blaze entities are floating fire-based mobs that can only attack with fireballs when they are actively on fire. They cycle between an \"on fire\" state and a \"cool\" state, making their attack patterns predictable. This helper provides access to their current fire state, which is crucial for understanding their combat behavior and timing attacks or defenses.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, AI control, movement, and other mob properties, while adding blaze-specific functionality for fire state monitoring.",
  "constructors": [
    {
      "signature": "",
      "description": "BlazeEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through:\n\n- Entity-related events (e.g., `EntityDeath`, `EntityInteract`, `EntitySpawn`, `ProjectileHit`)\n- World entity queries and type casting\n- Methods that return blaze entities\n- Type casting from EntityHelper using `as(\"minecraft:blaze\")` or appropriate casting methods",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isOnFire",
      "signature": "isOnFire()",
      "returnType": "boolean",
      "description": "Checks if the blaze entity is currently 'on fire'. For blazes, this state specifically indicates their active combat mode where they can shoot fireballs. This method does not signify vulnerability to fire damage (as blazes are immune) but rather their attack capability and readiness.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Real-time blaze monitoring system for Nether combat\nclass BlazeCombatMonitor {\n    constructor() {\n        this.activeBlazes = new Map();\n        this.alertCooldowns = new Map();\n        this.combatLog = [];\n        this.lastCleanup = 0;\n    }\n\n    updateBlaze(blazeEntity) {\n        const blaze = blazeEntity.as(\"minecraft:blaze\");\n        if (!blaze) return;\n\n        const uuid = blazeEntity.getUUID();\n        const player = Player.getPlayer();\n        const isOnFire = blaze.isOnFire();\n        const distance = player.distanceTo(blazeEntity);\n        const health = blazeEntity.asLiving().getHealth();\n        const maxHealth = blazeEntity.asLiving().getMaxHealth();\n        const pos = blazeEntity.getPos();\n\n        if (!this.activeBlazes.has(uuid)) {\n            // New blaze detected\n            this.activeBlazes.set(uuid, {\n                entity: blazeEntity,\n                name: blazeEntity.getName().getString(),\n                firstSeen: Client.getTime(),\n                lastFireState: isOnFire,\n                stateChanges: 0,\n                fireballCount: 0,\n                healthHistory: [{ health, time: Client.getTime() }],\n                combatEngagement: null,\n                threatLevel: this.calculateThreatLevel(blazeEntity, distance)\n            });\n\n            Chat.log(`&eüî• Blaze detected: ${blazeEntity.getName().getString()}`);\n            Chat.log(`  Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Initial state: ${isOnFire ? \"On Fire\" : \"Cooling\"}`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n\n            // Alert player if blaze is nearby and active\n            if (distance <= 16 && isOnFire) {\n                this.sendAlert(\"ACTIVE BLAZE NEARBY!\", \"warning\");\n            }\n        } else {\n            // Update existing blaze tracking\n            const blazeData = this.activeBlazes.get(uuid);\n\n            // Track fire state changes\n            if (blazeData.lastFireState !== isOnFire) {\n                blazeData.stateChanges++;\n                blazeData.lastFireState = isOnFire;\n\n                const stateText = isOnFire ? \"IGNITED\" : \"COOLING\";\n                Chat.log(`&6üîÑ ${blazeData.name} state changed to: ${stateText}`);\n\n                // Alert for state changes\n                if (distance <= 12) {\n                    const alertMessage = isOnFire ? \"Blaze IGNITED - Take cover!\" : \"Blaze COOLING - Attack now!\";\n                    const alertType = isOnFire ? \"danger\" : \"success\";\n                    this.sendAlert(alertMessage, alertType);\n                }\n\n                // Track potential fireball attacks\n                if (isOnFire) {\n                    blazeData.fireballCount++;\n                }\n            }\n\n            // Update health tracking\n            blazeData.healthHistory.push({ health, time: Client.getTime() });\n\n            // Keep only recent health history (last 30 seconds)\n            const cutoffTime = Client.getTime() - 600;\n            blazeData.healthHistory = blazeData.healthHistory.filter(h => h.time > cutoffTime);\n\n            // Update threat level\n            blazeData.threatLevel = this.calculateThreatLevel(blazeEntity, distance);\n\n            // Monitor for combat engagement\n            if (distance <= 20) {\n                if (!blazeData.combatEngagement) {\n                    blazeData.combatEngagement = Client.getTime();\n                    Chat.log(`&c‚öîÔ∏è Combat engagement with ${blazeData.name} at ${distance.toFixed(1)} blocks`);\n                }\n            }\n            else {\n                if (blazeData.combatEngagement && Client.getTime() - blazeData.combatEngagement > 100) {\n                    const combatDuration = (Client.getTime() - blazeData.combatEngagement) / 20;\n                    Chat.log(`&a‚úì Combat with ${blazeData.name} ended after ${combatDuration.toFixed(1)} seconds`);\n                    blazeData.combatEngagement = null;\n                }\n            }\n\n            // Periodic updates for nearby active blazes\n            if (distance <= 8 && isOnFire && Client.getTime() % 20 === 0) {\n                this.updateCombatStatus(blazeData, distance, health, maxHealth);\n            }\n        }\n    }\n\n    calculateThreatLevel(blazeEntity, distance) {\n        const health = blazeEntity.asLiving().getHealth();\n        const maxHealth = blazeEntity.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n        const blaze = blazeEntity.as(\"minecraft:blaze\");\n        const isActive = blaze && blaze.isOnFire();\n\n        let threat = 0;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 4) threat += 40;\n        else if (distance <= 8) threat += 25;\n        else if (distance <= 16) threat += 15;\n        else threat += 5;\n\n        // Health threat\n        threat += healthPercent * 0.3;\n\n        // Active state threat\n        if (isActive) threat += 25;\n\n        // Multi-blaze threat calculation (check nearby blazes)\n        const nearbyBlazes = this.countNearbyBlazes(blazeEntity.getPos(), 16);\n        if (nearbyBlazes > 1) threat += nearbyBlazes * 10;\n\n        return Math.min(threat, 100);\n    }\n\n    countNearbyBlazes(position, range) {\n        const player = Player.getPlayer();\n        const entities = World.getEntities();\n        let count = 0;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:blaze\")) {\n                const distance = position.distanceTo(entity.getPos());\n                if (distance <= range) {\n                    count++;\n                }\n            }\n        });\n\n        return count;\n    }\n\n    updateCombatStatus(blazeData, distance, health, maxHealth) {\n        const blaze = blazeData.entity.as(\"minecraft:blaze\");\n        const isActive = blaze.isOnFire();\n        const healthPercent = (health / maxHealth) * 100;\n\n        let statusMessage = `${blazeData.name}: `;\n\n        // State indicator\n        statusMessage += isActive ? \"üî• \" : \"‚ùÑÔ∏è \";\n\n        // Health indicator\n        if (healthPercent > 75) statusMessage += \"üü¢\";\n        else if (healthPercent > 40) statusMessage += \"üü°\";\n        else statusMessage += \"üî¥\";\n\n        // Distance indicator\n        statusMessage += ` ${distance.toFixed(0)}m`;\n\n        // Threat level\n        statusMessage += ` [${blazeData.threatLevel.toFixed(0)}%]`;\n\n        Chat.actionbar(statusMessage);\n    }\n\n    sendAlert(message, type = \"info\") {\n        const currentTime = Client.getTime();\n        const alertKey = `${message}_${type}`;\n\n        // Cooldown to prevent spam\n        if (!this.alertCooldowns.has(alertKey) ||\n            currentTime - this.alertCooldowns.get(alertKey) > 60) {\n\n            const prefix = {\n                \"warning\": \"&c‚ö†Ô∏è \",\n                \"danger\": \"&4üî• \",\n                \"success\": \"&a‚úì \",\n                \"info\": \"&b‚ÑπÔ∏è \"\n            }[type] || \"&b‚ÑπÔ∏è \";\n\n            Chat.actionbar(`${prefix}${message}`);\n            this.alertCooldowns.set(alertKey, currentTime);\n        }\n    }\n\n    generateReport() {\n        if (this.activeBlazes.size === 0) {\n            Chat.log(\"No blazes currently tracked\");\n            return;\n        }\n\n        Chat.log(`&6=== Blaze Combat Report (${this.activeBlazes.size} blazes) ===`);\n\n        let totalThreat = 0;\n        let activeBlazes = 0;\n        let coolingBlazes = 0;\n        let inCombat = 0;\n\n        for (const [uuid, blazeData] of this.activeBlazes) {\n            const blaze = blazeData.entity.as(\"minecraft:blaze\");\n            const isActive = blaze.isOnFire();\n            const distance = Player.getPlayer().distanceTo(blazeData.entity);\n            const trackingDuration = (Client.getTime() - blazeData.firstSeen) / 20;\n\n            if (isActive) activeBlazes++;\n            else coolingBlazes++;\n\n            if (blazeData.combatEngagement) inCombat++;\n\n            totalThreat += blazeData.threatLevel;\n\n            Chat.log(`\\n${blazeData.name}:`);\n            Chat.log(`  State: ${isActive ? \"üî• On Fire\" : \"‚ùÑÔ∏è Cooling\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Health: ${blazeData.entity.asLiving().getHealth().toFixed(1)}/${blazeData.entity.asLiving().getMaxHealth().toFixed(1)}`);\n            Chat.log(`  Threat Level: ${blazeData.threatLevel.toFixed(0)}%`);\n            Chat.log(`  State Changes: ${blazeData.stateChanges}`);\n            Chat.log(`  Fireball Phases: ${blazeData.fireballCount}`);\n            Chat.log(`  Tracked for: ${trackingDuration.toFixed(1)}s`);\n\n            if (blazeData.combatEngagement) {\n                const combatDuration = (Client.getTime() - blazeData.combatEngagement) / 20;\n                Chat.log(`  In Combat: ${combatDuration.toFixed(1)}s`);\n            }\n        }\n\n        // Summary\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Blazes: ${activeBlazes}`);\n        Chat.log(`Cooling Blazes: ${coolingBlazes}`);\n        Chat.log(`In Combat: ${inCombat}`);\n        Chat.log(`Average Threat Level: ${(totalThreat / this.activeBlazes.size).toFixed(0)}%`);\n\n        // Warnings\n        if (activeBlazes >= 3) {\n            Chat.log(`\\n&cüî• CRITICAL: ${activeBlazes} blazes currently active!`);\n        }\n        else if (activeBlazes >= 2) {\n            Chat.log(`\\n&e‚ö†Ô∏è WARNING: ${activeBlazes} blazes currently active!`);\n        }\n\n        if (inCombat >= 2) {\n            Chat.log(`\\n&c‚öîÔ∏è MULTIPLE COMBAT engagements in progress!`);\n        }\n    }\n\n    cleanup() {\n        const currentTime = Client.getTime();\n\n        // Only cleanup every 5 seconds to avoid performance issues\n        if (currentTime - this.lastCleanup < 100) return;\n\n        this.lastCleanup = currentTime;\n\n        for (const [uuid, blazeData] of this.activeBlazes) {\n            if (!blazeData.entity.isAlive()) {\n                const trackingDuration = (currentTime - blazeData.firstSeen) / 20;\n                Chat.log(`&7${blazeData.name} eliminated after ${trackingDuration.toFixed(1)}s`);\n                this.activeBlazes.delete(uuid);\n            }\n            else {\n                const distance = Player.getPlayer().distanceTo(blazeData.entity);\n\n                // Remove blazes that are too far away (64+ blocks)\n                if (distance > 64) {\n                    Chat.log(`&7${blazeData.name} moved out of tracking range`);\n                    this.activeBlazes.delete(uuid);\n                }\n            }\n        }\n    }\n}\n\nconst blazeMonitor = new BlazeCombatMonitor();\n\n// Monitor blazes every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 32; // Track blazes within 32 blocks\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= trackingRange && entity.is(\"minecraft:blaze\")) {\n            blazeMonitor.updateBlaze(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        blazeMonitor.cleanup();\n    }\n}));\n\n// Report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.b\" && e.action === 1) { // B key\n        blazeMonitor.generateReport();\n    }\n}));",
        "// Analyze and predict blaze attack patterns\nclass BlazeAttackPatternAnalyzer {\n    constructor() {\n        this.blazePatterns = new Map();\n        this.attackWindows = [];\n        this.defensiveRecommendations = [];\n    }\n\n    analyzeBlaze(blazeEntity) {\n        const blaze = blazeEntity.as(\"minecraft:blaze\");\n        if (!blaze) return;\n\n        const uuid = blazeEntity.getUUID();\n        const isOnFire = blaze.isOnFire();\n        const currentTime = Client.getTime();\n\n        if (!this.blazePatterns.has(uuid)) {\n            this.blazePatterns.set(uuid, {\n                entity: blazeEntity,\n                name: blazeEntity.getName().getString(),\n                states: [],\n                lastStateChange: currentTime,\n                averageCycleTime: 0,\n                totalTimeOnFire: 0,\n                totalTimeCooling: 0,\n                attacksPredicted: 0,\n                safeWindows: []\n            });\n        }\n\n        const pattern = this.blazePatterns.get(uuid);\n\n        if (pattern.states.length === 0 || pattern.states[pattern.states.length - 1].state !== isOnFire) {\n            // State changed\n            if (pattern.states.length > 0) {\n                const lastState = pattern.states[pattern.states.length - 1];\n                const duration = currentTime - lastState.timestamp;\n\n                if (lastState.state) {\n                    pattern.totalTimeOnFire += duration;\n                }\n                else {\n                    pattern.totalTimeCooling += duration;\n                }\n\n                // Update average cycle time\n                if (pattern.states.length >= 2) {\n                    pattern.averageCycleTime = (pattern.totalTimeOnFire + pattern.totalTimeCooling) / (pattern.states.length / 2);\n                }\n            }\n\n            pattern.states.push({\n                state: isOnFire,\n                timestamp: currentTime\n            });\n\n            // Log significant state changes\n            if (Player.getPlayer().distanceTo(blazeEntity) <= 16) {\n                const stateText = isOnFire ? \"IGNITED (Attack Mode)\" : \"COOLING (Safe Window)\";\n                Chat.log(`&6${pattern.name}: ${stateText}`);\n\n                if (isOnFire) {\n                    pattern.attacksPredicted++;\n                    this.predictAttackTiming(pattern, blazeEntity);\n                }\n                else {\n                    this.identifySafeWindow(pattern, blazeEntity);\n                }\n            }\n        }\n\n        // Clean old state data (keep last 2 minutes)\n        const cutoffTime = currentTime - 2400;\n        pattern.states = pattern.states.filter(state => state.timestamp > cutoffTime);\n    }\n\n    predictAttackTiming(pattern, blazeEntity) {\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(blazeEntity);\n\n        if (pattern.averageCycleTime > 0) {\n            const nextSafeWindow = pattern.averageCycleTime * 0.6; // Rough estimate\n            const message = `&e‚öîÔ∏è Expect attacks for next ~${nextSafeWindow.toFixed(1)}s`;\n\n            if (distance < 12) {\n                Chat.actionbar(message);\n            }\n        }\n\n        // Predictive recommendations\n        if (distance < 8) {\n            Chat.log(\"&cüî• IMMEDIATE ACTION: Move away or take cover!\");\n            Chat.log(\"‚Üí Fireballs incoming - dodge horizontally\");\n            Chat.log(\"‚Üí Use pillars or walls as shields\");\n        }\n        else if (distance < 16) {\n            Chat.log(\"&e‚öîÔ∏è COMBAT READY: Prepare for fireball attacks\");\n            Chat.log(\"‚Üí Keep moving to avoid projectiles\");\n            Chat.log(\"‚Üí Return fire with ranged weapons\");\n        }\n    }\n\n    identifySafeWindow(pattern, blazeEntity) {\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(blazeEntity);\n\n        if (pattern.averageCycleTime > 0) {\n            const safeWindowDuration = pattern.averageCycleTime * 0.4;\n            const message = `&aüõ°Ô∏è Safe attack window: ~${safeWindowDuration.toFixed(1)}s`;\n\n            if (distance < 20) {\n                Chat.actionbar(message);\n            }\n        }\n\n        // Safe window recommendations\n        if (distance < 12) {\n            Chat.log(\"&a‚úÖ ATTACK WINDOW: Blaze is cooling down!\");\n            Chat.log(\"‚Üí Close in for melee attacks\");\n            Chat.log(\"‚Üí Blaze cannot attack while cooling\");\n        }\n        else if (distance < 20) {\n            Chat.log(\"&eüéØ APPROACH OPPORTUNITY: Safe to advance\");\n            Chat.log(\"‚Üí Reduce distance for future attacks\");\n            Chat.log(\"‚Üí Prepare weapons for next active phase\");\n        }\n\n        // Track safe windows for analysis\n        pattern.safeWindows.push({\n            startTime: Client.getTime(),\n            distance: distance\n        });\n    }\n\n    generatePatternReport() {\n        if (this.blazePatterns.size === 0) {\n            Chat.log(\"No blaze pattern data available\");\n            return;\n        }\n\n        Chat.log(`&6=== Blaze Attack Pattern Analysis ===`);\n\n        for (const [uuid, pattern] of this.blazePatterns) {\n            const totalCycles = pattern.states.length / 2;\n            const currentDistance = Player.getPlayer().distanceTo(pattern.entity);\n            const blaze = pattern.entity.as(\"minecraft:blaze\");\n            const currentState = blaze.isOnFire();\n\n            Chat.log(`\\n${pattern.name}:`);\n            Chat.log(`  Current State: ${currentState ? \"üî• Active\" : \"‚ùÑÔ∏è Cooling\"}`);\n            Chat.log(`  Distance: ${currentDistance.toFixed(1)} blocks`);\n            Chat.log(`  Observed Cycles: ${totalCycles}`);\n\n            if (pattern.averageCycleTime > 0) {\n                Chat.log(`  Average Cycle Time: ${(pattern.averageCycleTime / 20).toFixed(1)}s`);\n                Chat.log(`  Active Duration: ${(pattern.totalTimeOnFire / 20 / totalCycles).toFixed(1)}s`);\n                Chat.log(`  Cooling Duration: ${(pattern.totalTimeCooling / 20 / totalCycles).toFixed(1)}s`);\n\n                const activePercentage = (pattern.totalTimeOnFire / (pattern.totalTimeOnFire + pattern.totalTimeCooling)) * 100;\n                Chat.log(`  Active Time Percentage: ${activePercentage.toFixed(1)}%`);\n            }\n\n            Chat.log(`  Attacks Predicted: ${pattern.attacksPredicted}`);\n            Chat.log(`  Safe Windows Identified: ${pattern.safeWindows.length}`);\n\n            // Provide tactical recommendations based on patterns\n            this.generateTacticalRecommendations(pattern);\n        }\n    }\n\n    generateTacticalRecommendations(pattern) {\n        const blaze = pattern.entity.as(\"minecraft:blaze\");\n        const currentState = blaze.isOnFire();\n        const distance = Player.getPlayer().distanceTo(pattern.entity);\n\n        Chat.log(\"\\n  Tactical Recommendations:\");\n\n        if (pattern.averageCycleTime > 0) {\n            const activePercent = (pattern.totalTimeOnFire / (pattern.totalTimeOnFire + pattern.totalTimeCooling)) * 100;\n\n            if (activePercent > 60) {\n                Chat.log(\"    &eThis blaze is highly aggressive - maintain distance\");\n                Chat.log(\"    ‚Üí Focus on ranged combat and evasive maneuvers\");\n            }\n            else if (activePercent < 40) {\n                Chat.log(\"    &aThis blaze is relatively passive - good for melee\");\n                Chat.log(\"    ‚Üí Aggressive close-range combat recommended\");\n            }\n            else {\n                Chat.log(\"    &6Balanced attack pattern - adaptable strategy\");\n                Chat.log(\"    ‚Üí Mix of ranged and melee combat effective\");\n            }\n        }\n\n        if (currentState) {\n            if (distance < 10) {\n                Chat.log(\"    &cDANGER: Too close to active blaze!\");\n                Chat.log(\"    ‚Üí Immediate retreat required\");\n            }\n            else {\n                Chat.log(\"    &eOPTIMAL RANGE: Good position for ranged combat\");\n                Chat.log(\"    ‚Üí Maintain current distance and attack\");\n            }\n        }\n        else {\n            if (distance > 15) {\n                Chat.log(\"    &6OPPORTUNITY: Close distance while blaze is cooling\");\n                Chat.log(\"    ‚Üí Advance to melee range for maximum damage\");\n            }\n            else {\n                Chat.log(\"    &aPERFECT POSITION: Attack now with melee weapons\");\n                Chat.log(\"    ‚Üí Blaze is defenseless while cooling\");\n            }\n        }\n\n        // Environmental considerations\n        const pos = pattern.entity.getPos();\n        if (pos.y < 50) {\n            Chat.log(\"    ‚ÑπÔ∏è Underground location - limited escape options\");\n            Chat.log(\"    ‚Üí Plan retreat routes carefully\");\n        }\n    }\n}\n\nconst patternAnalyzer = new BlazeAttackPatternAnalyzer();\n\n// Analyze blaze patterns every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 24;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:blaze\")) {\n            patternAnalyzer.analyzeBlaze(entity);\n        }\n    });\n}));\n\n// Pattern analysis command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.p\" && e.action === 1) { // P key\n        patternAnalyzer.generatePatternReport();\n    }\n}));",
        "// Simple but effective blaze fire state monitoring\nclass BlazeFireStateMonitor {\n    constructor() {\n        this.lastAlerts = new Map();\n        this.alertCooldown = 40; // 2 seconds between alerts for same blaze\n    }\n\n    monitorBlazes() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities();\n        const alertRange = 20;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:blaze\")) {\n                const blaze = entity.as(\"minecraft:blaze\");\n                const uuid = entity.getUUID();\n                const distance = player.distanceTo(entity);\n                const isOnFire = blaze.isOnFire();\n\n                if (distance <= alertRange) {\n                    this.sendBlazeAlert(uuid, entity, isOnFire, distance);\n                }\n            }\n        });\n    }\n\n    sendBlazeAlert(uuid, blazeEntity, isOnFire, distance) {\n        const currentTime = Client.getTime();\n        const lastAlert = this.lastAlerts.get(uuid) || 0;\n\n        if (currentTime - lastAlert < this.alertCooldown) {\n            return; // Skip to prevent alert spam\n        }\n\n        const name = blazeEntity.getName().getString();\n        let alertMessage = \"\";\n        let alertType = \"\";\n\n        if (isOnFire) {\n            if (distance < 6) {\n                alertMessage = `üî• CRITICAL: ${name} attacking at point blank!`;\n                alertType = \"critical\";\n            }\n            else if (distance < 12) {\n                alertMessage = `‚öîÔ∏è COMBAT: ${name} attacking at ${distance.toFixed(0)}m!`;\n                alertType = \"combat\";\n            }\n            else {\n                alertMessage = `üî• ALERT: ${name} active at ${distance.toFixed(0)}m`;\n                alertType = \"warning\";\n            }\n        }\n        else {\n            if (distance < 8) {\n                alertMessage = `‚úÖ SAFE: ${name} cooling down nearby`;\n                alertType = \"safe\";\n            }\n            else {\n                alertMessage = `üõ°Ô∏è WINDOW: ${name} vulnerable at ${distance.toFixed(0)}m`;\n                alertType = \"opportunity\";\n            }\n        }\n\n        const formattedMessage = {\n            \"critical\": \"&c\",\n            \"combat\": \"&e\",\n            \"warning\": \"&6\",\n            \"safe\": \"&a\",\n            \"opportunity\": \"&b\"\n        }[alertType] || \"&f\";\n\n        Chat.actionbar(`${formattedMessage}${alertMessage}`);\n        this.lastAlerts.set(uuid, currentTime);\n    }\n}\n\nconst fireStateMonitor = new BlazeFireStateMonitor();\n\n// Monitor blazes every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    fireStateMonitor.monitorBlazes();\n}));"
      ]
    }
  ]
}