{
  "name": "GuardianEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.GuardianEntityHelper",
  "extends": "MobEntityHelper<GuardianEntity>",
  "since": "JsMacros 1.8.4",
  "description": "Represents a guardian entity in the world. GuardianEntityHelper provides access to guardian-specific properties and behaviors, particularly their beam targeting abilities and spike states. Guardians are aquatic hostile mobs found in ocean monuments that use laser beam attacks and have defensive spikes.",
  "overview": "Guardians are formidable underwater guardians that protect ocean monuments and their precious treasures. They possess a unique laser beam attack that charges up before dealing damage, and defensive spikes that extend when threatened. This helper provides access to their targeting system, allowing you to monitor who they're attacking, and their defensive state through spike positioning.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, AI control, movement, and other mob properties, while adding guardian-specific functionality for beam targeting and defensive behavior monitoring.",
  "constructors": [
    {
      "signature": "GuardianEntityHelper()",
      "description": "GuardianEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through entity-related events (e.g., `EntityDeath`, `EntityInteract`, `EntitySpawn`, `ProjectileHit`), world entity queries and type casting, methods that return guardian entities, or type casting from EntityHelper using `as(\"minecraft:guardian\")` or appropriate casting methods.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isElder",
      "signature": "isElder()",
      "returnType": "boolean",
      "description": "Checks if this guardian is an Elder Guardian. Elder guardians have distinct behaviors, higher health, and apply Mining Fatigue.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive guardian detection and analysis system\nclass GuardianAnalyzer {\n    constructor() {\n        this.guardians = new Map();\n        this.oceanMonumentProximity = 0;\n        this.elderGuardianCount = 0;\n        this.analysisStartTime = Client.getTime();\n    }\n\n    analyzeGuardian(guardianEntity) {\n        const guardian = guardianEntity.as(\"minecraft:guardian\");\n        if (!guardian) return;\n\n        const uuid = guardianEntity.getUUID();\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted(); // Note behavior\n        const health = guardianEntity.asLiving().getHealth();\n        const maxHealth = guardianEntity.asLiving().getMaxHealth();\n        const pos = guardianEntity.getPos();\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(guardianEntity);\n\n        // Store guardian data\n        if (!this.guardians.has(uuid)) {\n            this.guardians.set(uuid, {\n                entity: guardianEntity,\n                name: guardianEntity.getName().getString(),\n                isElder: isElder,\n                firstSeen: Client.getTime(),\n                targetingHistory: [],\n                combatSessions: [],\n                maxAggressionLevel: 0\n            });\n\n            if (isElder) {\n                this.elderGuardianCount++;\n                Chat.log(`&cüëë ELDER GUARDIAN DETECTED!`);\n            }\n\n            Chat.log(`&eüõ°Ô∏è Guardian detected: ${guardianEntity.getName().getString()}`);\n        }\n\n        const data = this.guardians.get(uuid);\n\n        // Update targeting history\n        data.targetingHistory.push({\n            hasTarget: hasTarget,\n            targetName: target ? target.getName().getString() : null,\n            targetType: target ? target.getType() : null,\n            distance: target ? guardianEntity.getPos().distanceTo(target.getPos()) : null,\n            time: Client.getTime()\n        });\n\n        // Clean old history (keep last 2 minutes)\n        const cutoffTime = Client.getTime() - 2400;\n        data.targetingHistory = data.targetingHistory.filter(entry => entry.time > cutoffTime);\n\n        // Calculate current aggression level\n        const aggressionLevel = this.calculateAggressionLevel(hasTarget, spikesExtended, isElder);\n        data.maxAggressionLevel = Math.max(data.maxAggressionLevel, aggressionLevel);\n\n        // Provide real-time analysis\n        this.provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos);\n\n        // Check for ocean monument proximity\n        this.checkOceanMonumentProximity(pos);\n    }\n\n    calculateAggressionLevel(hasTarget, spikesExtended, isElder) {\n        let level = 0;\n\n        if (hasTarget && spikesExtended) level = 90; // Full combat\n        else if (hasTarget) level = 60; // Targeting\n        else if (spikesExtended) level = 30; // Alert\n        else level = 0; // Passive\n\n        if (isElder) level += 15; // Elder bonus\n\n        return level;\n    }\n\n    provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos) {\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted();\n\n        Chat.log(`&6=== Guardian Analysis ===`);\n        Chat.log(`Type: ${isElder ? \"üëë Elder Guardian\" : \"üõ°Ô∏è Guardian\"}`);\n        Chat.log(`Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)} (${((health/maxHealth)*100).toFixed(0)}%)`);\n        Chat.log(`Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n        // State analysis\n        const state = this.classifyGuardianState(hasTarget, spikesExtended);\n        Chat.log(`State: ${state.emoji} ${state.name}`);\n        Chat.log(`Description: ${state.description}`);\n\n        // Target analysis\n        if (hasTarget && target) {\n            const targetName = target.getName().getString();\n            const targetType = target.getType();\n            const targetDistance = guardian.getEntity().getPos().distanceTo(target.getPos());\n\n            Chat.log(`\\nüéØ Target Analysis:`);\n            Chat.log(`  Target: ${targetName} (${targetType})`);\n            Chat.log(`  Distance to Target: ${targetDistance.toFixed(1)} blocks`);\n\n            if (targetType === \"minecraft:player\") {\n                const targetPlayer = target.asPlayer();\n                const targetHealth = targetPlayer.getHealth();\n                Chat.log(`  &cüíÄ TARGET IS PLAYER!`);\n                Chat.log(`  Player Health: ${targetHealth.toFixed(1)}/${targetPlayer.getMaxHealth().toFixed(1)}`);\n                this.sendPlayerTargetAlert(targetName, targetDistance, isElder);\n            }\n        }\n\n        // Threat assessment\n        const threat = this.assessThreat(data, distance, health, maxHealth, isElder, state);\n        Chat.log(`\\n‚ö†Ô∏è Threat Level: ${threat.level} (${threat.score}/100)`);\n        Chat.log(`Recommendation: ${threat.recommendation}`);\n\n        // Combat recommendations\n        if (state.name === \"COMBAT_ENGAGED\" || state.name === \"TARGETING\") {\n            this.provideCombatRecommendations(data, distance, isElder, target);\n        }\n    }\n\n    classifyGuardianState(hasTarget, spikesExtended) {\n        if (hasTarget && spikesExtended) {\n            return {\n                name: \"COMBAT_ENGAGED\",\n                emoji: \"‚öîÔ∏è\",\n                description: \"Guardian is actively attacking with extended spikes\"\n            };\n        } else if (hasTarget) {\n            return {\n                name: \"TARGETING\",\n                emoji: \"üéØ\",\n                description: \"Guardian is charging laser beam attack\"\n            };\n        } else if (spikesExtended) {\n            return {\n                name: \"DEFENSIVE\",\n                emoji: \"üõ°Ô∏è\",\n                description: \"Guardian is alert with extended spikes\"\n            };\n        } else {\n            return {\n                name: \"PASSIVE\",\n                emoji: \"üòå\",\n                description: \"Guardian is calm and relaxed\"\n            };\n        }\n    }\n\n    assessThreat(data, distance, health, maxHealth, isElder, state) {\n        let score = 0;\n\n        // Base threat by type\n        if (isElder) score += 40;\n        else score += 20;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 8) score += 30;\n        else if (distance <= 16) score += 20;\n        else if (distance <= 24) score += 10;\n\n        // Health threat (higher health means more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        score += healthPercent * 0.2;\n\n        // State threat\n        const stateScores = {\n            \"COMBAT_ENGAGED\": 25,\n            \"TARGETING\": 15,\n            \"DEFENSIVE\": 8,\n            \"PASSIVE\": 0\n        };\n        score += stateScores[state.name] || 0;\n\n        // Multiple guardian threat\n        if (this.guardians.size > 1) {\n            score += (this.guardians.size - 1) * 5;\n        }\n\n        let level, recommendation;\n\n        if (score >= 80) {\n            level = \"CRITICAL\";\n            recommendation = \"Immediate retreat or full combat preparation required\";\n        } else if (score >= 60) {\n            level = \"HIGH\";\n            recommendation = \"Prepare for combat, maintain tactical distance\";\n        } else if (score >= 40) {\n            level = \"MEDIUM\";\n            recommendation = \"Monitor situation, be ready to engage or retreat\";\n        } else {\n            level = \"LOW\";\n            recommendation = \"Safe to approach if needed, remain cautious\";\n        }\n\n        return { level, score: Math.min(score, 100), recommendation };\n    }\n\n    provideCombatRecommendations(data, distance, isElder, target) {\n        Chat.log(`\\n‚öîÔ∏è Combat Recommendations:`);\n\n        if (distance <= 12) {\n            Chat.log(`  &cüî• CLOSE COMBAT ZONE:`);\n            Chat.log(`  ‚Üí Break line of sight immediately`);\n            Chat.log(`  ‚Üí Use pillars or walls as cover`);\n            Chat.log(`  ‚Üí Consider retreat to safer distance`);\n        } else if (distance <= 24) {\n            Chat.log(`  &eüèπ OPTIMAL COMBAT RANGE:`);\n            Chat.log(`  ‚Üí Use ranged weapons (bow, crossbow)`);\n            Chat.log(`  ‚Üí Keep moving to avoid laser beams`);\n            Chat.log(`  ‚Üí Attack during guardian cooldown periods`);\n        } else {\n            Chat.log(`  &aüéØ LONG RANGE ADVANTAGE:`);\n            Chat.log(`  ‚Üí Guardian attack effectiveness reduced`);\n            Chat.log(`  ‚Üí Good position for ranged combat`);\n            Chat.log(`  ‚Üí Monitor for approach opportunities`);\n        }\n\n        if (isElder) {\n            Chat.log(`\\n  &cüëë ELDER GUARDIAN TACTICS:`);\n            Chat.log(`  ‚Üí Bring milk for Mining Fatigue removal`);\n            Chat.log(`  ‚Üí Elder has more health and deals more damage`);\n            Chat.log(`  ‚Üí Consider using enchanted weapons and armor`);\n            Chat.log(`  ‚Üí Retreat more frequently to heal`);\n        }\n\n        if (target && target.getType() === \"minecraft:player\") {\n            Chat.log(`\\n  &cüíÄ PLAYER TARGETED:`);\n            Chat.log(`  ‚Üí Guardian is actively attacking a player`);\n            Chat.log(`  ‚Üí Immediate intervention may be required`);\n            Chat.log(`  ‚Üí Coordinate with other players if available`);\n        }\n\n        // Environmental recommendations\n        this.provideEnvironmentalRecommendations(data.entity.getPos());\n    }\n\n    provideEnvironmentalRecommendations(guardianPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`\\n  üåä Environmental Considerations:`);\n\n        // Check water depth\n        const waterDepth = this.getWaterDepth(guardianPos);\n        if (waterDepth > 15) {\n            Chat.log(`  ‚Üí Deep water environment (${waterDepth.toFixed(0)} blocks)`);\n            Chat.log(`  ‚Üí Guardian has significant mobility advantage`);\n            Chat.log(`  ‚Üí Consider surface combat or creating air pockets`);\n        } else if (waterDepth > 8) {\n            Chat.log(`  ‚Üí Medium water depth - balanced combat conditions`);\n        } else {\n            Chat.log(`  ‚Üí Shallow water - player advantage possible`);\n        }\n\n        // Check for nearby cover\n        const coverAvailable = this.findNearbyCover(playerPos, 16);\n        if (coverAvailable > 0) {\n            Chat.log(`  ‚Üí Cover detected nearby (${coverAvailable} potential positions)`);\n            Chat.log(`  ‚Üí Use cover to break line of sight during attacks`);\n        } else {\n            Chat.log(`  ‚Üí Limited cover available - consider tactical positioning`);\n        }\n\n        // Light level considerations\n        const lightLevel = this.getLightLevel(guardianPos);\n        if (lightLevel < 4) {\n            Chat.log(`  ‚Üí Dark environment - enhanced guardian stealth`);\n            Chat.log(`  ‚Üí Consider light sources for better visibility`);\n        }\n    }\n\n    getWaterDepth(pos) {\n        let depth = 0;\n        let checkY = Math.floor(pos.y);\n\n        while (checkY > pos.y - 30 && depth < 30) { // Check up to 30 blocks down\n            const block = World.getBlock(Math.floor(pos.x), checkY, Math.floor(pos.z));\n            if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                depth++;\n            } else {\n                break;\n            }\n            checkY--;\n        }\n\n        return depth;\n    }\n\n    findNearbyCover(pos, radius) {\n        let coverCount = 0;\n\n        for (let x = -radius; x <= radius; x += 4) {\n            for (let z = -radius; z <= radius; z += 4) {\n                for (let y = -3; y <= 3; y += 2) {\n                    const checkPos = {\n                        x: Math.floor(pos.x + x),\n                        y: Math.floor(pos.y + y),\n                        z: Math.floor(pos.z + z)\n                    };\n\n                    const block = World.getBlock(checkPos.x, checkPos.y, checkPos.z);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        coverCount++;\n                    }\n                }\n            }\n        }\n\n        return coverCount;\n    }\n\n    getLightLevel(pos) {\n        const block = World.getBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));\n        // This is a simplified approach - actual light level detection would be more complex\n        return 8; // Placeholder\n    }\n\n    checkOceanMonumentProximity(pos) {\n        // Simple heuristic for ocean monument detection\n        // In practice, this would check for actual monument structure detection\n        const waterBlocksNearby = this.countWaterBlocksNearby(pos, 16);\n\n        if (waterBlocksNearby > 200) {\n            if (this.oceanMonumentProximity < 75) {\n                this.oceanMonumentProximity = 75;\n                Chat.log(`&6üèõÔ∏è Possible ocean monument proximity detected`);\n                Chat.log(`High guardian activity area - exercise extreme caution`);\n            }\n        }\n    }\n\n    countWaterBlocksNearby(pos, radius) {\n        let waterCount = 0;\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -5; y <= 5; y += 2) {\n                    const block = World.getBlock(\n                        Math.floor(pos.x + x),\n                        Math.floor(pos.y + y),\n                        Math.floor(pos.z + z)\n                    );\n\n                    if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        waterCount++;\n                    }\n                }\n            }\n        }\n\n        return waterCount;\n    }\n\n    sendPlayerTargetAlert(playerName, distance, isElder) {\n        const currentTime = Client.getTime();\n        const alertKey = \"player_target_alert\";\n        const lastAlert = this.alertCooldowns?.get(alertKey) || 0;\n\n        if (!this.alertCooldowns) this.alertCooldowns = new Map();\n\n        if (currentTime - lastAlert < 60) return; // 3 second cooldown\n\n        let alertMessage = `${playerName} targeted by ${isElder ? \"ELDER\" : \"regular\"} guardian`;\n        let urgency = distance <= 12 ? \"CRITICAL\" : distance <= 20 ? \"URGENT\" : \"WARNING\";\n\n        Chat.actionbar(`&cüíÄ ${urgency}: ${alertMessage} (${distance.toFixed(0)}m)`);\n        this.alertCooldowns.set(alertKey, currentTime);\n    }\n\n    generateReport() {\n        if (this.guardians.size === 0) {\n            Chat.log(\"No guardian data available\");\n            return;\n        }\n\n        const analysisDuration = (Client.getTime() - this.analysisStartTime) / 20;\n\n        Chat.log(`&6=== Guardian Analysis Report ===`);\n        Chat.log(`Analysis Duration: ${analysisDuration.toFixed(1)} seconds`);\n        Chat.log(`Guardians Detected: ${this.guardians.size}`);\n        Chat.log(`Elder Guardians: ${this.elderGuardianCount}`);\n        Chat.log(`Ocean Monument Proximity: ${this.oceanMonumentProximity}%`);\n\n        let totalCombatTime = 0;\n        let highThreatCount = 0;\n        let activeTargetingCount = 0;\n\n        for (const [uuid, data] of this.guardians) {\n            const currentGuardian = data.entity.as(\"minecraft:guardian\");\n            const hasTarget = currentGuardian.hasTarget();\n            const isElder = data.isElder;\n            const health = data.entity.asLiving().getHealth();\n            const maxHealth = data.entity.asLiving().getMaxHealth();\n\n            if (hasTarget) activeTargetingCount++;\n            if (data.maxAggressionLevel >= 60) highThreatCount++;\n\n            Chat.log(`\\n${data.name}:`);\n            Chat.log(`  Type: ${isElder ? \"Elder\" : \"Regular\"} Guardian`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n            Chat.log(`  Max Aggression: ${data.maxAggressionLevel.toFixed(0)}%`);\n            Chat.log(`  Targeting Events: ${data.targetingHistory.filter(t => t.hasTarget).length}`);\n            Chat.log(`  Combat Sessions: ${data.combatSessions.length}`);\n\n            // Calculate total targeting time\n            const targetingEntries = data.targetingHistory.filter(entry => entry.hasTarget);\n            if (targetingEntries.length > 1) {\n                let totalTargetingTime = 0;\n                for (let i = 1; i < targetingEntries.length; i++) {\n                    totalTargetingTime += targetingEntries[i].time - targetingEntries[i-1].time;\n                }\n                totalCombatTime += totalTargetingTime / 20; // Convert to seconds\n            }\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Targeting: ${activeTargetingCount}/${this.guardians.size}`);\n        Chat.log(`High Threat Guardians: ${highThreatCount}`);\n        Chat.log(`Estimated Combat Time: ${totalCombatTime.toFixed(1)} seconds`);\n\n        if (this.elderGuardianCount >= 1) {\n            Chat.log(`\\n&cüëë ELDER GUARDIAN WARNING:`);\n            Chat.log(`Elder guardians present - extreme caution required`);\n            Chat.log(`Mining Fatigue effects likely in area`);\n            Chat.log(`Ensure adequate preparation before engagement`);\n        }\n\n        if (activeTargetingCount >= this.guardians.size * 0.7) {\n            Chat.log(`\\n&e‚ö†Ô∏è HIGH GUARDIAN ACTIVITY:`);\n            Chat.log(`Multiple guardians actively targeting`);\n            Chat.log(`Consider strategic retreat or full combat preparation`);\n        }\n    }\n}\n\nconst guardianAnalyzer = new GuardianAnalyzer();\n\n// Analyze guardians every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 64;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:guardian\")) {\n            guardianAnalyzer.analyzeGuardian(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.r\" && e.action === 1) { // R key\n        guardianAnalyzer.generateReport();\n    }\n}));"
      ]
    },
    {
      "name": "hasTarget",
      "signature": "hasTarget()",
      "returnType": "boolean",
      "description": "Checks if the guardian currently has an entity targeted for its laser beam attack.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive guardian detection and analysis system\nclass GuardianAnalyzer {\n    constructor() {\n        this.guardians = new Map();\n        this.oceanMonumentProximity = 0;\n        this.elderGuardianCount = 0;\n        this.analysisStartTime = Client.getTime();\n    }\n\n    analyzeGuardian(guardianEntity) {\n        const guardian = guardianEntity.as(\"minecraft:guardian\");\n        if (!guardian) return;\n\n        const uuid = guardianEntity.getUUID();\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted(); // Note behavior\n        const health = guardianEntity.asLiving().getHealth();\n        const maxHealth = guardianEntity.asLiving().getMaxHealth();\n        const pos = guardianEntity.getPos();\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(guardianEntity);\n\n        // Store guardian data\n        if (!this.guardians.has(uuid)) {\n            this.guardians.set(uuid, {\n                entity: guardianEntity,\n                name: guardianEntity.getName().getString(),\n                isElder: isElder,\n                firstSeen: Client.getTime(),\n                targetingHistory: [],\n                combatSessions: [],\n                maxAggressionLevel: 0\n            });\n\n            if (isElder) {\n                this.elderGuardianCount++;\n                Chat.log(`&cüëë ELDER GUARDIAN DETECTED!`);\n            }\n\n            Chat.log(`&eüõ°Ô∏è Guardian detected: ${guardianEntity.getName().getString()}`);\n        }\n\n        const data = this.guardians.get(uuid);\n\n        // Update targeting history\n        data.targetingHistory.push({\n            hasTarget: hasTarget,\n            targetName: target ? target.getName().getString() : null,\n            targetType: target ? target.getType() : null,\n            distance: target ? guardianEntity.getPos().distanceTo(target.getPos()) : null,\n            time: Client.getTime()\n        });\n\n        // Clean old history (keep last 2 minutes)\n        const cutoffTime = Client.getTime() - 2400;\n        data.targetingHistory = data.targetingHistory.filter(entry => entry.time > cutoffTime);\n\n        // Calculate current aggression level\n        const aggressionLevel = this.calculateAggressionLevel(hasTarget, spikesExtended, isElder);\n        data.maxAggressionLevel = Math.max(data.maxAggressionLevel, aggressionLevel);\n\n        // Provide real-time analysis\n        this.provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos);\n\n        // Check for ocean monument proximity\n        this.checkOceanMonumentProximity(pos);\n    }\n\n    calculateAggressionLevel(hasTarget, spikesExtended, isElder) {\n        let level = 0;\n\n        if (hasTarget && spikesExtended) level = 90; // Full combat\n        else if (hasTarget) level = 60; // Targeting\n        else if (spikesExtended) level = 30; // Alert\n        else level = 0; // Passive\n\n        if (isElder) level += 15; // Elder bonus\n\n        return level;\n    }\n\n    provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos) {\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted();\n\n        Chat.log(`&6=== Guardian Analysis ===`);\n        Chat.log(`Type: ${isElder ? \"üëë Elder Guardian\" : \"üõ°Ô∏è Guardian\"}`);\n        Chat.log(`Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)} (${((health/maxHealth)*100).toFixed(0)}%)`);\n        Chat.log(`Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n        // State analysis\n        const state = this.classifyGuardianState(hasTarget, spikesExtended);\n        Chat.log(`State: ${state.emoji} ${state.name}`);\n        Chat.log(`Description: ${state.description}`);\n\n        // Target analysis\n        if (hasTarget && target) {\n            const targetName = target.getName().getString();\n            const targetType = target.getType();\n            const targetDistance = guardian.getEntity().getPos().distanceTo(target.getPos());\n\n            Chat.log(`\\nüéØ Target Analysis:`);\n            Chat.log(`  Target: ${targetName} (${targetType})`);\n            Chat.log(`  Distance to Target: ${targetDistance.toFixed(1)} blocks`);\n\n            if (targetType === \"minecraft:player\") {\n                const targetPlayer = target.asPlayer();\n                const targetHealth = targetPlayer.getHealth();\n                Chat.log(`  &cüíÄ TARGET IS PLAYER!`);\n                Chat.log(`  Player Health: ${targetHealth.toFixed(1)}/${targetPlayer.getMaxHealth().toFixed(1)}`);\n                this.sendPlayerTargetAlert(targetName, targetDistance, isElder);\n            }\n        }\n\n        // Threat assessment\n        const threat = this.assessThreat(data, distance, health, maxHealth, isElder, state);\n        Chat.log(`\\n‚ö†Ô∏è Threat Level: ${threat.level} (${threat.score}/100)`);\n        Chat.log(`Recommendation: ${threat.recommendation}`);\n\n        // Combat recommendations\n        if (state.name === \"COMBAT_ENGAGED\" || state.name === \"TARGETING\") {\n            this.provideCombatRecommendations(data, distance, isElder, target);\n        }\n    }\n\n    classifyGuardianState(hasTarget, spikesExtended) {\n        if (hasTarget && spikesExtended) {\n            return {\n                name: \"COMBAT_ENGAGED\",\n                emoji: \"‚öîÔ∏è\",\n                description: \"Guardian is actively attacking with extended spikes\"\n            };\n        } else if (hasTarget) {\n            return {\n                name: \"TARGETING\",\n                emoji: \"üéØ\",\n                description: \"Guardian is charging laser beam attack\"\n            };\n        } else if (spikesExtended) {\n            return {\n                name: \"DEFENSIVE\",\n                emoji: \"üõ°Ô∏è\",\n                description: \"Guardian is alert with extended spikes\"\n            };\n        } else {\n            return {\n                name: \"PASSIVE\",\n                emoji: \"üòå\",\n                description: \"Guardian is calm and relaxed\"\n            };\n        }\n    }\n\n    assessThreat(data, distance, health, maxHealth, isElder, state) {\n        let score = 0;\n\n        // Base threat by type\n        if (isElder) score += 40;\n        else score += 20;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 8) score += 30;\n        else if (distance <= 16) score += 20;\n        else if (distance <= 24) score += 10;\n\n        // Health threat (higher health means more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        score += healthPercent * 0.2;\n\n        // State threat\n        const stateScores = {\n            \"COMBAT_ENGAGED\": 25,\n            \"TARGETING\": 15,\n            \"DEFENSIVE\": 8,\n            \"PASSIVE\": 0\n        };\n        score += stateScores[state.name] || 0;\n\n        // Multiple guardian threat\n        if (this.guardians.size > 1) {\n            score += (this.guardians.size - 1) * 5;\n        }\n\n        let level, recommendation;\n\n        if (score >= 80) {\n            level = \"CRITICAL\";\n            recommendation = \"Immediate retreat or full combat preparation required\";\n        } else if (score >= 60) {\n            level = \"HIGH\";\n            recommendation = \"Prepare for combat, maintain tactical distance\";\n        } else if (score >= 40) {\n            level = \"MEDIUM\";\n            recommendation = \"Monitor situation, be ready to engage or retreat\";\n        } else {\n            level = \"LOW\";\n            recommendation = \"Safe to approach if needed, remain cautious\";\n        }\n\n        return { level, score: Math.min(score, 100), recommendation };\n    }\n\n    provideCombatRecommendations(data, distance, isElder, target) {\n        Chat.log(`\\n‚öîÔ∏è Combat Recommendations:`);\n\n        if (distance <= 12) {\n            Chat.log(`  &cüî• CLOSE COMBAT ZONE:`);\n            Chat.log(`  ‚Üí Break line of sight immediately`);\n            Chat.log(`  ‚Üí Use pillars or walls as cover`);\n            Chat.log(`  ‚Üí Consider retreat to safer distance`);\n        } else if (distance <= 24) {\n            Chat.log(`  &eüèπ OPTIMAL COMBAT RANGE:`);\n            Chat.log(`  ‚Üí Use ranged weapons (bow, crossbow)`);\n            Chat.log(`  ‚Üí Keep moving to avoid laser beams`);\n            Chat.log(`  ‚Üí Attack during guardian cooldown periods`);\n        } else {\n            Chat.log(`  &aüéØ LONG RANGE ADVANTAGE:`);\n            Chat.log(`  ‚Üí Guardian attack effectiveness reduced`);\n            Chat.log(`  ‚Üí Good position for ranged combat`);\n            Chat.log(`  ‚Üí Monitor for approach opportunities`);\n        }\n\n        if (isElder) {\n            Chat.log(`\\n  &cüëë ELDER GUARDIAN TACTICS:`);\n            Chat.log(`  ‚Üí Bring milk for Mining Fatigue removal`);\n            Chat.log(`  ‚Üí Elder has more health and deals more damage`);\n            Chat.log(`  ‚Üí Consider using enchanted weapons and armor`);\n            Chat.log(`  ‚Üí Retreat more frequently to heal`);\n        }\n\n        if (target && target.getType() === \"minecraft:player\") {\n            Chat.log(`\\n  &cüíÄ PLAYER TARGETED:`);\n            Chat.log(`  ‚Üí Guardian is actively attacking a player`);\n            Chat.log(`  ‚Üí Immediate intervention may be required`);\n            Chat.log(`  ‚Üí Coordinate with other players if available`);\n        }\n\n        // Environmental recommendations\n        this.provideEnvironmentalRecommendations(data.entity.getPos());\n    }\n\n    provideEnvironmentalRecommendations(guardianPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`\\n  üåä Environmental Considerations:`);\n\n        // Check water depth\n        const waterDepth = this.getWaterDepth(guardianPos);\n        if (waterDepth > 15) {\n            Chat.log(`  ‚Üí Deep water environment (${waterDepth.toFixed(0)} blocks)`);\n            Chat.log(`  ‚Üí Guardian has significant mobility advantage`);\n            Chat.log(`  ‚Üí Consider surface combat or creating air pockets`);\n        } else if (waterDepth > 8) {\n            Chat.log(`  ‚Üí Medium water depth - balanced combat conditions`);\n        } else {\n            Chat.log(`  ‚Üí Shallow water - player advantage possible`);\n        }\n\n        // Check for nearby cover\n        const coverAvailable = this.findNearbyCover(playerPos, 16);\n        if (coverAvailable > 0) {\n            Chat.log(`  ‚Üí Cover detected nearby (${coverAvailable} potential positions)`);\n            Chat.log(`  ‚Üí Use cover to break line of sight during attacks`);\n        } else {\n            Chat.log(`  ‚Üí Limited cover available - consider tactical positioning`);\n        }\n\n        // Light level considerations\n        const lightLevel = this.getLightLevel(guardianPos);\n        if (lightLevel < 4) {\n            Chat.log(`  ‚Üí Dark environment - enhanced guardian stealth`);\n            Chat.log(`  ‚Üí Consider light sources for better visibility`);\n        }\n    }\n\n    getWaterDepth(pos) {\n        let depth = 0;\n        let checkY = Math.floor(pos.y);\n\n        while (checkY > pos.y - 30 && depth < 30) { // Check up to 30 blocks down\n            const block = World.getBlock(Math.floor(pos.x), checkY, Math.floor(pos.z));\n            if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                depth++;\n            } else {\n                break;\n            }\n            checkY--;\n        }\n\n        return depth;\n    }\n\n    findNearbyCover(pos, radius) {\n        let coverCount = 0;\n\n        for (let x = -radius; x <= radius; x += 4) {\n            for (let z = -radius; z <= radius; z += 4) {\n                for (let y = -3; y <= 3; y += 2) {\n                    const checkPos = {\n                        x: Math.floor(pos.x + x),\n                        y: Math.floor(pos.y + y),\n                        z: Math.floor(pos.z + z)\n                    };\n\n                    const block = World.getBlock(checkPos.x, checkPos.y, checkPos.z);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        coverCount++;\n                    }\n                }\n            }\n        }\n\n        return coverCount;\n    }\n\n    getLightLevel(pos) {\n        const block = World.getBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));\n        // This is a simplified approach - actual light level detection would be more complex\n        return 8; // Placeholder\n    }\n\n    checkOceanMonumentProximity(pos) {\n        // Simple heuristic for ocean monument detection\n        // In practice, this would check for actual monument structure detection\n        const waterBlocksNearby = this.countWaterBlocksNearby(pos, 16);\n\n        if (waterBlocksNearby > 200) {\n            if (this.oceanMonumentProximity < 75) {\n                this.oceanMonumentProximity = 75;\n                Chat.log(`&6üèõÔ∏è Possible ocean monument proximity detected`);\n                Chat.log(`High guardian activity area - exercise extreme caution`);\n            }\n        }\n    }\n\n    countWaterBlocksNearby(pos, radius) {\n        let waterCount = 0;\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -5; y <= 5; y += 2) {\n                    const block = World.getBlock(\n                        Math.floor(pos.x + x),\n                        Math.floor(pos.y + y),\n                        Math.floor(pos.z + z)\n                    );\n\n                    if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        waterCount++;\n                    }\n                }\n            }\n        }\n\n        return waterCount;\n    }\n\n    sendPlayerTargetAlert(playerName, distance, isElder) {\n        const currentTime = Client.getTime();\n        const alertKey = \"player_target_alert\";\n        const lastAlert = this.alertCooldowns?.get(alertKey) || 0;\n\n        if (!this.alertCooldowns) this.alertCooldowns = new Map();\n\n        if (currentTime - lastAlert < 60) return; // 3 second cooldown\n\n        let alertMessage = `${playerName} targeted by ${isElder ? \"ELDER\" : \"regular\"} guardian`;\n        let urgency = distance <= 12 ? \"CRITICAL\" : distance <= 20 ? \"URGENT\" : \"WARNING\";\n\n        Chat.actionbar(`&cüíÄ ${urgency}: ${alertMessage} (${distance.toFixed(0)}m)`);\n        this.alertCooldowns.set(alertKey, currentTime);\n    }\n\n    generateReport() {\n        if (this.guardians.size === 0) {\n            Chat.log(\"No guardian data available\");\n            return;\n        }\n\n        const analysisDuration = (Client.getTime() - this.analysisStartTime) / 20;\n\n        Chat.log(`&6=== Guardian Analysis Report ===`);\n        Chat.log(`Analysis Duration: ${analysisDuration.toFixed(1)} seconds`);\n        Chat.log(`Guardians Detected: ${this.guardians.size}`);\n        Chat.log(`Elder Guardians: ${this.elderGuardianCount}`);\n        Chat.log(`Ocean Monument Proximity: ${this.oceanMonumentProximity}%`);\n\n        let totalCombatTime = 0;\n        let highThreatCount = 0;\n        let activeTargetingCount = 0;\n\n        for (const [uuid, data] of this.guardians) {\n            const currentGuardian = data.entity.as(\"minecraft:guardian\");\n            const hasTarget = currentGuardian.hasTarget();\n            const isElder = data.isElder;\n            const health = data.entity.asLiving().getHealth();\n            const maxHealth = data.entity.asLiving().getMaxHealth();\n\n            if (hasTarget) activeTargetingCount++;\n            if (data.maxAggressionLevel >= 60) highThreatCount++;\n\n            Chat.log(`\\n${data.name}:`);\n            Chat.log(`  Type: ${isElder ? \"Elder\" : \"Regular\"} Guardian`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n            Chat.log(`  Max Aggression: ${data.maxAggressionLevel.toFixed(0)}%`);\n            Chat.log(`  Targeting Events: ${data.targetingHistory.filter(t => t.hasTarget).length}`);\n            Chat.log(`  Combat Sessions: ${data.combatSessions.length}`);\n\n            // Calculate total targeting time\n            const targetingEntries = data.targetingHistory.filter(entry => entry.hasTarget);\n            if (targetingEntries.length > 1) {\n                let totalTargetingTime = 0;\n                for (let i = 1; i < targetingEntries.length; i++) {\n                    totalTargetingTime += targetingEntries[i].time - targetingEntries[i-1].time;\n                }\n                totalCombatTime += totalTargetingTime / 20; // Convert to seconds\n            }\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Targeting: ${activeTargetingCount}/${this.guardians.size}`);\n        Chat.log(`High Threat Guardians: ${highThreatCount}`);\n        Chat.log(`Estimated Combat Time: ${totalCombatTime.toFixed(1)} seconds`);\n\n        if (this.elderGuardianCount >= 1) {\n            Chat.log(`\\n&cüëë ELDER GUARDIAN WARNING:`);\n            Chat.log(`Elder guardians present - extreme caution required`);\n            Chat.log(`Mining Fatigue effects likely in area`);\n            Chat.log(`Ensure adequate preparation before engagement`);\n        }\n\n        if (activeTargetingCount >= this.guardians.size * 0.7) {\n            Chat.log(`\\n&e‚ö†Ô∏è HIGH GUARDIAN ACTIVITY:`);\n            Chat.log(`Multiple guardians actively targeting`);\n            Chat.log(`Consider strategic retreat or full combat preparation`);\n        }\n    }\n}\n\nconst guardianAnalyzer = new GuardianAnalyzer();\n\n// Analyze guardians every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 64;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:guardian\")) {\n            guardianAnalyzer.analyzeGuardian(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.r\" && e.action === 1) { // R key\n        guardianAnalyzer.generateReport();\n    }\n}));"
      ]
    },
    {
      "name": "hasTarget",
      "signature": "hasTarget()",
      "returnType": "boolean",
      "description": "Checks if the guardian currently has an entity targeted for its laser beam attack.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive guardian detection and analysis system\nclass GuardianAnalyzer {\n    constructor() {\n        this.guardians = new Map();\n        this.oceanMonumentProximity = 0;\n        this.elderGuardianCount = 0;\n        this.analysisStartTime = Client.getTime();\n    }\n\n    analyzeGuardian(guardianEntity) {\n        const guardian = guardianEntity.as(\"minecraft:guardian\");\n        if (!guardian) return;\n\n        const uuid = guardianEntity.getUUID();\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted(); // Note behavior\n        const health = guardianEntity.asLiving().getHealth();\n        const maxHealth = guardianEntity.asLiving().getMaxHealth();\n        const pos = guardianEntity.getPos();\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(guardianEntity);\n\n        // Store guardian data\n        if (!this.guardians.has(uuid)) {\n            this.guardians.set(uuid, {\n                entity: guardianEntity,\n                name: guardianEntity.getName().getString(),\n                isElder: isElder,\n                firstSeen: Client.getTime(),\n                targetingHistory: [],\n                combatSessions: [],\n                maxAggressionLevel: 0\n            });\n\n            if (isElder) {\n                this.elderGuardianCount++;\n                Chat.log(`&cüëë ELDER GUARDIAN DETECTED!`);\n            }\n\n            Chat.log(`&eüõ°Ô∏è Guardian detected: ${guardianEntity.getName().getString()}`);\n        }\n\n        const data = this.guardians.get(uuid);\n\n        // Update targeting history\n        data.targetingHistory.push({\n            hasTarget: hasTarget,\n            targetName: target ? target.getName().getString() : null,\n            targetType: target ? target.getType() : null,\n            distance: target ? guardianEntity.getPos().distanceTo(target.getPos()) : null,\n            time: Client.getTime()\n        });\n\n        // Clean old history (keep last 2 minutes)\n        const cutoffTime = Client.getTime() - 2400;\n        data.targetingHistory = data.targetingHistory.filter(entry => entry.time > cutoffTime);\n\n        // Calculate current aggression level\n        const aggressionLevel = this.calculateAggressionLevel(hasTarget, spikesExtended, isElder);\n        data.maxAggressionLevel = Math.max(data.maxAggressionLevel, aggressionLevel);\n\n        // Provide real-time analysis\n        this.provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos);\n\n        // Check for ocean monument proximity\n        this.checkOceanMonumentProximity(pos);\n    }\n\n    calculateAggressionLevel(hasTarget, spikesExtended, isElder) {\n        let level = 0;\n\n        if (hasTarget && spikesExtended) level = 90; // Full combat\n        else if (hasTarget) level = 60; // Targeting\n        else if (spikesExtended) level = 30; // Alert\n        else level = 0; // Passive\n\n        if (isElder) level += 15; // Elder bonus\n\n        return level;\n    }\n\n    provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos) {\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted();\n\n        Chat.log(`&6=== Guardian Analysis ===`);\n        Chat.log(`Type: ${isElder ? \"üëë Elder Guardian\" : \"üõ°Ô∏è Guardian\"}`);\n        Chat.log(`Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)} (${((health/maxHealth)*100).toFixed(0)}%)`);\n        Chat.log(`Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n        // State analysis\n        const state = this.classifyGuardianState(hasTarget, spikesExtended);\n        Chat.log(`State: ${state.emoji} ${state.name}`);\n        Chat.log(`Description: ${state.description}`);\n\n        // Target analysis\n        if (hasTarget && target) {\n            const targetName = target.getName().getString();\n            const targetType = target.getType();\n            const targetDistance = guardian.getEntity().getPos().distanceTo(target.getPos());\n\n            Chat.log(`\\nüéØ Target Analysis:`);\n            Chat.log(`  Target: ${targetName} (${targetType})`);\n            Chat.log(`  Distance to Target: ${targetDistance.toFixed(1)} blocks`);\n\n            if (targetType === \"minecraft:player\") {\n                const targetPlayer = target.asPlayer();\n                const targetHealth = targetPlayer.getHealth();\n                Chat.log(`  &cüíÄ TARGET IS PLAYER!`);\n                Chat.log(`  Player Health: ${targetHealth.toFixed(1)}/${targetPlayer.getMaxHealth().toFixed(1)}`);\n                this.sendPlayerTargetAlert(targetName, targetDistance, isElder);\n            }\n        }\n\n        // Threat assessment\n        const threat = this.assessThreat(data, distance, health, maxHealth, isElder, state);\n        Chat.log(`\\n‚ö†Ô∏è Threat Level: ${threat.level} (${threat.score}/100)`);\n        Chat.log(`Recommendation: ${threat.recommendation}`);\n\n        // Combat recommendations\n        if (state.name === \"COMBAT_ENGAGED\" || state.name === \"TARGETING\") {\n            this.provideCombatRecommendations(data, distance, isElder, target);\n        }\n    }\n\n    classifyGuardianState(hasTarget, spikesExtended) {\n        if (hasTarget && spikesExtended) {\n            return {\n                name: \"COMBAT_ENGAGED\",\n                emoji: \"‚öîÔ∏è\",\n                description: \"Guardian is actively attacking with extended spikes\"\n            };\n        } else if (hasTarget) {\n            return {\n                name: \"TARGETING\",\n                emoji: \"üéØ\",\n                description: \"Guardian is charging laser beam attack\"\n            };\n        } else if (spikesExtended) {\n            return {\n                name: \"DEFENSIVE\",\n                emoji: \"üõ°Ô∏è\",\n                description: \"Guardian is alert with extended spikes\"\n            };\n        } else {\n            return {\n                name: \"PASSIVE\",\n                emoji: \"üòå\",\n                description: \"Guardian is calm and relaxed\"\n            };\n        }\n    }\n\n    assessThreat(data, distance, health, maxHealth, isElder, state) {\n        let score = 0;\n\n        // Base threat by type\n        if (isElder) score += 40;\n        else score += 20;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 8) score += 30;\n        else if (distance <= 16) score += 20;\n        else if (distance <= 24) score += 10;\n\n        // Health threat (higher health means more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        score += healthPercent * 0.2;\n\n        // State threat\n        const stateScores = {\n            \"COMBAT_ENGAGED\": 25,\n            \"TARGETING\": 15,\n            \"DEFENSIVE\": 8,\n            \"PASSIVE\": 0\n        };\n        score += stateScores[state.name] || 0;\n\n        // Multiple guardian threat\n        if (this.guardians.size > 1) {\n            score += (this.guardians.size - 1) * 5;\n        }\n\n        let level, recommendation;\n\n        if (score >= 80) {\n            level = \"CRITICAL\";\n            recommendation = \"Immediate retreat or full combat preparation required\";\n        } else if (score >= 60) {\n            level = \"HIGH\";\n            recommendation = \"Prepare for combat, maintain tactical distance\";\n        } else if (score >= 40) {\n            level = \"MEDIUM\";\n            recommendation = \"Monitor situation, be ready to engage or retreat\";\n        } else {\n            level = \"LOW\";\n            recommendation = \"Safe to approach if needed, remain cautious\";\n        }\n\n        return { level, score: Math.min(score, 100), recommendation };\n    }\n\n    provideCombatRecommendations(data, distance, isElder, target) {\n        Chat.log(`\\n‚öîÔ∏è Combat Recommendations:`);\n\n        if (distance <= 12) {\n            Chat.log(`  &cüî• CLOSE COMBAT ZONE:`);\n            Chat.log(`  ‚Üí Break line of sight immediately`);\n            Chat.log(`  ‚Üí Use pillars or walls as cover`);\n            Chat.log(`  ‚Üí Consider retreat to safer distance`);\n        } else if (distance <= 24) {\n            Chat.log(`  &eüèπ OPTIMAL COMBAT RANGE:`);\n            Chat.log(`  ‚Üí Use ranged weapons (bow, crossbow)`);\n            Chat.log(`  ‚Üí Keep moving to avoid laser beams`);\n            Chat.log(`  ‚Üí Attack during guardian cooldown periods`);\n        } else {\n            Chat.log(`  &aüéØ LONG RANGE ADVANTAGE:`);\n            Chat.log(`  ‚Üí Guardian attack effectiveness reduced`);\n            Chat.log(`  ‚Üí Good position for ranged combat`);\n            Chat.log(`  ‚Üí Monitor for approach opportunities`);\n        }\n\n        if (isElder) {\n            Chat.log(`\\n  &cüëë ELDER GUARDIAN TACTICS:`);\n            Chat.log(`  ‚Üí Bring milk for Mining Fatigue removal`);\n            Chat.log(`  ‚Üí Elder has more health and deals more damage`);\n            Chat.log(`  ‚Üí Consider using enchanted weapons and armor`);\n            Chat.log(`  ‚Üí Retreat more frequently to heal`);\n        }\n\n        if (target && target.getType() === \"minecraft:player\") {\n            Chat.log(`\\n  &cüíÄ PLAYER TARGETED:`);\n            Chat.log(`  ‚Üí Guardian is actively attacking a player`);\n            Chat.log(`  ‚Üí Immediate intervention may be required`);\n            Chat.log(`  ‚Üí Coordinate with other players if available`);\n        }\n\n        // Environmental recommendations\n        this.provideEnvironmentalRecommendations(data.entity.getPos());\n    }\n\n    provideEnvironmentalRecommendations(guardianPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`\\n  üåä Environmental Considerations:`);\n\n        // Check water depth\n        const waterDepth = this.getWaterDepth(guardianPos);\n        if (waterDepth > 15) {\n            Chat.log(`  ‚Üí Deep water environment (${waterDepth.toFixed(0)} blocks)`);\n            Chat.log(`  ‚Üí Guardian has significant mobility advantage`);\n            Chat.log(`  ‚Üí Consider surface combat or creating air pockets`);\n        } else if (waterDepth > 8) {\n            Chat.log(`  ‚Üí Medium water depth - balanced combat conditions`);\n        } else {\n            Chat.log(`  ‚Üí Shallow water - player advantage possible`);\n        }\n\n        // Check for nearby cover\n        const coverAvailable = this.findNearbyCover(playerPos, 16);\n        if (coverAvailable > 0) {\n            Chat.log(`  ‚Üí Cover detected nearby (${coverAvailable} potential positions)`);\n            Chat.log(`  ‚Üí Use cover to break line of sight during attacks`);\n        } else {\n            Chat.log(`  ‚Üí Limited cover available - consider tactical positioning`);\n        }\n\n        // Light level considerations\n        const lightLevel = this.getLightLevel(guardianPos);\n        if (lightLevel < 4) {\n            Chat.log(`  ‚Üí Dark environment - enhanced guardian stealth`);\n            Chat.log(`  ‚Üí Consider light sources for better visibility`);\n        }\n    }\n\n    getWaterDepth(pos) {\n        let depth = 0;\n        let checkY = Math.floor(pos.y);\n\n        while (checkY > pos.y - 30 && depth < 30) { // Check up to 30 blocks down\n            const block = World.getBlock(Math.floor(pos.x), checkY, Math.floor(pos.z));\n            if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                depth++;\n            } else {\n                break;\n            }\n            checkY--;\n        }\n\n        return depth;\n    }\n\n    findNearbyCover(pos, radius) {\n        let coverCount = 0;\n\n        for (let x = -radius; x <= radius; x += 4) {\n            for (let z = -radius; z <= radius; z += 4) {\n                for (let y = -3; y <= 3; y += 2) {\n                    const checkPos = {\n                        x: Math.floor(pos.x + x),\n                        y: Math.floor(pos.y + y),\n                        z: Math.floor(pos.z + z)\n                    };\n\n                    const block = World.getBlock(checkPos.x, checkPos.y, checkPos.z);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        coverCount++;\n                    }\n                }\n            }\n        }\n\n        return coverCount;\n    }\n\n    getLightLevel(pos) {\n        const block = World.getBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));\n        // This is a simplified approach - actual light level detection would be more complex\n        return 8; // Placeholder\n    }\n\n    checkOceanMonumentProximity(pos) {\n        // Simple heuristic for ocean monument detection\n        // In practice, this would check for actual monument structure detection\n        const waterBlocksNearby = this.countWaterBlocksNearby(pos, 16);\n\n        if (waterBlocksNearby > 200) {\n            if (this.oceanMonumentProximity < 75) {\n                this.oceanMonumentProximity = 75;\n                Chat.log(`&6üèõÔ∏è Possible ocean monument proximity detected`);\n                Chat.log(`High guardian activity area - exercise extreme caution`);\n            }\n        }\n    }\n\n    countWaterBlocksNearby(pos, radius) {\n        let waterCount = 0;\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -5; y <= 5; y += 2) {\n                    const block = World.getBlock(\n                        Math.floor(pos.x + x),\n                        Math.floor(pos.y + y),\n                        Math.floor(pos.z + z)\n                    );\n\n                    if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        waterCount++;\n                    }\n                }\n            }\n        }\n\n        return waterCount;\n    }\n\n    sendPlayerTargetAlert(playerName, distance, isElder) {\n        const currentTime = Client.getTime();\n        const alertKey = \"player_target_alert\";\n        const lastAlert = this.alertCooldowns?.get(alertKey) || 0;\n\n        if (!this.alertCooldowns) this.alertCooldowns = new Map();\n\n        if (currentTime - lastAlert < 60) return; // 3 second cooldown\n\n        let alertMessage = `${playerName} targeted by ${isElder ? \"ELDER\" : \"regular\"} guardian`;\n        let urgency = distance <= 12 ? \"CRITICAL\" : distance <= 20 ? \"URGENT\" : \"WARNING\";\n\n        Chat.actionbar(`&cüíÄ ${urgency}: ${alertMessage} (${distance.toFixed(0)}m)`);\n        this.alertCooldowns.set(alertKey, currentTime);\n    }\n\n    generateReport() {\n        if (this.guardians.size === 0) {\n            Chat.log(\"No guardian data available\");\n            return;\n        }\n\n        const analysisDuration = (Client.getTime() - this.analysisStartTime) / 20;\n\n        Chat.log(`&6=== Guardian Analysis Report ===`);\n        Chat.log(`Analysis Duration: ${analysisDuration.toFixed(1)} seconds`);\n        Chat.log(`Guardians Detected: ${this.guardians.size}`);\n        Chat.log(`Elder Guardians: ${this.elderGuardianCount}`);\n        Chat.log(`Ocean Monument Proximity: ${this.oceanMonumentProximity}%`);\n\n        let totalCombatTime = 0;\n        let highThreatCount = 0;\n        let activeTargetingCount = 0;\n\n        for (const [uuid, data] of this.guardians) {\n            const currentGuardian = data.entity.as(\"minecraft:guardian\");\n            const hasTarget = currentGuardian.hasTarget();\n            const isElder = data.isElder;\n            const health = data.entity.asLiving().getHealth();\n            const maxHealth = data.entity.asLiving().getMaxHealth();\n\n            if (hasTarget) activeTargetingCount++;\n            if (data.maxAggressionLevel >= 60) highThreatCount++;\n\n            Chat.log(`\\n${data.name}:`);\n            Chat.log(`  Type: ${isElder ? \"Elder\" : \"Regular\"} Guardian`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n            Chat.log(`  Max Aggression: ${data.maxAggressionLevel.toFixed(0)}%`);\n            Chat.log(`  Targeting Events: ${data.targetingHistory.filter(t => t.hasTarget).length}`);\n            Chat.log(`  Combat Sessions: ${data.combatSessions.length}`);\n\n            // Calculate total targeting time\n            const targetingEntries = data.targetingHistory.filter(entry => entry.hasTarget);\n            if (targetingEntries.length > 1) {\n                let totalTargetingTime = 0;\n                for (let i = 1; i < targetingEntries.length; i++) {\n                    totalTargetingTime += targetingEntries[i].time - targetingEntries[i-1].time;\n                }\n                totalCombatTime += totalTargetingTime / 20; // Convert to seconds\n            }\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Targeting: ${activeTargetingCount}/${this.guardians.size}`);\n        Chat.log(`High Threat Guardians: ${highThreatCount}`);\n        Chat.log(`Estimated Combat Time: ${totalCombatTime.toFixed(1)} seconds`);\n\n        if (this.elderGuardianCount >= 1) {\n            Chat.log(`\\n&cüëë ELDER GUARDIAN WARNING:`);\n            Chat.log(`Elder guardians present - extreme caution required`);\n            Chat.log(`Mining Fatigue effects likely in area`);\n            Chat.log(`Ensure adequate preparation before engagement`);\n        }\n\n        if (activeTargetingCount >= this.guardians.size * 0.7) {\n            Chat.log(`\\n&e‚ö†Ô∏è HIGH GUARDIAN ACTIVITY:`);\n            Chat.log(`Multiple guardians actively targeting`);\n            Chat.log(`Consider strategic retreat or full combat preparation`);\n        }\n    }\n}\n\nconst guardianAnalyzer = new GuardianAnalyzer();\n\n// Analyze guardians every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 64;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:guardian\")) {\n            guardianAnalyzer.analyzeGuardian(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.r\" && e.action === 1) { // R key\n        guardianAnalyzer.generateReport();\n    }\n}));"
      ]
    },
    {
      "name": "getTarget",
      "signature": "getTarget()",
      "returnType": "EntityHelper",
      "description": "Retrieves the entity that the guardian is currently targeting with its laser beam. Returns `null` if no target is present.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive guardian detection and analysis system\nclass GuardianAnalyzer {\n    constructor() {\n        this.guardians = new Map();\n        this.oceanMonumentProximity = 0;\n        this.elderGuardianCount = 0;\n        this.analysisStartTime = Client.getTime();\n    }\n\n    analyzeGuardian(guardianEntity) {\n        const guardian = guardianEntity.as(\"minecraft:guardian\");\n        if (!guardian) return;\n\n        const uuid = guardianEntity.getUUID();\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted(); // Note behavior\n        const health = guardianEntity.asLiving().getHealth();\n        const maxHealth = guardianEntity.asLiving().getMaxHealth();\n        const pos = guardianEntity.getPos();\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(guardianEntity);\n\n        // Store guardian data\n        if (!this.guardians.has(uuid)) {\n            this.guardians.set(uuid, {\n                entity: guardianEntity,\n                name: guardianEntity.getName().getString(),\n                isElder: isElder,\n                firstSeen: Client.getTime(),\n                targetingHistory: [],\n                combatSessions: [],\n                maxAggressionLevel: 0\n            });\n\n            if (isElder) {\n                this.elderGuardianCount++;\n                Chat.log(`&cüëë ELDER GUARDIAN DETECTED!`);\n            }\n\n            Chat.log(`&eüõ°Ô∏è Guardian detected: ${guardianEntity.getName().getString()}`);\n        }\n\n        const data = this.guardians.get(uuid);\n\n        // Update targeting history\n        data.targetingHistory.push({\n            hasTarget: hasTarget,\n            targetName: target ? target.getName().getString() : null,\n            targetType: target ? target.getType() : null,\n            distance: target ? guardianEntity.getPos().distanceTo(target.getPos()) : null,\n            time: Client.getTime()\n        });\n\n        // Clean old history (keep last 2 minutes)\n        const cutoffTime = Client.getTime() - 2400;\n        data.targetingHistory = data.targetingHistory.filter(entry => entry.time > cutoffTime);\n\n        // Calculate current aggression level\n        const aggressionLevel = this.calculateAggressionLevel(hasTarget, spikesExtended, isElder);\n        data.maxAggressionLevel = Math.max(data.maxAggressionLevel, aggressionLevel);\n\n        // Provide real-time analysis\n        this.provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos);\n\n        // Check for ocean monument proximity\n        this.checkOceanMonumentProximity(pos);\n    }\n\n    calculateAggressionLevel(hasTarget, spikesExtended, isElder) {\n        let level = 0;\n\n        if (hasTarget && spikesExtended) level = 90; // Full combat\n        else if (hasTarget) level = 60; // Targeting\n        else if (spikesExtended) level = 30; // Alert\n        else level = 0; // Passive\n\n        if (isElder) level += 15; // Elder bonus\n\n        return level;\n    }\n\n    provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos) {\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted();\n\n        Chat.log(`&6=== Guardian Analysis ===`);\n        Chat.log(`Type: ${isElder ? \"üëë Elder Guardian\" : \"üõ°Ô∏è Guardian\"}`);\n        Chat.log(`Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)} (${((health/maxHealth)*100).toFixed(0)}%)`);\n        Chat.log(`Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n        // State analysis\n        const state = this.classifyGuardianState(hasTarget, spikesExtended);\n        Chat.log(`State: ${state.emoji} ${state.name}`);\n        Chat.log(`Description: ${state.description}`);\n\n        // Target analysis\n        if (hasTarget && target) {\n            const targetName = target.getName().getString();\n            const targetType = target.getType();\n            const targetDistance = guardian.getEntity().getPos().distanceTo(target.getPos());\n\n            Chat.log(`\\nüéØ Target Analysis:`);\n            Chat.log(`  Target: ${targetName} (${targetType})`);\n            Chat.log(`  Distance to Target: ${targetDistance.toFixed(1)} blocks`);\n\n            if (targetType === \"minecraft:player\") {\n                const targetPlayer = target.asPlayer();\n                const targetHealth = targetPlayer.getHealth();\n                Chat.log(`  &cüíÄ TARGET IS PLAYER!`);\n                Chat.log(`  Player Health: ${targetHealth.toFixed(1)}/${targetPlayer.getMaxHealth().toFixed(1)}`);\n                this.sendPlayerTargetAlert(targetName, targetDistance, isElder);\n            }\n        }\n\n        // Threat assessment\n        const threat = this.assessThreat(data, distance, health, maxHealth, isElder, state);\n        Chat.log(`\\n‚ö†Ô∏è Threat Level: ${threat.level} (${threat.score}/100)`);\n        Chat.log(`Recommendation: ${threat.recommendation}`);\n\n        // Combat recommendations\n        if (state.name === \"COMBAT_ENGAGED\" || state.name === \"TARGETING\") {\n            this.provideCombatRecommendations(data, distance, isElder, target);\n        }\n    }\n\n    classifyGuardianState(hasTarget, spikesExtended) {\n        if (hasTarget && spikesExtended) {\n            return {\n                name: \"COMBAT_ENGAGED\",\n                emoji: \"‚öîÔ∏è\",\n                description: \"Guardian is actively attacking with extended spikes\"\n            };\n        } else if (hasTarget) {\n            return {\n                name: \"TARGETING\",\n                emoji: \"üéØ\",\n                description: \"Guardian is charging laser beam attack\"\n            };\n        } else if (spikesExtended) {\n            return {\n                name: \"DEFENSIVE\",\n                emoji: \"üõ°Ô∏è\",\n                description: \"Guardian is alert with extended spikes\"\n            };\n        } else {\n            return {\n                name: \"PASSIVE\",\n                emoji: \"üòå\",\n                description: \"Guardian is calm and relaxed\"\n            };\n        }\n    }\n\n    assessThreat(data, distance, health, maxHealth, isElder, state) {\n        let score = 0;\n\n        // Base threat by type\n        if (isElder) score += 40;\n        else score += 20;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 8) score += 30;\n        else if (distance <= 16) score += 20;\n        else if (distance <= 24) score += 10;\n\n        // Health threat (higher health means more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        score += healthPercent * 0.2;\n\n        // State threat\n        const stateScores = {\n            \"COMBAT_ENGAGED\": 25,\n            \"TARGETING\": 15,\n            \"DEFENSIVE\": 8,\n            \"PASSIVE\": 0\n        };\n        score += stateScores[state.name] || 0;\n\n        // Multiple guardian threat\n        if (this.guardians.size > 1) {\n            score += (this.guardians.size - 1) * 5;\n        }\n\n        let level, recommendation;\n\n        if (score >= 80) {\n            level = \"CRITICAL\";\n            recommendation = \"Immediate retreat or full combat preparation required\";\n        } else if (score >= 60) {\n            level = \"HIGH\";\n            recommendation = \"Prepare for combat, maintain tactical distance\";\n        } else if (score >= 40) {\n            level = \"MEDIUM\";\n            recommendation = \"Monitor situation, be ready to engage or retreat\";\n        } else {\n            level = \"LOW\";\n            recommendation = \"Safe to approach if needed, remain cautious\";\n        }\n\n        return { level, score: Math.min(score, 100), recommendation };\n    }\n\n    provideCombatRecommendations(data, distance, isElder, target) {\n        Chat.log(`\\n‚öîÔ∏è Combat Recommendations:`);\n\n        if (distance <= 12) {\n            Chat.log(`  &cüî• CLOSE COMBAT ZONE:`);\n            Chat.log(`  ‚Üí Break line of sight immediately`);\n            Chat.log(`  ‚Üí Use pillars or walls as cover`);\n            Chat.log(`  ‚Üí Consider retreat to safer distance`);\n        } else if (distance <= 24) {\n            Chat.log(`  &eüèπ OPTIMAL COMBAT RANGE:`);\n            Chat.log(`  ‚Üí Use ranged weapons (bow, crossbow)`);\n            Chat.log(`  ‚Üí Keep moving to avoid laser beams`);\n            Chat.log(`  ‚Üí Attack during guardian cooldown periods`);\n        } else {\n            Chat.log(`  &aüéØ LONG RANGE ADVANTAGE:`);\n            Chat.log(`  ‚Üí Guardian attack effectiveness reduced`);\n            Chat.log(`  ‚Üí Good position for ranged combat`);\n            Chat.log(`  ‚Üí Monitor for approach opportunities`);\n        }\n\n        if (isElder) {\n            Chat.log(`\\n  &cüëë ELDER GUARDIAN TACTICS:`);\n            Chat.log(`  ‚Üí Bring milk for Mining Fatigue removal`);\n            Chat.log(`  ‚Üí Elder has more health and deals more damage`);\n            Chat.log(`  ‚Üí Consider using enchanted weapons and armor`);\n            Chat.log(`  ‚Üí Retreat more frequently to heal`);\n        }\n\n        if (target && target.getType() === \"minecraft:player\") {\n            Chat.log(`\\n  &cüíÄ PLAYER TARGETED:`);\n            Chat.log(`  ‚Üí Guardian is actively attacking a player`);\n            Chat.log(`  ‚Üí Immediate intervention may be required`);\n            Chat.log(`  ‚Üí Coordinate with other players if available`);\n        }\n\n        // Environmental recommendations\n        this.provideEnvironmentalRecommendations(data.entity.getPos());\n    }\n\n    provideEnvironmentalRecommendations(guardianPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`\\n  üåä Environmental Considerations:`);\n\n        // Check water depth\n        const waterDepth = this.getWaterDepth(guardianPos);\n        if (waterDepth > 15) {\n            Chat.log(`  ‚Üí Deep water environment (${waterDepth.toFixed(0)} blocks)`);\n            Chat.log(`  ‚Üí Guardian has significant mobility advantage`);\n            Chat.log(`  ‚Üí Consider surface combat or creating air pockets`);\n        } else if (waterDepth > 8) {\n            Chat.log(`  ‚Üí Medium water depth - balanced combat conditions`);\n        } else {\n            Chat.log(`  ‚Üí Shallow water - player advantage possible`);\n        }\n\n        // Check for nearby cover\n        const coverAvailable = this.findNearbyCover(playerPos, 16);\n        if (coverAvailable > 0) {\n            Chat.log(`  ‚Üí Cover detected nearby (${coverAvailable} potential positions)`);\n            Chat.log(`  ‚Üí Use cover to break line of sight during attacks`);\n        } else {\n            Chat.log(`  ‚Üí Limited cover available - consider tactical positioning`);\n        }\n\n        // Light level considerations\n        const lightLevel = this.getLightLevel(guardianPos);\n        if (lightLevel < 4) {\n            Chat.log(`  ‚Üí Dark environment - enhanced guardian stealth`);\n            Chat.log(`  ‚Üí Consider light sources for better visibility`);\n        }\n    }\n\n    getWaterDepth(pos) {\n        let depth = 0;\n        let checkY = Math.floor(pos.y);\n\n        while (checkY > pos.y - 30 && depth < 30) { // Check up to 30 blocks down\n            const block = World.getBlock(Math.floor(pos.x), checkY, Math.floor(pos.z));\n            if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                depth++;\n            } else {\n                break;\n            }\n            checkY--;\n        }\n\n        return depth;\n    }\n\n    findNearbyCover(pos, radius) {\n        let coverCount = 0;\n\n        for (let x = -radius; x <= radius; x += 4) {\n            for (let z = -radius; z <= radius; z += 4) {\n                for (let y = -3; y <= 3; y += 2) {\n                    const checkPos = {\n                        x: Math.floor(pos.x + x),\n                        y: Math.floor(pos.y + y),\n                        z: Math.floor(pos.z + z)\n                    };\n\n                    const block = World.getBlock(checkPos.x, checkPos.y, checkPos.z);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        coverCount++;\n                    }\n                }\n            }\n        }\n\n        return coverCount;\n    }\n\n    getLightLevel(pos) {\n        const block = World.getBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));\n        // This is a simplified approach - actual light level detection would be more complex\n        return 8; // Placeholder\n    }\n\n    checkOceanMonumentProximity(pos) {\n        // Simple heuristic for ocean monument detection\n        // In practice, this would check for actual monument structure detection\n        const waterBlocksNearby = this.countWaterBlocksNearby(pos, 16);\n\n        if (waterBlocksNearby > 200) {\n            if (this.oceanMonumentProximity < 75) {\n                this.oceanMonumentProximity = 75;\n                Chat.log(`&6üèõÔ∏è Possible ocean monument proximity detected`);\n                Chat.log(`High guardian activity area - exercise extreme caution`);\n            }\n        }\n    }\n\n    countWaterBlocksNearby(pos, radius) {\n        let waterCount = 0;\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -5; y <= 5; y += 2) {\n                    const block = World.getBlock(\n                        Math.floor(pos.x + x),\n                        Math.floor(pos.y + y),\n                        Math.floor(pos.z + z)\n                    );\n\n                    if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        waterCount++;\n                    }\n                }\n            }\n        }\n\n        return waterCount;\n    }\n\n    sendPlayerTargetAlert(playerName, distance, isElder) {\n        const currentTime = Client.getTime();\n        const alertKey = \"player_target_alert\";\n        const lastAlert = this.alertCooldowns?.get(alertKey) || 0;\n\n        if (!this.alertCooldowns) this.alertCooldowns = new Map();\n\n        if (currentTime - lastAlert < 60) return; // 3 second cooldown\n\n        let alertMessage = `${playerName} targeted by ${isElder ? \"ELDER\" : \"regular\"} guardian`;\n        let urgency = distance <= 12 ? \"CRITICAL\" : distance <= 20 ? \"URGENT\" : \"WARNING\";\n\n        Chat.actionbar(`&cüíÄ ${urgency}: ${alertMessage} (${distance.toFixed(0)}m)`);\n        this.alertCooldowns.set(alertKey, currentTime);\n    }\n\n    generateReport() {\n        if (this.guardians.size === 0) {\n            Chat.log(\"No guardian data available\");\n            return;\n        }\n\n        const analysisDuration = (Client.getTime() - this.analysisStartTime) / 20;\n\n        Chat.log(`&6=== Guardian Analysis Report ===`);\n        Chat.log(`Analysis Duration: ${analysisDuration.toFixed(1)} seconds`);\n        Chat.log(`Guardians Detected: ${this.guardians.size}`);\n        Chat.log(`Elder Guardians: ${this.elderGuardianCount}`);\n        Chat.log(`Ocean Monument Proximity: ${this.oceanMonumentProximity}%`);\n\n        let totalCombatTime = 0;\n        let highThreatCount = 0;\n        let activeTargetingCount = 0;\n\n        for (const [uuid, data] of this.guardians) {\n            const currentGuardian = data.entity.as(\"minecraft:guardian\");\n            const hasTarget = currentGuardian.hasTarget();\n            const isElder = data.isElder;\n            const health = data.entity.asLiving().getHealth();\n            const maxHealth = data.entity.asLiving().getMaxHealth();\n\n            if (hasTarget) activeTargetingCount++;\n            if (data.maxAggressionLevel >= 60) highThreatCount++;\n\n            Chat.log(`\\n${data.name}:`);\n            Chat.log(`  Type: ${isElder ? \"Elder\" : \"Regular\"} Guardian`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n            Chat.log(`  Max Aggression: ${data.maxAggressionLevel.toFixed(0)}%`);\n            Chat.log(`  Targeting Events: ${data.targetingHistory.filter(t => t.hasTarget).length}`);\n            Chat.log(`  Combat Sessions: ${data.combatSessions.length}`);\n\n            // Calculate total targeting time\n            const targetingEntries = data.targetingHistory.filter(entry => entry.hasTarget);\n            if (targetingEntries.length > 1) {\n                let totalTargetingTime = 0;\n                for (let i = 1; i < targetingEntries.length; i++) {\n                    totalTargetingTime += targetingEntries[i].time - targetingEntries[i-1].time;\n                }\n                totalCombatTime += totalTargetingTime / 20; // Convert to seconds\n            }\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Targeting: ${activeTargetingCount}/${this.guardians.size}`);\n        Chat.log(`High Threat Guardians: ${highThreatCount}`);\n        Chat.log(`Estimated Combat Time: ${totalCombatTime.toFixed(1)} seconds`);\n\n        if (this.elderGuardianCount >= 1) {\n            Chat.log(`\\n&cüëë ELDER GUARDIAN WARNING:`);\n            Chat.log(`Elder guardians present - extreme caution required`);\n            Chat.log(`Mining Fatigue effects likely in area`);\n            Chat.log(`Ensure adequate preparation before engagement`);\n        }\n\n        if (activeTargetingCount >= this.guardians.size * 0.7) {\n            Chat.log(`\\n&e‚ö†Ô∏è HIGH GUARDIAN ACTIVITY:`);\n            Chat.log(`Multiple guardians actively targeting`);\n            Chat.log(`Consider strategic retreat or full combat preparation`);\n        }\n    }\n}\n\nconst guardianAnalyzer = new GuardianAnalyzer();\n\n// Analyze guardians every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 64;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:guardian\")) {\n            guardianAnalyzer.analyzeGuardian(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.r\" && e.action === 1) { // R key\n        guardianAnalyzer.generateReport();\n    }\n}));"
      ]
    },
    {
      "name": "hasSpikesRetracted",
      "signature": "hasSpikesRetracted()",
      "returnType": "boolean",
      "description": "Checks if the guardian's defensive spikes are currently retracted. Note: The documentation states this method may have inverted logic in the current implementation; test behavior in your environment.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive guardian detection and analysis system\nclass GuardianAnalyzer {\n    constructor() {\n        this.guardians = new Map();\n        this.oceanMonumentProximity = 0;\n        this.elderGuardianCount = 0;\n        this.analysisStartTime = Client.getTime();\n    }\n\n    analyzeGuardian(guardianEntity) {\n        const guardian = guardianEntity.as(\"minecraft:guardian\");\n        if (!guardian) return;\n\n        const uuid = guardianEntity.getUUID();\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted(); // Note behavior\n        const health = guardianEntity.asLiving().getHealth();\n        const maxHealth = guardianEntity.asLiving().getMaxHealth();\n        const pos = guardianEntity.getPos();\n        const player = Player.getPlayer();\n        const distance = player.distanceTo(guardianEntity);\n\n        // Store guardian data\n        if (!this.guardians.has(uuid)) {\n            this.guardians.set(uuid, {\n                entity: guardianEntity,\n                name: guardianEntity.getName().getString(),\n                isElder: isElder,\n                firstSeen: Client.getTime(),\n                targetingHistory: [],\n                combatSessions: [],\n                maxAggressionLevel: 0\n            });\n\n            if (isElder) {\n                this.elderGuardianCount++;\n                Chat.log(`&cüëë ELDER GUARDIAN DETECTED!`);\n            }\n\n            Chat.log(`&eüõ°Ô∏è Guardian detected: ${guardianEntity.getName().getString()}`);\n        }\n\n        const data = this.guardians.get(uuid);\n\n        // Update targeting history\n        data.targetingHistory.push({\n            hasTarget: hasTarget,\n            targetName: target ? target.getName().getString() : null,\n            targetType: target ? target.getType() : null,\n            distance: target ? guardianEntity.getPos().distanceTo(target.getPos()) : null,\n            time: Client.getTime()\n        });\n\n        // Clean old history (keep last 2 minutes)\n        const cutoffTime = Client.getTime() - 2400;\n        data.targetingHistory = data.targetingHistory.filter(entry => entry.time > cutoffTime);\n\n        // Calculate current aggression level\n        const aggressionLevel = this.calculateAggressionLevel(hasTarget, spikesExtended, isElder);\n        data.maxAggressionLevel = Math.max(data.maxAggressionLevel, aggressionLevel);\n\n        // Provide real-time analysis\n        this.provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos);\n\n        // Check for ocean monument proximity\n        this.checkOceanMonumentProximity(pos);\n    }\n\n    calculateAggressionLevel(hasTarget, spikesExtended, isElder) {\n        let level = 0;\n\n        if (hasTarget && spikesExtended) level = 90; // Full combat\n        else if (hasTarget) level = 60; // Targeting\n        else if (spikesExtended) level = 30; // Alert\n        else level = 0; // Passive\n\n        if (isElder) level += 15; // Elder bonus\n\n        return level;\n    }\n\n    provideGuardianAnalysis(data, guardian, health, maxHealth, distance, pos) {\n        const isElder = guardian.isElder();\n        const hasTarget = guardian.hasTarget();\n        const target = guardian.getTarget();\n        const spikesExtended = guardian.hasSpikesRetracted();\n\n        Chat.log(`&6=== Guardian Analysis ===`);\n        Chat.log(`Type: ${isElder ? \"üëë Elder Guardian\" : \"üõ°Ô∏è Guardian\"}`);\n        Chat.log(`Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)} (${((health/maxHealth)*100).toFixed(0)}%)`);\n        Chat.log(`Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n        // State analysis\n        const state = this.classifyGuardianState(hasTarget, spikesExtended);\n        Chat.log(`State: ${state.emoji} ${state.name}`);\n        Chat.log(`Description: ${state.description}`);\n\n        // Target analysis\n        if (hasTarget && target) {\n            const targetName = target.getName().getString();\n            const targetType = target.getType();\n            const targetDistance = guardian.getEntity().getPos().distanceTo(target.getPos());\n\n            Chat.log(`\\nüéØ Target Analysis:`);\n            Chat.log(`  Target: ${targetName} (${targetType})`);\n            Chat.log(`  Distance to Target: ${targetDistance.toFixed(1)} blocks`);\n\n            if (targetType === \"minecraft:player\") {\n                const targetPlayer = target.asPlayer();\n                const targetHealth = targetPlayer.getHealth();\n                Chat.log(`  &cüíÄ TARGET IS PLAYER!`);\n                Chat.log(`  Player Health: ${targetHealth.toFixed(1)}/${targetPlayer.getMaxHealth().toFixed(1)}`);\n                this.sendPlayerTargetAlert(targetName, targetDistance, isElder);\n            }\n        }\n\n        // Threat assessment\n        const threat = this.assessThreat(data, distance, health, maxHealth, isElder, state);\n        Chat.log(`\\n‚ö†Ô∏è Threat Level: ${threat.level} (${threat.score}/100)`);\n        Chat.log(`Recommendation: ${threat.recommendation}`);\n\n        // Combat recommendations\n        if (state.name === \"COMBAT_ENGAGED\" || state.name === \"TARGETING\") {\n            this.provideCombatRecommendations(data, distance, isElder, target);\n        }\n    }\n\n    classifyGuardianState(hasTarget, spikesExtended) {\n        if (hasTarget && spikesExtended) {\n            return {\n                name: \"COMBAT_ENGAGED\",\n                emoji: \"‚öîÔ∏è\",\n                description: \"Guardian is actively attacking with extended spikes\"\n            };\n        } else if (hasTarget) {\n            return {\n                name: \"TARGETING\",\n                emoji: \"üéØ\",\n                description: \"Guardian is charging laser beam attack\"\n            };\n        } else if (spikesExtended) {\n            return {\n                name: \"DEFENSIVE\",\n                emoji: \"üõ°Ô∏è\",\n                description: \"Guardian is alert with extended spikes\"\n            };\n        } else {\n            return {\n                name: \"PASSIVE\",\n                emoji: \"üòå\",\n                description: \"Guardian is calm and relaxed\"\n            };\n        }\n    }\n\n    assessThreat(data, distance, health, maxHealth, isElder, state) {\n        let score = 0;\n\n        // Base threat by type\n        if (isElder) score += 40;\n        else score += 20;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 8) score += 30;\n        else if (distance <= 16) score += 20;\n        else if (distance <= 24) score += 10;\n\n        // Health threat (higher health means more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        score += healthPercent * 0.2;\n\n        // State threat\n        const stateScores = {\n            \"COMBAT_ENGAGED\": 25,\n            \"TARGETING\": 15,\n            \"DEFENSIVE\": 8,\n            \"PASSIVE\": 0\n        };\n        score += stateScores[state.name] || 0;\n\n        // Multiple guardian threat\n        if (this.guardians.size > 1) {\n            score += (this.guardians.size - 1) * 5;\n        }\n\n        let level, recommendation;\n\n        if (score >= 80) {\n            level = \"CRITICAL\";\n            recommendation = \"Immediate retreat or full combat preparation required\";\n        } else if (score >= 60) {\n            level = \"HIGH\";\n            recommendation = \"Prepare for combat, maintain tactical distance\";\n        } else if (score >= 40) {\n            level = \"MEDIUM\";\n            recommendation = \"Monitor situation, be ready to engage or retreat\";\n        } else {\n            level = \"LOW\";\n            recommendation = \"Safe to approach if needed, remain cautious\";\n        }\n\n        return { level, score: Math.min(score, 100), recommendation };\n    }\n\n    provideCombatRecommendations(data, distance, isElder, target) {\n        Chat.log(`\\n‚öîÔ∏è Combat Recommendations:`);\n\n        if (distance <= 12) {\n            Chat.log(`  &cüî• CLOSE COMBAT ZONE:`);\n            Chat.log(`  ‚Üí Break line of sight immediately`);\n            Chat.log(`  ‚Üí Use pillars or walls as cover`);\n            Chat.log(`  ‚Üí Consider retreat to safer distance`);\n        } else if (distance <= 24) {\n            Chat.log(`  &eüèπ OPTIMAL COMBAT RANGE:`);\n            Chat.log(`  ‚Üí Use ranged weapons (bow, crossbow)`);\n            Chat.log(`  ‚Üí Keep moving to avoid laser beams`);\n            Chat.log(`  ‚Üí Attack during guardian cooldown periods`);\n        } else {\n            Chat.log(`  &aüéØ LONG RANGE ADVANTAGE:`);\n            Chat.log(`  ‚Üí Guardian attack effectiveness reduced`);\n            Chat.log(`  ‚Üí Good position for ranged combat`);\n            Chat.log(`  ‚Üí Monitor for approach opportunities`);\n        }\n\n        if (isElder) {\n            Chat.log(`\\n  &cüëë ELDER GUARDIAN TACTICS:`);\n            Chat.log(`  ‚Üí Bring milk for Mining Fatigue removal`);\n            Chat.log(`  ‚Üí Elder has more health and deals more damage`);\n            Chat.log(`  ‚Üí Consider using enchanted weapons and armor`);\n            Chat.log(`  ‚Üí Retreat more frequently to heal`);\n        }\n\n        if (target && target.getType() === \"minecraft:player\") {\n            Chat.log(`\\n  &cüíÄ PLAYER TARGETED:`);\n            Chat.log(`  ‚Üí Guardian is actively attacking a player`);\n            Chat.log(`  ‚Üí Immediate intervention may be required`);\n            Chat.log(`  ‚Üí Coordinate with other players if available`);\n        }\n\n        // Environmental recommendations\n        this.provideEnvironmentalRecommendations(data.entity.getPos());\n    }\n\n    provideEnvironmentalRecommendations(guardianPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`\\n  üåä Environmental Considerations:`);\n\n        // Check water depth\n        const waterDepth = this.getWaterDepth(guardianPos);\n        if (waterDepth > 15) {\n            Chat.log(`  ‚Üí Deep water environment (${waterDepth.toFixed(0)} blocks)`);\n            Chat.log(`  ‚Üí Guardian has significant mobility advantage`);\n            Chat.log(`  ‚Üí Consider surface combat or creating air pockets`);\n        } else if (waterDepth > 8) {\n            Chat.log(`  ‚Üí Medium water depth - balanced combat conditions`);\n        } else {\n            Chat.log(`  ‚Üí Shallow water - player advantage possible`);\n        }\n\n        // Check for nearby cover\n        const coverAvailable = this.findNearbyCover(playerPos, 16);\n        if (coverAvailable > 0) {\n            Chat.log(`  ‚Üí Cover detected nearby (${coverAvailable} potential positions)`);\n            Chat.log(`  ‚Üí Use cover to break line of sight during attacks`);\n        } else {\n            Chat.log(`  ‚Üí Limited cover available - consider tactical positioning`);\n        }\n\n        // Light level considerations\n        const lightLevel = this.getLightLevel(guardianPos);\n        if (lightLevel < 4) {\n            Chat.log(`  ‚Üí Dark environment - enhanced guardian stealth`);\n            Chat.log(`  ‚Üí Consider light sources for better visibility`);\n        }\n    }\n\n    getWaterDepth(pos) {\n        let depth = 0;\n        let checkY = Math.floor(pos.y);\n\n        while (checkY > pos.y - 30 && depth < 30) { // Check up to 30 blocks down\n            const block = World.getBlock(Math.floor(pos.x), checkY, Math.floor(pos.z));\n            if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                depth++;\n            } else {\n                break;\n            }\n            checkY--;\n        }\n\n        return depth;\n    }\n\n    findNearbyCover(pos, radius) {\n        let coverCount = 0;\n\n        for (let x = -radius; x <= radius; x += 4) {\n            for (let z = -radius; z <= radius; z += 4) {\n                for (let y = -3; y <= 3; y += 2) {\n                    const checkPos = {\n                        x: Math.floor(pos.x + x),\n                        y: Math.floor(pos.y + y),\n                        z: Math.floor(pos.z + z)\n                    };\n\n                    const block = World.getBlock(checkPos.x, checkPos.y, checkPos.z);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        coverCount++;\n                    }\n                }\n            }\n        }\n\n        return coverCount;\n    }\n\n    getLightLevel(pos) {\n        const block = World.getBlock(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z));\n        // This is a simplified approach - actual light level detection would be more complex\n        return 8; // Placeholder\n    }\n\n    checkOceanMonumentProximity(pos) {\n        // Simple heuristic for ocean monument detection\n        // In practice, this would check for actual monument structure detection\n        const waterBlocksNearby = this.countWaterBlocksNearby(pos, 16);\n\n        if (waterBlocksNearby > 200) {\n            if (this.oceanMonumentProximity < 75) {\n                this.oceanMonumentProximity = 75;\n                Chat.log(`&6üèõÔ∏è Possible ocean monument proximity detected`);\n                Chat.log(`High guardian activity area - exercise extreme caution`);\n            }\n        }\n    }\n\n    countWaterBlocksNearby(pos, radius) {\n        let waterCount = 0;\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -5; y <= 5; y += 2) {\n                    const block = World.getBlock(\n                        Math.floor(pos.x + x),\n                        Math.floor(pos.y + y),\n                        Math.floor(pos.z + z)\n                    );\n\n                    if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        waterCount++;\n                    }\n                }\n            }\n        }\n\n        return waterCount;\n    }\n\n    sendPlayerTargetAlert(playerName, distance, isElder) {\n        const currentTime = Client.getTime();\n        const alertKey = \"player_target_alert\";\n        const lastAlert = this.alertCooldowns?.get(alertKey) || 0;\n\n        if (!this.alertCooldowns) this.alertCooldowns = new Map();\n\n        if (currentTime - lastAlert < 60) return; // 3 second cooldown\n\n        let alertMessage = `${playerName} targeted by ${isElder ? \"ELDER\" : \"regular\"} guardian`;\n        let urgency = distance <= 12 ? \"CRITICAL\" : distance <= 20 ? \"URGENT\" : \"WARNING\";\n\n        Chat.actionbar(`&cüíÄ ${urgency}: ${alertMessage} (${distance.toFixed(0)}m)`);\n        this.alertCooldowns.set(alertKey, currentTime);\n    }\n\n    generateReport() {\n        if (this.guardians.size === 0) {\n            Chat.log(\"No guardian data available\");\n            return;\n        }\n\n        const analysisDuration = (Client.getTime() - this.analysisStartTime) / 20;\n\n        Chat.log(`&6=== Guardian Analysis Report ===`);\n        Chat.log(`Analysis Duration: ${analysisDuration.toFixed(1)} seconds`);\n        Chat.log(`Guardians Detected: ${this.guardians.size}`);\n        Chat.log(`Elder Guardians: ${this.elderGuardianCount}`);\n        Chat.log(`Ocean Monument Proximity: ${this.oceanMonumentProximity}%`);\n\n        let totalCombatTime = 0;\n        let highThreatCount = 0;\n        let activeTargetingCount = 0;\n\n        for (const [uuid, data] of this.guardians) {\n            const currentGuardian = data.entity.as(\"minecraft:guardian\");\n            const hasTarget = currentGuardian.hasTarget();\n            const isElder = data.isElder;\n            const health = data.entity.asLiving().getHealth();\n            const maxHealth = data.entity.asLiving().getMaxHealth();\n\n            if (hasTarget) activeTargetingCount++;\n            if (data.maxAggressionLevel >= 60) highThreatCount++;\n\n            Chat.log(`\\n${data.name}:`);\n            Chat.log(`  Type: ${isElder ? \"Elder\" : \"Regular\"} Guardian`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n            Chat.log(`  Max Aggression: ${data.maxAggressionLevel.toFixed(0)}%`);\n            Chat.log(`  Targeting Events: ${data.targetingHistory.filter(t => t.hasTarget).length}`);\n            Chat.log(`  Combat Sessions: ${data.combatSessions.length}`);\n\n            // Calculate total targeting time\n            const targetingEntries = data.targetingHistory.filter(entry => entry.hasTarget);\n            if (targetingEntries.length > 1) {\n                let totalTargetingTime = 0;\n                for (let i = 1; i < targetingEntries.length; i++) {\n                    totalTargetingTime += targetingEntries[i].time - targetingEntries[i-1].time;\n                }\n                totalCombatTime += totalTargetingTime / 20; // Convert to seconds\n            }\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Targeting: ${activeTargetingCount}/${this.guardians.size}`);\n        Chat.log(`High Threat Guardians: ${highThreatCount}`);\n        Chat.log(`Estimated Combat Time: ${totalCombatTime.toFixed(1)} seconds`);\n\n        if (this.elderGuardianCount >= 1) {\n            Chat.log(`\\n&cüëë ELDER GUARDIAN WARNING:`);\n            Chat.log(`Elder guardians present - extreme caution required`);\n            Chat.log(`Mining Fatigue effects likely in area`);\n            Chat.log(`Ensure adequate preparation before engagement`);\n        }\n\n        if (activeTargetingCount >= this.guardians.size * 0.7) {\n            Chat.log(`\\n&e‚ö†Ô∏è HIGH GUARDIAN ACTIVITY:`);\n            Chat.log(`Multiple guardians actively targeting`);\n            Chat.log(`Consider strategic retreat or full combat preparation`);\n        }\n    }\n}\n\nconst guardianAnalyzer = new GuardianAnalyzer();\n\n// Analyze guardians every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 64;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:guardian\")) {\n            guardianAnalyzer.analyzeGuardian(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.r\" && e.action === 1) { // R key\n        guardianAnalyzer.generateReport();\n    }\n}));"
      ]
    }
  ]
}