{
  "name": "SlimeEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.SlimeEntityHelper<T extends SlimeEntity>",
  "extends": "MobEntityHelper<T>",
  "since": "JsMacros 1.8.4",
  "description": "Represents a slime entity in the world. SlimeEntityHelper provides access to slime-specific properties and behaviors such as size variations and attack capabilities. This class serves as a specialized helper for all slime variants, tracking their dimensional characteristics and combat behaviors.",
  "overview": "Slimes are gelatinous, cube-shaped hostile mobs that spawn in specific biomes and chunks. They come in multiple sizes, from tiny (harmless) to large (dangerous), and have the unique ability to split into smaller slimes when defeated, except for the smallest size. This helper provides access to the current size of the slime and determines whether it poses a threat based on its dimensions.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, movement, AI control, and other mob properties, while adding slime-specific functionality for size analysis and threat assessment.",
  "constructors": [
    {
      "signature": "(Obtained via events or casting)",
      "description": "SlimeEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through:\n\n- Entity-related events (e.g., `EntityDeath`, `EntityInteract`, `EntitySpawn`)\n- World entity queries and type casting\n- Methods that return slime entities\n- Type casting from EntityHelper using `as(\"minecraft:slime\")` or appropriate casting methods",
      "parameters": [],
      "examples": [
        "// Method 1: From entity events\nJsMacros.on(\"EntitySpawn\", JavaWrapper.methodToJavaAsync((event) => {\n    const entity = event.getEntity();\n    if (entity.is(\"minecraft:slime\")) {\n        const slime = entity; // Already properly typed\n        Chat.log(`Slime spawned! Size: ${slime.getSize()}, Is small: ${slime.isSmall()}`);\n    }\n}));\n\n// Method 2: From world queries\nconst entities = World.getEntities();\nfor (const entity of entities) {\n    if (entity.is(\"minecraft:slime\")) {\n        const slime = entity;\n        const distance = Player.getPlayer().distanceTo(entity);\n        Chat.log(`Found slime at ${distance.toFixed(1)} blocks`);\n    }\n}"
      ]
    }
  ],
  "methods": [
    {
      "name": "getSize",
      "signature": "int getSize()",
      "returnType": "int",
      "description": "Gets the current size of the slime. Slimes can have sizes from 1 (smallest, harmless) to 4 (largest, dangerous). The size directly influences health, damage, and how many times a slime will split.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive slime population analysis and tracking\nclass SlimePopulationAnalyzer {\n    constructor() {\n        this.slimeHistory = new Map();\n        this.populationStats = {\n            total: 0,\n            bySize: { 1: 0, 2: 0, 3: 0, 4: 0 },\n            spawnLocations: [],\n            lastAnalysis: 0\n        };\n        this.analysisInterval = 100; // Analyze every 5 seconds\n    }\n\n    analyzePopulation() {\n        const currentTime = Client.getTime();\n        if (currentTime - this.populationStats.lastAnalysis < this.analysisInterval) {\n            return; // Skip if analyzed recently\n        }\n\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities();\n        const analysisRange = 64;\n        const slimes = entities.filter(entity =>\n            entity.is(\"minecraft:slime\") &&\n            player.distanceTo(entity) <= analysisRange\n        );\n\n        // Reset current stats\n        this.populationStats.total = slimes.length;\n        this.populationStats.bySize = { 1: 0, 2: 0, 3: 0, 4: 0 };\n        this.populationStats.spawnLocations = [];\n\n        // Analyze each slime\n        slimes.forEach(slimeEntity => {\n            const slime = slimeEntity.as(\"minecraft:slime\");\n            if (!slime) return;\n\n            const size = slime.getSize();\n            const pos = slimeEntity.getPos();\n            const health = slimeEntity.asLiving().getHealth();\n            const distance = player.distanceTo(slimeEntity);\n            const isSmall = slime.isSmall();\n\n            this.populationStats.bySize[size]++;\n            this.populationStats.spawnLocations.push({\n                x: pos.x,\n                y: pos.y,\n                z: pos.z,\n                size: size,\n                distance: distance\n            });\n\n            // Track slime history\n            const uuid = slimeEntity.getUUID();\n            if (!this.slimeHistory.has(uuid)) {\n                this.slimeHistory.set(uuid, {\n                    firstSeen: currentTime,\n                    lastSeen: currentTime,\n                    initialSize: size,\n                    sizeChanges: [],\n                    currentHealth: health\n                });\n            } else {\n                const history = this.slimeHistory.get(uuid);\n                history.lastSeen = currentTime;\n                history.currentHealth = health;\n\n                // Track size changes (could indicate splitting or growth)\n                if (history.currentSize !== size) {\n                    history.sizeChanges.push({\n                        from: history.currentSize,\n                        to: size,\n                        time: currentTime\n                    });\n                    history.currentSize = size;\n                }\n            }\n        });\n\n        this.populationStats.lastAnalysis = currentTime;\n        this.displayPopulationAnalysis();\n    }\n\n    displayPopulationAnalysis() {\n        Chat.log(`&6=== Slime Population Analysis ===`);\n        Chat.log(`Total slimes in range: ${this.populationStats.total}`);\n\n        // Size distribution\n        Chat.log(\"\\n&lSize Distribution:\");\n        const total = this.populationStats.total;\n        for (const [size, count] of Object.entries(this.populationStats.bySize)) {\n            const percentage = total > 0 ? (count / total * 100).toFixed(1) : \"0.0\";\n            const emoji = size === \"1\" ? \"‚úÖ\" : size === \"2\" ? \"‚ö†Ô∏è\" : \"üî•\";\n            const threat = size === \"1\" ? \"Harmless\" : size === \"2\" ? \"Moderate\" : size === \"3\" ? \"Dangerous\" : \"Very Dangerous\";\n            Chat.log(`  ${emoji} Size ${size}: ${count} (${percentage}%) - ${threat}`);\n        }\n\n        // Threat assessment\n        const dangerousSlimes = this.populationStats.bySize[2] + this.populationStats.bySize[3] + this.populationStats.bySize[4];\n        const harmlessSlimes = this.populationStats.bySize[1];\n\n        Chat.log(`\\n&lThreat Assessment:`);\n        if (dangerousSlimes === 0) {\n            Chat.log(`  &a‚úÖ Safe Environment: All slimes are harmless!`);\n            Chat.log(`  &a   Perfect for slimeball farming`);\n        } else {\n            Chat.log(`  &c‚ö†Ô∏è Dangerous Slimes: ${dangerousSlimes}`);\n            Chat.log(`  &a   Harmless Slimes: ${harmlessSlimes}`);\n\n            const threatRatio = (dangerousSlimes / total * 100).toFixed(1);\n            Chat.log(`  &e   Threat Ratio: ${threatRatio}%`);\n\n            if (threatRatio > 60) {\n                Chat.log(`  &4üî• HIGH THREAT AREA: Exercise extreme caution!`);\n            } else if (threatRatio > 30) {\n                Chat.log(`  &e‚ö†Ô∏è MODERATE RISK: Prepare for combat`);\n            }\n        }\n\n        // Geographical analysis\n        if (this.populationStats.spawnLocations.length > 0) {\n            this.analyzeSpawnPatterns();\n        }\n\n        // Historical data\n        this.displayHistoricalTrends();\n    }\n\n    analyzeSpawnPatterns() {\n        const locations = this.populationStats.spawnLocations;\n\n        // Calculate clustering\n        const clusters = this.identifySlimeClusters(locations);\n\n        Chat.log(`\\n&lSpawn Pattern Analysis:`);\n\n        if (clusters.length > 0) {\n            Chat.log(`  Detected ${clusters.length} slime cluster(s):`);\n            clusters.forEach((cluster, index) => {\n                const center = cluster.center;\n                const threatLevel = cluster.dangerous > cluster.safe ? \"Dangerous\" : \"Safe\";\n                const icon = cluster.dangerous > cluster.safe ? \"üî•\" : \"‚úÖ\";\n\n                Chat.log(`    ${icon} Cluster ${index + 1}: ${cluster.total} slimes`);\n                Chat.log(`       Center: [${center.x.toFixed(0)}, ${center.y.toFixed(0)}, ${center.z.toFixed(0)}]`);\n                Chat.log(`       Composition: ${cluster.dangerous} dangerous, ${cluster.safe} harmless`);\n                Chat.log(`       Assessment: ${threatLevel}`);\n            });\n        } else {\n            Chat.log(`  No significant clustering detected`);\n            Chat.log(`  Slimes are widely distributed`);\n        }\n\n        // Vertical distribution\n        const yLevels = locations.map(loc => loc.y);\n        const minY = Math.min(...yLevels);\n        const maxY = Math.max(...yLevels);\n        const avgY = yLevels.reduce((sum, y) => sum + y, 0) / yLevels.length;\n\n        Chat.log(`\\n&lVertical Distribution:`);\n        Chat.log(`  Height Range: Y ${minY.toFixed(0)} to ${maxY.toFixed(0)}`);\n        Chat.log(`  Average Level: Y ${avgY.toFixed(0)}`);\n\n        if (avgY < 40) {\n            Chat.log(`  &7Mostly underground spawns (typical for slime chunks)`);\n        } else if (avgY < 60) {\n            Chat.log(`  &eMixed surface/cave spawns`);\n        } else {\n            Chat.log(`  &bMostly surface spawns (swamp biome likely)`);\n        }\n    }\n\n    identifySlimeClusters(locations) {\n        const clusters = [];\n        const processed = new Set();\n        const clusterRadius = 16; // Blocks within same cluster\n\n        locations.forEach((location, index) => {\n            if (processed.has(index)) return;\n\n            const cluster = {\n                total: 0,\n                safe: 0,\n                dangerous: 0,\n                positions: [],\n                center: { x: 0, y: 0, z: 0 }\n            };\n\n            // BFS to find all slimes within cluster radius\n            const queue = [index];\n            while (queue.length > 0) {\n                const currentIndex = queue.shift();\n                if (processed.has(currentIndex)) continue;\n\n                processed.add(currentIndex);\n                const currentLoc = locations[currentIndex];\n\n                cluster.total++;\n                cluster.positions.push(currentLoc);\n\n                if (currentLoc.size === 1) {\n                    cluster.safe++;\n                } else {\n                    cluster.dangerous++;\n                }\n\n                // Find nearby slimes\n                locations.forEach((otherLoc, otherIndex) => {\n                    if (!processed.has(otherIndex)) {\n                        const distance = Math.sqrt(\n                            Math.pow(currentLoc.x - otherLoc.x, 2) +\n                            Math.pow(currentLoc.y - otherLoc.y, 2) +\n                            Math.pow(currentLoc.z - otherLoc.z, 2)\n                        );\n\n                        if (distance <= clusterRadius) {\n                            queue.push(otherIndex);\n                        }\n                    }\n                });\n            }\n\n            if (cluster.total > 1) {\n                // Calculate cluster center\n                const center = cluster.positions.reduce((acc, pos) => ({\n                    x: acc.x + pos.x / cluster.total,\n                    y: acc.y + pos.y / cluster.total,\n                    z: acc.z + pos.z / cluster.total\n                }), { x: 0, y: 0, z: 0 });\n\n                cluster.center = center;\n                clusters.push(cluster);\n            }\n        });\n\n        return clusters;\n    }\n\n    displayHistoricalTrends() {\n        const currentTime = Client.getTime();\n        let recentSpawnings = 0;\n        let oldSlimes = 0;\n\n        for (const [uuid, history] of this.slimeHistory) {\n            const age = currentTime - history.firstSeen;\n            if (age < 600) { // Last 30 seconds\n                recentSpawnings++;\n            }\n            if (age > 1200) { // Older than 1 minute\n                oldSlimes++;\n            }\n        }\n\n        Chat.log(`\\n&lPopulation Dynamics:`);\n        Chat.log(`  Recently spawned: ${recentSpawnings} (last 30s)`);\n        Chat.log(`  Long-lived slimes: ${oldSlimes} (> 1min)`);\n        Chat.log(`  Total tracked: ${this.slimeHistory.size}`);\n\n        if (recentSpawnings > 5) {\n            Chat.log(`  &eüîÑ Active spawning detected!`);\n        } else if (recentSpawnings > 2) {\n            Chat.log(`  &6Moderate spawning activity`);\n        } else {\n            Chat.log(`  &7Low spawning activity`);\n        }\n    }\n\n    cleanup() {\n        const currentTime = Client.getTime();\n        const cutoffTime = currentTime - 3600; // Remove slimes older than 3 minutes\n\n        for (const [uuid, history] of this.slimeHistory) {\n            if (history.lastSeen < cutoffTime) {\n                this.slimeHistory.delete(uuid);\n            }\n        }\n    }\n}\n\nconst slimeAnalyzer = new SlimePopulationAnalyzer();\n\n// Analyze slime population periodically\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    slimeAnalyzer.analyzePopulation();\n\n    // Cleanup every 30 seconds\n    if (Client.getTime() % 600 === 0) {\n        slimeAnalyzer.cleanup();\n    }\n}));\n\nChat.log(\"&aüìä Slime Population Analyzer activated!\");",
        "// Advanced combat strategy based on slime sizes and behaviors\nclass SlimeCombatSystem {\n    constructor() {\n        this.combatLog = [];\n        this.strategies = {\n            \"farming\": \"Focus on safely killing small slimes for resources\",\n            \"survival\": \"Prioritize eliminating large threats\",\n            \"efficient\": \"Kill slimes in size order for maximum efficiency\"\n        };\n        this.currentStrategy = \"survival\";\n        this.combatStats = {\n            slimesKilled: { 1: 0, 2: 0, 3: 0, 4: 0 },\n            damageTaken: 0,\n            damageDealt: 0,\n            combatTime: 0\n        };\n    }\n\n    analyzeCombatSituation() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities();\n        const combatRange = 32;\n        const slimes = entities.filter(entity =>\n            entity.is(\"minecraft:slime\") &&\n            player.distanceTo(entity) <= combatRange\n        );\n\n        if (slimes.length === 0) {\n            Chat.log(\"No slimes in combat range\");\n            return;\n        }\n\n        Chat.log(`&c‚öîÔ∏è=== COMBAT ANALYSIS (${slimes.length} slimes) ===`);\n\n        // Sort slimes by threat level\n        const prioritizedSlimes = this.prioritizeThreats(slimes);\n\n        let totalThreat = 0;\n        let immediateThreats = 0;\n        let optimalTargets = [];\n\n        prioritizedSlimes.forEach((slimeData, index) => {\n            const slime = slimeData.entity.as(\"minecraft:slime\");\n            const size = slime.getSize();\n            const distance = slimeData.distance;\n            const threat = this.calculateCombatThreat(slimeData.entity, size, distance);\n\n            totalThreat += threat;\n\n            if (distance <= size + 2) {\n                immediateThreats++;\n            }\n\n            const recommendation = this.getCombatRecommendation(slimeData.entity, size, distance);\n\n            Chat.log(`\\n${index + 1}. Size ${size} Slime:`);\n            Chat.log(`   Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`   Health: ${slimeData.entity.asLiving().getHealth().toFixed(1)}`);\n            Chat.log(`   Threat Level: ${threat.toFixed(0)}%`);\n            Chat.log(`   Status: ${immediateThreats > 0 && distance <= size + 2 ? \"&cATTACKING!\" : \"&ePositioning\"}`);\n            Chat.log(`   Recommendation: ${recommendation.action}`);\n\n            if (recommendation.priority === \"high\") {\n                optimalTargets.push(slimeData);\n            }\n        });\n\n        // Overall combat assessment\n        this.generateCombatStrategy(prioritizedSlimes, totalThreat, immediateThreats);\n\n        // Equipment check\n        this.checkCombatReadiness(optimalTargets);\n    }\n\n    prioritizeThreats(slimes) {\n        return slimes\n            .map(entity => {\n                const slime = entity.as(\"minecraft:slime\");\n                const size = slime.getSize();\n                const distance = Player.getPlayer().distanceTo(entity);\n                const threat = this.calculateCombatThreat(entity, size, distance);\n\n                return {\n                    entity: entity,\n                    size: size,\n                    distance: distance,\n                    threat: threat\n                };\n            })\n            .sort((a, b) => b.threat - a.threat);\n    }\n\n    calculateCombatThreat(slimeEntity, size, distance) {\n        let threat = 0;\n\n        // Size threat (bigger = more dangerous)\n        threat += size * 25;\n\n        // Distance threat (closer = more immediate)\n        const attackRange = size + 2;\n        if (distance <= attackRange) {\n            threat += 50; // Immediate threat\n        } else if (distance <= attackRange * 2) {\n            threat += 30; // Can attack soon\n        } else if (distance <= 20) {\n            threat += 15; // Within engagement range\n        }\n\n        // Health factor\n        const healthPercent = (slimeEntity.asLiving().getHealth() / slimeEntity.asLiving().getMaxHealth()) * 100;\n        threat += healthPercent * 0.1;\n\n        return Math.min(threat, 100);\n    }\n\n    getCombatRecommendation(slimeEntity, size, distance) {\n        const attackRange = size + 2;\n        const playerHealth = Player.getPlayer().asLiving().getHealth();\n        const maxHealth = Player.getPlayer().asLiving().getMaxHealth();\n        const healthPercent = (playerHealth / maxHealth) * 100;\n\n        if (size === 1) {\n            return {\n                action: \"Safe to kill for slimeballs\",\n                priority: \"low\",\n                urgency: \"none\"\n            };\n        }\n\n        if (distance <= attackRange) {\n            return {\n                action: \"IMMEDIATE PRIORITY - Attacking now!\",\n                priority: \"high\",\n                urgency: \"critical\"\n            };\n        }\n\n        if (distance <= attackRange * 2 && healthPercent < 50) {\n            return {\n                action: \"Create distance before engaging\",\n                priority: \"high\",\n                urgency: \"high\"\n            };\n        }\n\n        if (size >= 3 && distance <= 16) {\n            return {\n                action: \"Eliminate first - major threat\",\n                priority: \"high\",\n                urgency: \"medium\"\n            };\n        }\n\n        if (size === 2 && distance <= 12) {\n            return {\n                action: \"Engage with caution\",\n                priority: \"medium\",\n                urgency: \"medium\"\n            };\n        }\n\n        return {\n            action: \"Monitor and approach strategically\",\n            priority: \"low\",\n            urgency: \"low\"\n        };\n    }\n\n    generateCombatStrategy(prioritizedSlimes, totalThreat, immediateThreats) {\n        Chat.log(`\\n&6=== COMBAT STRATEGY ===`);\n\n        const player = Player.getPlayer();\n        const healthPercent = (player.asLiving().getHealth() / player.asLiving().getMaxHealth()) * 100;\n\n        // Overall threat assessment\n        if (totalThreat > 200) {\n            Chat.log(`&cüî• CRITICAL SITUATION: Multiple large threats!`);\n            Chat.log(`   ‚Üí Consider tactical retreat`);\n            Chat.log(`   ‚Üí Use terrain for advantage`);\n            Chat.log(`   ‚Üí Focus on escape routes`);\n        } else if (totalThreat > 100) {\n            Chat.log(`&e‚ö†Ô∏è DANGEROUS: Significant threat level`);\n            Chat.log(`   ‚Üí Prioritize large slimes first`);\n            Chat.log(`   ‚Üí Maintain mobility`);\n            Chat.log(`   ‚Üí Use hit-and-run tactics`);\n        } else if (totalThreat > 50) {\n            Chat.log(`&6‚öîÔ∏è MODERATE: Manageable threat level`);\n            Chat.log(`   ‚Üí Systematic elimination recommended`);\n            Chat.log(`   ‚Üí Watch for splitting behavior`);\n        } else {\n            Chat.log(`&a‚úÖ LOW RISK: Minor threats only`);\n            Chat.log(`   ‚Üí Can farm safely`);\n            Chat.log(`   ‚Üí Focus on resource collection`);\n        }\n\n        // Health-based strategy adjustment\n        if (healthPercent < 30) {\n            Chat.log(`\\n&c‚ùå HEALTH CRITICAL: ${healthPercent.toFixed(0)}%`);\n            Chat.log(`   ‚Üí IMMEDIATE RETREAT RECOMMENDED`);\n            Chat.log(`   ‚Üí Use healing items before engaging`);\n        } else if (healthPercent < 60) {\n            Chat.log(`\\n&e‚ö†Ô∏è HEALTH LOW: ${healthPercent.toFixed(0)}%`);\n            Chat.log(`   ‚Üí Engage cautiously`);\n            Chat.log(`   ‚Üí Have escape route ready`);\n        }\n\n        // Immediate action plan\n        if (immediateThreats > 0) {\n            Chat.log(`\\n&cüö® IMMEDIATE ACTIONS REQUIRED:`);\n            Chat.log(`   ‚Üí ${immediateThreats} slime(s) currently attacking!`);\n\n            // Find the most dangerous immediate threat\n            const immediateThreatsList = prioritizedSlimes.filter(s => s.distance <= s.size + 2);\n            if (immediateThreatsList.length > 0) {\n                const worstThreat = immediateThreatsList[0];\n                Chat.log(`   ‚Üí Target: Size ${worstThreat.size} slime (${worstThreat.threat.toFixed(0)}% threat)`);\n\n                if (worstThreat.size >= 3) {\n                    Chat.log(`   ‚Üí Use knockback weapons or terrain`);\n                } else {\n                    Chat.log(`   ‚Üí Quick engagement recommended`);\n                }\n            }\n        }\n\n        // Strategic recommendations\n        Chat.log(`\\nüí° STRATEGIC TIPS:`);\n\n        const largeSlimes = prioritizedSlimes.filter(s => s.size >= 3).length;\n        const mediumSlimes = prioritizedSlimes.filter(s => s.size === 2).length;\n\n        if (largeSlimes > 0) {\n            Chat.log(`   ‚Ä¢ Kill large slimes first to reduce spawn rate`);\n            Chat.log(`   ‚Ä¢ Be prepared for 2-4 smaller slimes per large slime`);\n        }\n\n        if (mediumSlimes > 2) {\n            Chat.log(`   ‚Ä¢ Multiple medium slimes can overwhelm quickly`);\n            Chat.log(`   ‚Ä¢ Consider area damage or crowd control`);\n        }\n\n        Chat.log(`   ‚Ä¢ Small slimes are harmless - farm for resources`);\n        Chat.log(`   ‚Ä¢ Use vertical terrain to your advantage`);\n    }\n\n    checkCombatReadiness(optimalTargets) {\n        const player = Player.getPlayer();\n\n        Chat.log(`\\nüõ°Ô∏è COMBAT READINESS CHECK:`);\n\n        // Weapon check\n        const mainHand = player.getMainHand();\n        let weaponScore = 0;\n\n        if (mainHand) {\n            const weaponType = mainHand.getType();\n            if (weaponType.includes(\"sword\")) {\n                weaponScore = 8;\n                Chat.log(`   &a‚úì Sword equipped: ${mainHand.getName().getString()}`);\n            } else if (weaponType.includes(\"axe\")) {\n                weaponScore = 6;\n                Chat.log(`   &e‚ö†Ô∏è Axe equipped: ${mainHand.getName().getString()} (less optimal)`);\n            } else {\n                Chat.log(`   &c‚ùå No weapon equipped: ${mainHand.getName().getString()}`);\n            }\n        }\n\n        else {\n            Chat.log(`   &c‚ùå No item in main hand`);\n        }\n\n        // Health check\n        const health = player.asLiving().getHealth();\n        const maxHealth = player.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n\n        if (healthPercent >= 80) {\n            Chat.log(`   &a‚úì Excellent health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        } else if (healthPercent >= 50) {\n            Chat.log(`   &e‚ö†Ô∏è Moderate health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        } else {\n            Chat.log(`   &c‚ùå Low health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        }\n\n        // Armor check\n        const armorValue = player.asLiving().getArmor();\n        if (armorValue >= 15) {\n            Chat.log(`   &a‚úì Good armor protection: ${armorValue}`);\n        } else if (armorValue >= 8) {\n            Chat.log(`   &e‚ö†Ô∏è Moderate armor: ${armorValue}`);\n        } else {\n            Chat.log(`   &c‚ùå Insufficient armor: ${armorValue}`);\n        }\n\n        // Overall readiness score\n        const readinessScore = weaponScore + (healthPercent / 10) + (armorValue / 4);\n\n        Chat.log(`\\nüìä COMBAT READINESS: ${readinessScore.toFixed(0)}%`);\n\n        if (readinessScore >= 80) {\n            Chat.log(`   &a‚úÖ READY FOR COMBAT`);\n        } else if (readinessScore >= 60) {\n            Chat.log(`   &e‚ö†Ô∏è CAUTION ADVISED`);\n        } else {\n            Chat.log(`   &c‚ùå NOT READY - PREPARE FIRST`);\n        }\n\n        // Target-specific recommendations\n        if (optimalTargets.length > 0) {\n            Chat.log(`\\nüéØ OPTIMAL TARGETS: ${optimalTargets.length}`);\n            optimalTargets.forEach((target, index) => {\n                const slime = target.entity.as(\"minecraft:slime\");\n                const size = slime.getSize();\n                const distance = target.distance;\n\n                Chat.log(`   ${index + 1}. Size ${size} slime at ${distance.toFixed(1)}m`);\n\n                if (size >= 3) {\n                    Chat.log(`      ‚Üí High priority - major threat`);\n                } else if (size === 2) {\n                    Chat.log(`      ‚Üí Medium priority - moderate threat`);\n                }\n            });\n        }\n    }\n}\n\nconst slimeCombatSystem = new SlimeCombatSystem();\n\n// Combat analysis command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.c\" && e.action === 1) { // C key\n        slimeCombatSystem.analyzeCombatSituation();\n    }\n}));\n\nChat.log(\"&c‚öîÔ∏è Slime Combat System activated!\");\nChat.log(\"&ePress C to analyze combat situation\");"
      ]
    },
    {
      "name": "isSmall",
      "signature": "boolean isSmall()",
      "returnType": "boolean",
      "description": "Checks if the slime is a small (size 1) slime, which is harmless and does not split further when defeated. Small slimes pose no combat threat.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive slime population analysis and tracking\nclass SlimePopulationAnalyzer {\n    constructor() {\n        this.slimeHistory = new Map();\n        this.populationStats = {\n            total: 0,\n            bySize: { 1: 0, 2: 0, 3: 0, 4: 0 },\n            spawnLocations: [],\n            lastAnalysis: 0\n        };\n        this.analysisInterval = 100; // Analyze every 5 seconds\n    }\n\n    analyzePopulation() {\n        const currentTime = Client.getTime();\n        if (currentTime - this.populationStats.lastAnalysis < this.analysisInterval) {\n            return; // Skip if analyzed recently\n        }\n\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities();\n        const analysisRange = 64;\n        const slimes = entities.filter(entity =>\n            entity.is(\"minecraft:slime\") &&\n            player.distanceTo(entity) <= analysisRange\n        );\n\n        // Reset current stats\n        this.populationStats.total = slimes.length;\n        this.populationStats.bySize = { 1: 0, 2: 0, 3: 0, 4: 0 };\n        this.populationStats.spawnLocations = [];\n\n        // Analyze each slime\n        slimes.forEach(slimeEntity => {\n            const slime = slimeEntity.as(\"minecraft:slime\");\n            if (!slime) return;\n\n            const size = slime.getSize();\n            const pos = slimeEntity.getPos();\n            const health = slimeEntity.asLiving().getHealth();\n            const distance = player.distanceTo(slimeEntity);\n            const isSmall = slime.isSmall();\n\n            this.populationStats.bySize[size]++;\n            this.populationStats.spawnLocations.push({\n                x: pos.x,\n                y: pos.y,\n                z: pos.z,\n                size: size,\n                distance: distance\n            });\n\n            // Track slime history\n            const uuid = slimeEntity.getUUID();\n            if (!this.slimeHistory.has(uuid)) {\n                this.slimeHistory.set(uuid, {\n                    firstSeen: currentTime,\n                    lastSeen: currentTime,\n                    initialSize: size,\n                    sizeChanges: [],\n                    currentHealth: health\n                });\n            } else {\n                const history = this.slimeHistory.get(uuid);\n                history.lastSeen = currentTime;\n                history.currentHealth = health;\n\n                // Track size changes (could indicate splitting or growth)\n                if (history.currentSize !== size) {\n                    history.sizeChanges.push({\n                        from: history.currentSize,\n                        to: size,\n                        time: currentTime\n                    });\n                    history.currentSize = size;\n                }\n            }\n        });\n\n        this.populationStats.lastAnalysis = currentTime;\n        this.displayPopulationAnalysis();\n    }\n\n    displayPopulationAnalysis() {\n        Chat.log(`&6=== Slime Population Analysis ===`);\n        Chat.log(`Total slimes in range: ${this.populationStats.total}`);\n\n        // Size distribution\n        Chat.log(\"\\n&lSize Distribution:\");\n        const total = this.populationStats.total;\n        for (const [size, count] of Object.entries(this.populationStats.bySize)) {\n            const percentage = total > 0 ? (count / total * 100).toFixed(1) : \"0.0\";\n            const emoji = size === \"1\" ? \"‚úÖ\" : size === \"2\" ? \"‚ö†Ô∏è\" : \"üî•\";\n            const threat = size === \"1\" ? \"Harmless\" : size === \"2\" ? \"Moderate\" : size === \"3\" ? \"Dangerous\" : \"Very Dangerous\";\n            Chat.log(`  ${emoji} Size ${size}: ${count} (${percentage}%) - ${threat}`);\n        }\n\n        // Threat assessment\n        const dangerousSlimes = this.populationStats.bySize[2] + this.populationStats.bySize[3] + this.populationStats.bySize[4];\n        const harmlessSlimes = this.populationStats.bySize[1];\n\n        Chat.log(`\\n&lThreat Assessment:`);\n        if (dangerousSlimes === 0) {\n            Chat.log(`  &a‚úÖ Safe Environment: All slimes are harmless!`);\n            Chat.log(`  &a   Perfect for slimeball farming`);\n        } else {\n            Chat.log(`  &c‚ö†Ô∏è Dangerous Slimes: ${dangerousSlimes}`);\n            Chat.log(`  &a   Harmless Slimes: ${harmlessSlimes}`);\n\n            const threatRatio = (dangerousSlimes / total * 100).toFixed(1);\n            Chat.log(`  &e   Threat Ratio: ${threatRatio}%`);\n\n            if (threatRatio > 60) {\n                Chat.log(`  &4üî• HIGH THREAT AREA: Exercise extreme caution!`);\n            } else if (threatRatio > 30) {\n                Chat.log(`  &e‚ö†Ô∏è MODERATE RISK: Prepare for combat`);\n            }\n        }\n\n        // Geographical analysis\n        if (this.populationStats.spawnLocations.length > 0) {\n            this.analyzeSpawnPatterns();\n        }\n\n        // Historical data\n        this.displayHistoricalTrends();\n    }\n\n    analyzeSpawnPatterns() {\n        const locations = this.populationStats.spawnLocations;\n\n        // Calculate clustering\n        const clusters = this.identifySlimeClusters(locations);\n\n        Chat.log(`\\n&lSpawn Pattern Analysis:`);\n\n        if (clusters.length > 0) {\n            Chat.log(`  Detected ${clusters.length} slime cluster(s):`);\n            clusters.forEach((cluster, index) => {\n                const center = cluster.center;\n                const threatLevel = cluster.dangerous > cluster.safe ? \"Dangerous\" : \"Safe\";\n                const icon = cluster.dangerous > cluster.safe ? \"üî•\" : \"‚úÖ\";\n\n                Chat.log(`    ${icon} Cluster ${index + 1}: ${cluster.total} slimes`);\n                Chat.log(`       Center: [${center.x.toFixed(0)}, ${center.y.toFixed(0)}, ${center.z.toFixed(0)}]`);\n                Chat.log(`       Composition: ${cluster.dangerous} dangerous, ${cluster.safe} harmless`);\n                Chat.log(`       Assessment: ${threatLevel}`);\n            });\n        } else {\n            Chat.log(`  No significant clustering detected`);\n            Chat.log(`  Slimes are widely distributed`);\n        }\n\n        // Vertical distribution\n        const yLevels = locations.map(loc => loc.y);\n        const minY = Math.min(...yLevels);\n        const maxY = Math.max(...yLevels);\n        const avgY = yLevels.reduce((sum, y) => sum + y, 0) / yLevels.length;\n\n        Chat.log(`\\n&lVertical Distribution:`);\n        Chat.log(`  Height Range: Y ${minY.toFixed(0)} to ${maxY.toFixed(0)}`);\n        Chat.log(`  Average Level: Y ${avgY.toFixed(0)}`);\n\n        if (avgY < 40) {\n            Chat.log(`  &7Mostly underground spawns (typical for slime chunks)`);\n        } else if (avgY < 60) {\n            Chat.log(`  &eMixed surface/cave spawns`);\n        } else {\n            Chat.log(`  &bMostly surface spawns (swamp biome likely)`);\n        }\n    }\n\n    identifySlimeClusters(locations) {\n        const clusters = [];\n        const processed = new Set();\n        const clusterRadius = 16; // Blocks within same cluster\n\n        locations.forEach((location, index) => {\n            if (processed.has(index)) return;\n\n            const cluster = {\n                total: 0,\n                safe: 0,\n                dangerous: 0,\n                positions: [],\n                center: { x: 0, y: 0, z: 0 }\n            };\n\n            // BFS to find all slimes within cluster radius\n            const queue = [index];\n            while (queue.length > 0) {\n                const currentIndex = queue.shift();\n                if (processed.has(currentIndex)) continue;\n\n                processed.add(currentIndex);\n                const currentLoc = locations[currentIndex];\n\n                cluster.total++;\n                cluster.positions.push(currentLoc);\n\n                if (currentLoc.size === 1) {\n                    cluster.safe++;\n                } else {\n                    cluster.dangerous++;\n                }\n\n                // Find nearby slimes\n                locations.forEach((otherLoc, otherIndex) => {\n                    if (!processed.has(otherIndex)) {\n                        const distance = Math.sqrt(\n                            Math.pow(currentLoc.x - otherLoc.x, 2) +\n                            Math.pow(currentLoc.y - otherLoc.y, 2) +\n                            Math.pow(currentLoc.z - otherLoc.z, 2)\n                        );\n\n                        if (distance <= clusterRadius) {\n                            queue.push(otherIndex);\n                        }\n                    }\n                });\n            }\n\n            if (cluster.total > 1) {\n                // Calculate cluster center\n                const center = cluster.positions.reduce((acc, pos) => ({\n                    x: acc.x + pos.x / cluster.total,\n                    y: acc.y + pos.y / cluster.total,\n                    z: acc.z + pos.z / cluster.total\n                }), { x: 0, y: 0, z: 0 });\n\n                cluster.center = center;\n                clusters.push(cluster);\n            }\n        });\n\n        return clusters;\n    }\n\n    displayHistoricalTrends() {\n        const currentTime = Client.getTime();\n        let recentSpawnings = 0;\n        let oldSlimes = 0;\n\n        for (const [uuid, history] of this.slimeHistory) {\n            const age = currentTime - history.firstSeen;\n            if (age < 600) { // Last 30 seconds\n                recentSpawnings++;\n            }\n            if (age > 1200) { // Older than 1 minute\n                oldSlimes++;\n            }\n        }\n\n        Chat.log(`\\n&lPopulation Dynamics:`);\n        Chat.log(`  Recently spawned: ${recentSpawnings} (last 30s)`);\n        Chat.log(`  Long-lived slimes: ${oldSlimes} (> 1min)`);\n        Chat.log(`  Total tracked: ${this.slimeHistory.size}`);\n\n        if (recentSpawnings > 5) {\n            Chat.log(`  &eüîÑ Active spawning detected!`);\n        } else if (recentSpawnings > 2) {\n            Chat.log(`  &6Moderate spawning activity`);\n        } else {\n            Chat.log(`  &7Low spawning activity`);\n        }\n    }\n\n    cleanup() {\n        const currentTime = Client.getTime();\n        const cutoffTime = currentTime - 3600; // Remove slimes older than 3 minutes\n\n        for (const [uuid, history] of this.slimeHistory) {\n            if (history.lastSeen < cutoffTime) {\n                this.slimeHistory.delete(uuid);\n            }\n        }\n    }\n}\n\nconst slimeAnalyzer = new SlimePopulationAnalyzer();\n\n// Analyze slime population periodically\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    slimeAnalyzer.analyzePopulation();\n\n    // Cleanup every 30 seconds\n    if (Client.getTime() % 600 === 0) {\n        slimeAnalyzer.cleanup();\n    }\n}));\n\nChat.log(\"&aüìä Slime Population Analyzer activated!\");",
        "// Advanced combat strategy based on slime sizes and behaviors\nclass SlimeCombatSystem {\n    constructor() {\n        this.combatLog = [];\n        this.strategies = {\n            \"farming\": \"Focus on safely killing small slimes for resources\",\n            \"survival\": \"Prioritize eliminating large threats\",\n            \"efficient\": \"Kill slimes in size order for maximum efficiency\"\n        };\n        this.currentStrategy = \"survival\";\n        this.combatStats = {\n            slimesKilled: { 1: 0, 2: 0, 3: 0, 4: 0 },\n            damageTaken: 0,\n            damageDealt: 0,\n            combatTime: 0\n        };\n    }\n\n    analyzeCombatSituation() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities();\n        const combatRange = 32;\n        const slimes = entities.filter(entity =>\n            entity.is(\"minecraft:slime\") &&\n            player.distanceTo(entity) <= combatRange\n        );\n\n        if (slimes.length === 0) {\n            Chat.log(\"No slimes in combat range\");\n            return;\n        }\n\n        Chat.log(`&c‚öîÔ∏è=== COMBAT ANALYSIS (${slimes.length} slimes) ===`);\n\n        // Sort slimes by threat level\n        const prioritizedSlimes = this.prioritizeThreats(slimes);\n\n        let totalThreat = 0;\n        let immediateThreats = 0;\n        let optimalTargets = [];\n\n        prioritizedSlimes.forEach((slimeData, index) => {\n            const slime = slimeData.entity.as(\"minecraft:slime\");\n            const size = slime.getSize();\n            const distance = slimeData.distance;\n            const threat = this.calculateCombatThreat(slimeData.entity, size, distance);\n\n            totalThreat += threat;\n\n            if (distance <= size + 2) {\n                immediateThreats++;\n            }\n\n            const recommendation = this.getCombatRecommendation(slimeData.entity, size, distance);\n\n            Chat.log(`\\n${index + 1}. Size ${size} Slime:`);\n            Chat.log(`   Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`   Health: ${slimeData.entity.asLiving().getHealth().toFixed(1)}`);\n            Chat.log(`   Threat Level: ${threat.toFixed(0)}%`);\n            Chat.log(`   Status: ${immediateThreats > 0 && distance <= size + 2 ? \"&cATTACKING!\" : \"&ePositioning\"}`);\n            Chat.log(`   Recommendation: ${recommendation.action}`);\n\n            if (recommendation.priority === \"high\") {\n                optimalTargets.push(slimeData);\n            }\n        });\n\n        // Overall combat assessment\n        this.generateCombatStrategy(prioritizedSlimes, totalThreat, immediateThreats);\n\n        // Equipment check\n        this.checkCombatReadiness(optimalTargets);\n    }\n\n    prioritizeThreats(slimes) {\n        return slimes\n            .map(entity => {\n                const slime = entity.as(\"minecraft:slime\");\n                const size = slime.getSize();\n                const distance = Player.getPlayer().distanceTo(entity);\n                const threat = this.calculateCombatThreat(entity, size, distance);\n\n                return {\n                    entity: entity,\n                    size: size,\n                    distance: distance,\n                    threat: threat\n                };\n            })\n            .sort((a, b) => b.threat - a.threat);\n    }\n\n    calculateCombatThreat(slimeEntity, size, distance) {\n        let threat = 0;\n\n        // Size threat (bigger = more dangerous)\n        threat += size * 25;\n\n        // Distance threat (closer = more immediate)\n        const attackRange = size + 2;\n        if (distance <= attackRange) {\n            threat += 50; // Immediate threat\n        } else if (distance <= attackRange * 2) {\n            threat += 30; // Can attack soon\n        } else if (distance <= 20) {\n            threat += 15; // Within engagement range\n        }\n\n        // Health factor\n        const healthPercent = (slimeEntity.asLiving().getHealth() / slimeEntity.asLiving().getMaxHealth()) * 100;\n        threat += healthPercent * 0.1;\n\n        return Math.min(threat, 100);\n    }\n\n    getCombatRecommendation(slimeEntity, size, distance) {\n        const attackRange = size + 2;\n        const playerHealth = Player.getPlayer().asLiving().getHealth();\n        const maxHealth = Player.getPlayer().asLiving().getMaxHealth();\n        const healthPercent = (playerHealth / maxHealth) * 100;\n\n        if (size === 1) {\n            return {\n                action: \"Safe to kill for slimeballs\",\n                priority: \"low\",\n                urgency: \"none\"\n            };\n        }\n\n        if (distance <= attackRange) {\n            return {\n                action: \"IMMEDIATE PRIORITY - Attacking now!\",\n                priority: \"high\",\n                urgency: \"critical\"\n            };\n        }\n\n        if (distance <= attackRange * 2 && healthPercent < 50) {\n            return {\n                action: \"Create distance before engaging\",\n                priority: \"high\",\n                urgency: \"high\"\n            };\n        }\n\n        if (size >= 3 && distance <= 16) {\n            return {\n                action: \"Eliminate first - major threat\",\n                priority: \"high\",\n                urgency: \"medium\"\n            };\n        }\n\n        if (size === 2 && distance <= 12) {\n            return {\n                action: \"Engage with caution\",\n                priority: \"medium\",\n                urgency: \"medium\"\n            };\n        }\n\n        return {\n            action: \"Monitor and approach strategically\",\n            priority: \"low\",\n            urgency: \"low\"\n        };\n    }\n\n    generateCombatStrategy(prioritizedSlimes, totalThreat, immediateThreats) {\n        Chat.log(`\\n&6=== COMBAT STRATEGY ===`);\n\n        const player = Player.getPlayer();\n        const healthPercent = (player.asLiving().getHealth() / player.asLiving().getMaxHealth()) * 100;\n\n        // Overall threat assessment\n        if (totalThreat > 200) {\n            Chat.log(`&cüî• CRITICAL SITUATION: Multiple large threats!`);\n            Chat.log(`   ‚Üí Consider tactical retreat`);\n            Chat.log(`   ‚Üí Use terrain for advantage`);\n            Chat.log(`   ‚Üí Focus on escape routes`);\n        } else if (totalThreat > 100) {\n            Chat.log(`&e‚ö†Ô∏è DANGEROUS: Significant threat level`);\n            Chat.log(`   ‚Üí Prioritize large slimes first`);\n            Chat.log(`   ‚Üí Maintain mobility`);\n            Chat.log(`   ‚Üí Use hit-and-run tactics`);\n        } else if (totalThreat > 50) {\n            Chat.log(`&6‚öîÔ∏è MODERATE: Manageable threat level`);\n            Chat.log(`   ‚Üí Systematic elimination recommended`);\n            Chat.log(`   ‚Üí Watch for splitting behavior`);\n        } else {\n            Chat.log(`&a‚úÖ LOW RISK: Minor threats only`);\n            Chat.log(`   ‚Üí Can farm safely`);\n            Chat.log(`   ‚Üí Focus on resource collection`);\n        }\n\n        // Health-based strategy adjustment\n        if (healthPercent < 30) {\n            Chat.log(`\\n&c‚ùå HEALTH CRITICAL: ${healthPercent.toFixed(0)}%`);\n            Chat.log(`   ‚Üí IMMEDIATE RETREAT RECOMMENDED`);\n            Chat.log(`   ‚Üí Use healing items before engaging`);\n        } else if (healthPercent < 60) {\n            Chat.log(`\\n&e‚ö†Ô∏è HEALTH LOW: ${healthPercent.toFixed(0)}%`);\n            Chat.log(`   ‚Üí Engage cautiously`);\n            Chat.log(`   ‚Üí Have escape route ready`);\n        }\n\n        // Immediate action plan\n        if (immediateThreats > 0) {\n            Chat.log(`\\n&cüö® IMMEDIATE ACTIONS REQUIRED:`);\n            Chat.log(`   ‚Üí ${immediateThreats} slime(s) currently attacking!`);\n\n            // Find the most dangerous immediate threat\n            const immediateThreatsList = prioritizedSlimes.filter(s => s.distance <= s.size + 2);\n            if (immediateThreatsList.length > 0) {\n                const worstThreat = immediateThreatsList[0];\n                Chat.log(`   ‚Üí Target: Size ${worstThreat.size} slime (${worstThreat.threat.toFixed(0)}% threat)`);\n\n                if (worstThreat.size >= 3) {\n                    Chat.log(`   ‚Üí Use knockback weapons or terrain`);\n                } else {\n                    Chat.log(`   ‚Üí Quick engagement recommended`);\n                }\n            }\n        }\n\n        // Strategic recommendations\n        Chat.log(`\\nüí° STRATEGIC TIPS:`);\n\n        const largeSlimes = prioritizedSlimes.filter(s => s.size >= 3).length;\n        const mediumSlimes = prioritizedSlimes.filter(s => s.size === 2).length;\n\n        if (largeSlimes > 0) {\n            Chat.log(`   ‚Ä¢ Kill large slimes first to reduce spawn rate`);\n            Chat.log(`   ‚Ä¢ Be prepared for 2-4 smaller slimes per large slime`);\n        }\n\n        if (mediumSlimes > 2) {\n            Chat.log(`   ‚Ä¢ Multiple medium slimes can overwhelm quickly`);\n            Chat.log(`   ‚Ä¢ Consider area damage or crowd control`);\n        }\n\n        Chat.log(`   ‚Ä¢ Small slimes are harmless - farm for resources`);\n        Chat.log(`   ‚Ä¢ Use vertical terrain to your advantage`);\n    }\n\n    checkCombatReadiness(optimalTargets) {\n        const player = Player.getPlayer();\n\n        Chat.log(`\\nüõ°Ô∏è COMBAT READINESS CHECK:`);\n\n        // Weapon check\n        const mainHand = player.getMainHand();\n        let weaponScore = 0;\n\n        if (mainHand) {\n            const weaponType = mainHand.getType();\n            if (weaponType.includes(\"sword\")) {\n                weaponScore = 8;\n                Chat.log(`   &a‚úì Sword equipped: ${mainHand.getName().getString()}`);\n            } else if (weaponType.includes(\"axe\")) {\n                weaponScore = 6;\n                Chat.log(`   &e‚ö†Ô∏è Axe equipped: ${mainHand.getName().getString()} (less optimal)`);\n            } else {\n                Chat.log(`   &c‚ùå No weapon equipped: ${mainHand.getName().getString()}`);\n            }\n        }\n\n        else {\n            Chat.log(`   &c‚ùå No item in main hand`);\n        }\n\n        // Health check\n        const health = player.asLiving().getHealth();\n        const maxHealth = player.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n\n        if (healthPercent >= 80) {\n            Chat.log(`   &a‚úì Excellent health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        } else if (healthPercent >= 50) {\n            Chat.log(`   &e‚ö†Ô∏è Moderate health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        } else {\n            Chat.log(`   &c‚ùå Low health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        }\n\n        // Armor check\n        const armorValue = player.asLiving().getArmor();\n        if (armorValue >= 15) {\n            Chat.log(`   &a‚úì Good armor protection: ${armorValue}`);\n        } else if (armorValue >= 8) {\n            Chat.log(`   &e‚ö†Ô∏è Moderate armor: ${armorValue}`);\n        } else {\n            Chat.log(`   &c‚ùå Insufficient armor: ${armorValue}`);\n        }\n\n        // Overall readiness score\n        const readinessScore = weaponScore + (healthPercent / 10) + (armorValue / 4);\n\n        Chat.log(`\\nüìä COMBAT READINESS: ${readinessScore.toFixed(0)}%`);\n\n        if (readinessScore >= 80) {\n            Chat.log(`   &a‚úÖ READY FOR COMBAT`);\n        } else if (readinessScore >= 60) {\n            Chat.log(`   &e‚ö†Ô∏è CAUTION ADVISED`);\n        } else {\n            Chat.log(`   &c‚ùå NOT READY - PREPARE FIRST`);\n        }\n\n        // Target-specific recommendations\n        if (optimalTargets.length > 0) {\n            Chat.log(`\\nüéØ OPTIMAL TARGETS: ${optimalTargets.length}`);\n            optimalTargets.forEach((target, index) => {\n                const slime = target.entity.as(\"minecraft:slime\");\n                const size = slime.getSize();\n                const distance = target.distance;\n\n                Chat.log(`   ${index + 1}. Size ${size} slime at ${distance.toFixed(1)}m`);\n\n                if (size >= 3) {\n                    Chat.log(`      ‚Üí High priority - major threat`);\n                } else if (size === 2) {\n                    Chat.log(`      ‚Üí Medium priority - moderate threat`);\n                }\n            });\n        }\n    }\n}\n\nconst slimeCombatSystem = new SlimeCombatSystem();\n\n// Combat analysis command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.c\" && e.action === 1) { // C key\n        slimeCombatSystem.analyzeCombatSituation();\n    }\n}));\n\nChat.log(\"&c‚öîÔ∏è Slime Combat System activated!\");\nChat.log(\"&ePress C to analyze combat situation\");"
      ]
    }
  ]
}