{
  "name": "SpiderEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.SpiderEntityHelper",
  "extends": "MobEntityHelper<SpiderEntity>",
  "since": "JSMacros 1.8.4",
  "description": "The `SpiderEntityHelper` class provides specialized access to spider entities in Minecraft, offering methods to monitor and interact with spider-specific behaviors such as climbing states and movement patterns. This class extends `MobEntityHelper` and inherits all functionality for living entities including health monitoring, status effects, AI states, and combat behaviors.",
  "overview": "This helper is particularly useful for creating scripts that detect spider climbing behaviors, analyze spider movement patterns, or implement spider-specific monitoring systems for enhanced gameplay awareness.",
  "constructors": [
    {
      "signature": "N/A (Indirectly Instantiated)",
      "description": "SpiderEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through: Entity-related events (e.g., EntitySpawn, EntityDeath, EntityInteract), World entity queries using type filtering, Casting from generic EntityHelper instances using type checking.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isClimbing",
      "signature": "isClimbing()",
      "returnType": "boolean",
      "description": "Checks if the spider entity is currently climbing a solid block. This method detects when spiders are actively climbing walls, ceilings, and obstacles that would normally block other mobs.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive spider behavior monitoring system\nclass SpiderMonitor {\n    constructor() {\n        this.trackedSpiders = new Map();\n        this.climbingEvents = [];\n        this.stats = {\n            totalSeen: 0,\n            climbingCount: 0,\n            averageClimbingTime: 0,\n            climbingSessions: []\n        };\n    }\n\n    analyzeSpider(spider) {\n        const uuid = spider.getUUID();\n        const pos = spider.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(spider);\n        const isClimbing = spider.isClimbing();\n        const isAttacking = spider.isAttacking();\n        const health = spider.getHealth();\n        const maxHealth = spider.getMaxHealth();\n\n        // Get previous state if tracked\n        const previousState = this.trackedSpiders.get(uuid) || {\n            wasClimbing: false,\n            climbingStartTime: null,\n            totalClimbingTime: 0,\n            lastPosition: pos\n        };\n\n        // Detect climbing state changes\n        if (isClimbing && !previousState.wasClimbing) {\n            // Spider started climbing\n            previousState.climbingStartTime = Client.getTime();\n            this.stats.climbingCount++;\n\n            Chat.log(`&eSpider started climbing at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n\n            this.climbingEvents.push({\n                spider: spider,\n                startTime: Client.getTime(),\n                startDistance: distance,\n                health: health\n            });\n\n        } else if (!isClimbing && previousState.wasClimbing && previousState.climbingStartTime) {\n            // Spider stopped climbing\n            const climbingDuration = Client.getTime() - previousState.climbingStartTime;\n            previousState.totalClimbingTime += climbingDuration;\n            previousState.climbingStartTime = null;\n\n            this.stats.climbingSessions.push(climbingDuration);\n            this.updateAverageClimbingTime();\n\n            Chat.log(`&7Spider stopped climbing after ${(climbingDuration/20).toFixed(1)}s`);\n        }\n\n        // Calculate movement speed\n        const movementSpeed = pos.distanceTo(previousState.lastPosition);\n\n        // Update tracking data\n        const currentState = {\n            spider: spider,\n            isClimbing: isClimbing,\n            isAttacking: isAttacking,\n            distance: distance,\n            health: health,\n            healthPercentage: (health / maxHealth) * 100,\n            movementSpeed: movementSpeed,\n            wasClimbing: isClimbing,\n            climbingStartTime: previousState.climbingStartTime,\n            totalClimbingTime: previousState.totalClimbingTime,\n            lastPosition: pos,\n            lastUpdate: Client.getTime()\n        };\n\n        this.trackedSpiders.set(uuid, currentState);\n        this.stats.totalSeen = Math.max(this.stats.totalSeen, this.trackedSpiders.size);\n\n        return currentState;\n    }\n\n    updateAverageClimbingTime() {\n        if (this.stats.climbingSessions.length > 0) {\n            const sum = this.stats.climbingSessions.reduce((a, b) => a + b, 0);\n            this.stats.averageClimbingTime = sum / this.stats.climbingSessions.length;\n        }\n    }\n\n    generateThreatAssessment(spiderData) {\n        let threatLevel = \"low\";\n        let threatScore = 0;\n\n        // Distance-based threat\n        if (spiderData.distance <= 4) {\n            threatScore += 50;\n            threatLevel = \"critical\";\n        } else if (spiderData.distance <= 8) {\n            threatScore += 30;\n            threatLevel = \"high\";\n        } else if (spiderData.distance <= 12) {\n            threatScore += 15;\n            threatLevel = \"medium\";\n        }\n\n        // Climbing-based threat bonus\n        if (spiderData.isClimbing) {\n            threatScore += 25;\n            if (spiderData.distance <= 8) {\n                threatLevel = \"critical\"; // Climbing spiders are very dangerous up close\n            }\n        }\n\n        // Attack state threat\n        if (spiderData.isAttacking) {\n            threatScore += 20;\n        }\n\n        // Health-based threat (healthier spiders are more dangerous)\n        if (spiderData.healthPercentage > 75) {\n            threatScore += 10;\n        }\n\n        return { threatLevel, threatScore };\n    }\n\n    getThreatColor(threatLevel) {\n        switch (threatLevel) {\n            case \"critical\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"low\": return 0x00FF00; // Green\n            default: return 0x808080; // Gray\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentSpiderUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:spider\")) {\n                const spider = entity;\n                const uuid = spider.getUUID();\n                currentSpiderUUIDs.add(uuid);\n\n                const spiderData = this.analyzeSpider(spider);\n                const threat = this.generateThreatAssessment(spiderData);\n                const threatColor = this.getThreatColor(threat.threatLevel);\n\n                // Apply visual indicators based on threat level\n                if (threat.threatLevel !== \"low\") {\n                    spider.setGlowing(true);\n                    spider.setGlowingColor(threatColor);\n\n                    // Show action bar for high-threat spiders\n                    if (threat.threatLevel === \"critical\" || threat.threatLevel === \"high\") {\n                        const climbingStatus = spiderData.isClimbing ? \" (CLIMBING)\" : \"\";\n                        const healthStatus = ` ${Math.floor(spiderData.healthPercentage)}% HP`;\n                        Chat.actionbar(`&cSpider Threat: ${threat.threatLevel.toUpperCase()}${climbingStatus}${healthStatus} - ${spiderData.distance.toFixed(1)}m`);\n                    }\n                } else {\n                    spider.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed spider data\n        for (const [uuid, data] of this.trackedSpiders) {\n            if (!currentSpiderUUIDs.has(uuid)) {\n                const finalClimbingTime = data.totalClimbingTime;\n                Chat.log(`&7Spider removed from tracking - Total climbing time: ${(finalClimbingTime/20).toFixed(1)}s`);\n                this.trackedSpiders.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        Chat.log(\"=== Spider Behavior Analysis Report ===\");\n        Chat.log(`Total spiders tracked: ${this.stats.totalSeen}`);\n        Chat.log(`Currently active spiders: ${this.trackedSpiders.size}`);\n        Chat.log(`Spiders observed climbing: ${this.stats.climbingCount}`);\n\n        if (this.stats.averageClimbingTime > 0) {\n            Chat.log(`Average climbing session: ${(this.stats.averageClimbingTime/20).toFixed(1)}s`);\n        }\n\n        const climbingSpiders = Array.from(this.trackedSpiders.values()).filter(s => s.isClimbing);\n        Chat.log(`Currently climbing: ${climbingSpiders.length}`);\n\n        if (climbingSpiders.length > 0) {\n            Chat.log(\"\\nClimbing spiders:\");\n            climbingSpiders.forEach(spider => {\n                const pos = spider.spider.getPos();\n                Chat.log(`  - Distance: ${spider.distance.toFixed(1)}m at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            });\n        }\n    }\n}\n\n// Initialize and run the spider monitor\nconst spiderMonitor = new SpiderMonitor();\n\n// Update monitoring every tick for real-time tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    spiderMonitor.update();\n}));\n\n// Generate analysis report every 2 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 2) === 0) {\n        spiderMonitor.generateReport();\n    }\n}));\n\nChat.log(\"&aSpider Behavior Monitor activated - Tracking spider movement and climbing patterns\");",
        "// Advanced spider climbing detection and defense system\nfunction detectSpiderClimbing() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const playerPos = player.getPos();\n    const entities = World.getEntities();\n    const climbingSpiders = [];\n    const threats = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:spider\")) {\n            const spider = entity;\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const isClimbing = spider.isClimbing();\n            const isAttacking = spider.isAttacking();\n\n            // Analyze climbing patterns\n            if (isClimbing) {\n                climbingSpiders.push({\n                    spider: spider,\n                    position: pos,\n                    distance: distance,\n                    isAttacking: isAttacking,\n                    height: pos.y - Math.floor(pos.y), // Height within block\n                    health: spider.getHealth(),\n                    maxHealth: spider.getMaxHealth()\n                });\n\n                // Assess threat level\n                let threatLevel = \"low\";\n                if (distance <= 8 && isClimbing) {\n                    threatLevel = isAttacking ? \"critical\" : \"high\";\n                } else if (distance <= 16 && isClimbing) {\n                    threatLevel = \"medium\";\n                }\n\n                threats.push({\n                    spider: spider,\n                    threatLevel: threatLevel,\n                    distance: distance,\n                    position: pos\n                });\n            }\n        }\n    });\n\n    // Sort threats by distance and severity\n    threats.sort((a, b) => {\n        const threatOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n        const aPriority = threatOrder[a.threatLevel];\n        const bPriority = threatOrder[b.threatLevel];\n\n        if (aPriority !== bPriority) {\n            return aPriority - bPriority;\n        }\n        return a.distance - b.distance;\n    });\n\n    // Display climbing spider information\n    if (climbingSpiders.length > 0) {\n        Chat.log(`&6Spider Alert: ${climbingSpiders.length} spider${climbingSpiders.length > 1 ? 's are' : ' is'} climbing!`);\n\n        climbingSpiders.forEach((spiderData, index) => {\n            const healthPercentage = (spiderData.health / spiderData.maxHealth) * 100;\n            Chat.log(`${index + 1}. &eClimbing Spider - Distance: ${spiderData.distance.toFixed(1)}m, Health: ${Math.floor(healthPercentage)}%, Attacking: ${spiderData.isAttacking}`);\n        });\n\n        // Show action bar for most immediate threat\n        if (threats.length > 0) {\n            const topThreat = threats[0];\n            let threatMessage = \"\";\n\n            switch (topThreat.threatLevel) {\n                case \"critical\":\n                    threatMessage = `&c&&lCRITICAL: Spider climbing and attacking! ${topThreat.distance.toFixed(1)}m`;\n                    break;\n                case \"high\":\n                    threatMessage = `&e&&lHIGH THREAT: Spider climbing nearby! ${topThreat.distance.toFixed(1)}m`;\n                    break;\n                case \"medium\":\n                    threatMessage = `&6CAUTION: Spider climbing in area ${topThreat.distance.toFixed(1)}m`;\n                    break;\n                default:\n                    threatMessage = `Spider climbing detected ${topThreat.distance.toFixed(1)}m`;\n            }\n\n            Chat.actionbar(threatMessage);\n\n            // Highlight the most dangerous spider\n            topThreat.spider.setGlowing(true);\n            topThreat.spider.setGlowingColor(0xFF0000); // Red for critical threats\n        }\n    }\n}\n\n// Run climbing detection every 3 ticks for good coverage without excessive calls\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 3 === 0) {\n        detectSpiderClimbing();\n    }\n}));\n\nChat.log(\"&aSpider Climbing Detection System activated\");",
        "// Analyze player defenses against climbing spiders\nfunction analyzeSpiderDefenses() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const playerPos = player.getPos();\n    const playerBlockPos = player.getBlockPos();\n    const entities = World.getEntities();\n\n    // Find all spiders\n    const spiders = entities.filter(entity => entity.is(\"minecraft:spider\"));\n    const climbingSpiders = spiders.filter(spider => spider.isClimbing());\n\n    if (spiders.length === 0) {\n        Chat.log(\"No spiders detected in the area\");\n        return;\n    }\n\n    Chat.log(`=== Spider Defense Analysis ===`);\n    Chat.log(`Total spiders: ${spiders.length}`);\n    Chat.log(`Climbing spiders: ${climbingSpiders.length} (${(climbingSpiders.length/spiders.length*100).toFixed(1)}%)`);\n\n    // Analyze climbing spider positions relative to player\n    let climbersAbove = 0;\n    let climbersLevel = 0;\n    let climbersBelow = 0;\n    let closeClimbers = 0;\n\n    climbingSpiders.forEach(spider => {\n        const spiderPos = spider.getPos();\n        const distance = player.distanceTo(spider);\n\n        if (distance <= 16) closeClimbers++;\n\n        if (spiderPos.y > playerPos.y + 2) {\n            climbersAbove++;\n        } else if (spiderPos.y >= playerPos.y - 1 && spiderPos.y <= playerPos.y + 2) {\n            climbersLevel++;\n        } else {\n            climbersBelow++;\n        }\n    });\n\n    Chat.log(`Climbing spiders by position:`);\n    Chat.log(`  Above player: ${climbersAbove}`);\n    Chat.log(`  Level with player: ${climbersLevel}`);\n    Chat.log(`  Below player: ${climbersBelow}`);\n    Chat.log(`  Within 16 blocks: ${closeClimbers}`);\n\n    // Defense recommendations\n    Chat.log(\"\\n=== Defense Recommendations ===\");\n\n    if (closeClimbers > 0) {\n        Chat.log(\"&c&&lIMMEDIATE ACTION REQUIRED:\");\n        Chat.log(\"- Climbing spiders are within attack range!\");\n        Chat.log(\"- Spiders can climb over most barriers\");\n        Chat.log(\"- Consider backing away to open terrain\");\n    }\n\n    if (climbersAbove > 0) {\n        Chat.log(\"&e&&lOVERHEAD THREAT:\");\n        Chat.log(\"- Spiders are climbing above your position\");\n        Chat.log(\"- Watch for ceiling attacks\");\n        Chat.log(\"- Consider moving to open areas\");\n    }\n\n    if (climbersLevel > 0) {\n        Chat.log(\"&6&&lDIRECTIONAL THREAT:\");\n        Chat.log(\"- Spiders climbing at your level\");\n        Chat.log(\"- Maintain distance and use ranged attacks\");\n        Chat.log(\"- Avoid corners where spiders can trap you\");\n    }\n\n    // Barrier effectiveness analysis\n    const totalClimbingRate = spiders.length > 0 ? (climbingSpiders.length / spiders.length) : 0;\n\n    if (totalClimbingRate > 0.5) {\n        Chat.log(\"\\n&c&&lBARRIER ANALYSIS:\");\n        Chat.log(\"- High climbing rate detected!\");\n        Chat.log(\"- Your current location has poor spider defenses\");\n        Chat.log(\"- Spiders are actively using terrain to approach\");\n        Chat.log(\"- Consider moving to more defensible position\");\n    }\n\n    // Player protection assessment\n    const immediateThreats = climbingSpiders.filter(spider => player.distanceTo(spider) <= 8);\n\n    if (immediateThreats.length > 0) {\n        Chat.log(\"\\n&4&&lSAFETY WARNING:\");\n        Chat.log(`- ${immediateThreats.length} climbing spider${immediateThreats.length > 1 ? 's are' : ' is'} in immediate range!`);\n        Chat.log(\"- Conventional barriers may be ineffective\");\n        Chat.log(\"- Spiders can attack from unexpected angles\");\n        Chat.log(\"- Retreat to open terrain immediately\");\n\n        // Emergency highlighting\n        immediateThreats.forEach(spider => {\n            spider.setGlowing(true);\n            spider.setGlowingColor(0xFF0000); // Red for emergency threats\n        });\n    }\n\n    return {\n        totalSpiders: spiders.length,\n        climbingSpiders: climbingSpiders.length,\n        closeClimbers: closeClimbers,\n        immediateThreats: immediateThreats.length,\n        climbingRate: totalClimbingRate\n    };\n}\n\n// Run defense analysis every 10 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 200 === 0) { // Every 200 ticks (10 seconds)\n        analyzeSpiderDefenses();\n    }\n}));\n\nChat.log(\"&aSpider Defense Analysis System activated\");"
      ]
    }
  ]
}