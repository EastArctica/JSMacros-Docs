{
  "name": "FrogEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.FrogEntityHelper",
  "extends": "AnimalEntityHelper<FrogEntity>",
  "since": "JSMacros 1.8.4",
  "description": "The `FrogEntityHelper` class provides specialized access to frog entities in Minecraft, offering methods for identifying frog variants, tracking hunting behavior, and monitoring croaking animations. This class extends `AnimalEntityHelper`, inheriting comprehensive functionality for animal breeding, feeding mechanics, mob behaviors, living entity properties, and basic entity operations.",
  "overview": "Frogs are unique passive mobs that can be found in swamp biomes and come in different variants depending on the temperature of their spawning biome. They are also capable of hunting small mobs like slimes and magma cubes.",
  "constructors": [],
  "methods": [
    {
      "name": "getVariant",
      "signature": "getVariant()",
      "returnType": "String",
      "description": "Returns the variant type of this frog, which is determined by the biome temperature where the frog was spawned.",
      "parameters": [],
      "static": false,
      "examples": [
        "const entities = World.getEntities(32);\nconst frogs = entities.filter(entity => entity.getType() === \"minecraft:frog\");\n\nfrogs.forEach(entity => {\n    const frog = entity.asAnimal();\n    const variant = frog.getVariant();\n    const pos = entity.getPos();\n\n    Chat.log(`Frog at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)} is variant: ${variant}`);\n});"
      ]
    },
    {
      "name": "getTarget",
      "signature": "getTarget()",
      "returnType": "EntityHelper<?>",
      "description": "Returns the entity that this frog is currently targeting for hunting. Frogs will target and attack small mobs like slimes and magma cubes using their tongue attack.",
      "parameters": [],
      "static": false,
      "examples": [
        "events.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    const entities = World.getEntities(16);\n    const frogs = entities.filter(entity => entity.getType() === \"minecraft:frog\");\n\n    frogs.forEach(entity => {\n        const frog = entity.asAnimal();\n        const target = frog.getTarget();\n\n        if (target) {\n            const frogPos = entity.getPos();\n            const targetPos = target.getPos();\n            const distance = frogPos.distanceTo(targetPos);\n\n            // Highlight hunting frogs and their targets\n            entity.setGlowing(true);\n            entity.setGlowingColor(0x00FF00); // Green for frog\n            target.setGlowing(true);\n            target.setGlowingColor(0xFF0000); // Red for target\n\n            Chat.actionbar(`Frog hunting ${target.getType()} (${distance.toFixed(1)}m away)`);\n        } else {\n            entity.resetGlowing();\n        }\n    });\n}));"
      ]
    },
    {
      "name": "isCroaking",
      "signature": "isCroaking()",
      "returnType": "boolean",
      "description": "Returns whether the frog is currently playing its croaking animation. Frogs croak periodically and this can be used to identify active or vocalizing frogs.",
      "parameters": [],
      "static": false,
      "examples": [
        "class FrogObserver {\n    constructor() {\n        this.observedFrogs = new Map();\n        this.scanRadius = 24;\n        this.lastScan = 0;\n    }\n\n    scanFrogs() {\n        const entities = World.getEntities(this.scanRadius);\n        const frogs = entities.filter(entity => entity.getType() === \"minecraft:frog\");\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        frogs.forEach(entity => {\n            const uuid = entity.getUUID();\n            const frog = entity.asAnimal();\n            const pos = entity.getPos();\n            const isCroaking = frog.isCroaking();\n            const variant = frog.getVariant();\n            const target = frog.getTarget();\n\n            const frogData = {\n                uuid: uuid,\n                entity: entity,\n                frog: frog,\n                position: pos,\n                variant: variant,\n                isCroaking: isCroaking,\n                target: target,\n                lastCroakTime: isCroaking ? Client.getTime() : (this.observedFrogs.get(uuid)?.lastCroakTime || 0),\n                croakCount: this.observedFrogs.get(uuid)?.croakCount || 0\n            };\n\n            // Track croaking behavior\n            if (isCroaking && !this.observedFrogs.get(uuid)?.isCroaking) {\n                frogData.lastCroakTime = Client.getTime();\n                frogData.croakCount++;\n\n                Chat.log(`&eFrog (${variant}) started croaking at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`);\n\n                // Brief highlight when croaking\n                entity.setGlowing(true);\n                entity.setGlowingColor(0x00FFFF); // Cyan for croaking\n                setTimeout(() => {\n                    entity.resetGlowing();\n                }, 2000);\n            }\n\n            this.observedFrogs.set(uuid, frogData);\n        });\n\n        // Clean up frogs that are no longer in range\n        const currentUUIDs = new Set(frogs.map(f => f.getUUID()));\n        for (const [uuid, frogData] of this.observedFrogs) {\n            if (!currentUUIDs.has(uuid)) {\n                this.observedFrogs.delete(uuid);\n            }\n        }\n    }\n\n    generateFrogReport() {\n        if (this.observedFrogs.size === 0) {\n            Chat.log(\"&7No frogs found in range\");\n            return;\n        }\n\n        Chat.log(\"=== Frog Observation Report ===\");\n\n        // Count by variant\n        const variantCounts = new Map();\n        let croakingCount = 0;\n        let huntingCount = 0;\n\n        for (const [uuid, frogData] of this.observedFrogs) {\n            const variant = frogData.variant;\n            variantCounts.set(variant, (variantCounts.get(variant) || 0) + 1);\n\n            if (frogData.isCroaking) croakingCount++;\n            if (frogData.target) huntingCount++;\n        }\n\n        Chat.log(\"&6Frog Variants:\");\n        for (const [variant, count] of variantCounts) {\n            const variantName = variant.replace(\"minecraft:\", \"\").charAt(0).toUpperCase() +\n                               variant.replace(\"minecraft:\", \"\").slice(1);\n            Chat.log(`  ${variantName}: ${count}`);\n        }\n\n        Chat.log(`\\n&eActivity Status:`);\n        Chat.log(`  Croaking: ${croakingCount}/${this.observedFrogs.size}`);\n        Chat.log(`  Hunting: ${huntingCount}/${this.observedFrogs.size}`);\n\n        // Show most vocal frogs\n        const sortedByCroaks = Array.from(this.observedFrogs.entries())\n            .sort((a, b) => b[1].croakCount - a[1].croakCount)\n            .slice(0, 3);\n\n        if (sortedByCroaks.length > 0 && sortedByCroaks[0][1].croakCount > 0) {\n            Chat.log(`\\n&eMost Vocal Frogs:`);\n            sortedByCroaks.forEach(([uuid, frogData], index) => {\n                const variant = frogData.variant.replace(\"minecraft:\", \"\");\n                Chat.log(`  ${index + 1}. ${variant} frog: ${frogData.croakCount} croaks observed`);\n            });\n        }\n    }\n\n    highlightHuntingFrogs() {\n        for (const [uuid, frogData] of this.observedFrogs) {\n            if (frogData.target) {\n                // Highlight frog-prey interactions\n                frogData.entity.setGlowing(true);\n                frogData.entity.setGlowingColor(0x00FF00); // Green for hunting frog\n                frogData.target.setGlowing(true);\n                frogData.target.setGlowingColor(0xFFA500); // Orange for prey\n\n                // Draw line between frog and target\n                const frogPos = frogData.position;\n                const targetPos = frogData.target.getPos();\n\n                const line = new Line3D(\n                    frogPos.x, frogPos.y + 0.5, frogPos.z,\n                    targetPos.x, targetPos.y, targetPos.z,\n                    0x00FF00, 0xFF0000, 2, false\n                );\n\n                // Add to 3D render for one tick\n                const render3D = Hud.createDraw3D();\n                render3D.addLine(line);\n                render3D.register();\n            } else {\n                frogData.entity.resetGlowing();\n            }\n        }\n    }\n\n    update() {\n        if (Client.getTime() - this.lastScan < 20) return; // Scan every second\n\n        this.lastScan = Client.getTime();\n        this.scanFrogs();\n        this.highlightHuntingFrogs();\n    }\n}\n\n// Initialize frog observer\nconst frogObserver = new FrogObserver();\n\n// Regular updates\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    frogObserver.update();\n}));\n\n// Generate report every 30 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 30) === 0) {\n        frogObserver.generateFrogReport();\n    }\n}));\n\nChat.log(\"&aFrog Observer activated! Monitoring frog variants, behavior, and hunting activity...\");"
      ]
    }
  ]
}