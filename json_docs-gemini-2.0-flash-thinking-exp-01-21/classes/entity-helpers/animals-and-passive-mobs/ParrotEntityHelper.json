{
  "name": "ParrotEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.ParrotEntityHelper",
  "extends": "TameableEntityHelper<ParrotEntity>",
  "since": "1.8.4",
  "description": "The ParrotEntityHelper class provides specialized methods for interacting with Parrot entities in Minecraft. Parrots are flying passive mobs that come in various colors, can mimic sounds, sit on players' shoulders, and dance to music. These colorful birds spawn naturally in jungle biomes and can be tamed with seeds, making them excellent companions with unique behaviors.",
  "overview": "Parrots are special among Minecraft mobs for their ability to mimic nearby mob sounds, sit on player shoulders, and dance to jukebox or note block music. They can be tamed using any type of seed (grass seeds, melon seeds, pumpkin seeds, beetroot seeds, wheat seeds, or torchflower seeds), and tamed parrots will follow their owners like other tamed animals. However, parrots have the unique ability to perch on player shoulders, making them portable companions.\n\nThis helper class provides access to key parrot behaviors including their color variant, current state (sitting, flying, dancing), shoulder perching status, and all standard tameable entity functionality. The class extends TameableEntityHelper and inherits comprehensive methods for ownership management, health tracking, AI control, and other tameable animal behaviors, while adding parrot-specific functionality.",
  "constructors": [],
  "methods": [
    {
      "name": "getVariant",
      "signature": "getVariant()",
      "returnType": "String",
      "description": "Returns the color variant of this parrot. Parrots come in 5 different color variants that affect their appearance but don't affect gameplay mechanics.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Analyze all parrots in the area by their color variants\nconst parrots = World.getEntities(\"minecraft:parrot\");\nconst variantCounts = new Map();\nconst player = Player.getPlayer();\n\nif (!player) return;\n\nconst playerPos = player.getPos();\nconst range = 64; // Search range for parrots\n\nChat.log(\"ü¶ú=== Parrot Color Analysis ===\");\n\nparrots.forEach(entity => {\n    const distance = player.distanceTo(entity);\n    if (distance <= range) {\n        const parrot = entity.as(\"minecraft:parrot\");\n        const variant = parrot.getVariant();\n        const pos = entity.getPos();\n\n        // Count variants\n        variantCounts.set(variant, (variantCounts.get(variant) || 0) + 1);\n\n        // Log detailed information\n        Chat.log(`${getVariantDisplayName(variant)} parrot at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}] (${distance.toFixed(1)}m away)`);\n\n        // Additional states\n        const isTamed = parrot.isTamed();\n        const isDancing = parrot.isPartying();\n        const isFlying = parrot.isFlying();\n        const isShoulder = parrot.isSittingOnShoulder();\n\n        Chat.log(`  Status: ${isTamed ? \"Tamed\" : \"Wild\"}, ${isDancing ? \"Dancing üéµ\" : \"\"}${isFlying ? \"Flying\" : \"\"}${isShoulder ? \"Shoulder-perched\" : \"\"}`);\n    }\n});\n\n// Display variant collection summary\nChat.log(`\\nüìä Found ${parrots.length} parrots within ${range} blocks:`);\nfor (const [variant, count] of variantCounts) {\n    const variantName = getVariantDisplayName(variant);\n    Chat.log(`  ${variantName}: ${count}`);\n}\n\nfunction getVariantDisplayName(variantId) {\n    const variantNames = {\n        \"minecraft:red\": \"Red\",\n        \"minecraft:blue\": \"Blue\",\n        \"minecraft:green\": \"Green\",\n        \"minecraft:cyan\": \"Cyan\",\n        \"minecraft:gray\": \"Gray\"\n    };\n    return variantNames[variantId] || variantId.replace(\"minecraft:\", \"\");\n}"
      ]
    },
    {
      "name": "isSitting",
      "signature": "isSitting()",
      "returnType": "boolean",
      "description": "Returns whether this parrot is currently in a sitting pose. Parrots can sit when commanded by their owner or when they land on the ground after flying.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Monitor tamed parrot activity and sitting behavior\nclass ParrotActivityMonitor {\n    constructor() {\n        this.monitoredParrots = new Map();\n        this.sittingStats = {\n            totalTimeSitting: 0,\n            totalTimeFlying: 0,\n            totalTimeDancing: 0\n        };\n    }\n\n    updateParrotActivity() {\n        const entities = World.getEntities(32); // 32 block range\n        const currentParrotUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:parrot\")) {\n                const parrot = entity.as(\"minecraft:parrot\");\n                const uuid = entity.getUUID();\n                currentParrotUUIDs.add(uuid);\n\n                if (!this.monitoredParrots.has(uuid)) {\n                    // New parrot detected\n                    this.monitoredParrots.set(uuid, {\n                        entity: entity,\n                        parrot: parrot,\n                        lastState: this.getParrotState(parrot),\n                        stateStartTime: Client.getTime(),\n                        name: parrot.isTamed() ? parrot.getName().getString() : \"Wild Parrot\"\n                    });\n\n                    Chat.log(`ü¶ú Started monitoring: ${this.monitoredParrots.get(uuid).name}`);\n                } else {\n                    // Update existing parrot\n                    this.updateParrotState(uuid, parrot);\n                }\n            }\n        });\n\n        // Remove parrots that are no longer in range\n        for (const [uuid, parrotData] of this.monitoredParrots) {\n            if (!currentParrotUUIDs.has(uuid)) {\n                Chat.log(`ü¶ú ${parrotData.name} left monitoring range`);\n                this.monitoredParrots.delete(uuid);\n            }\n        }\n    }\n\n    getParrotState(parrot) {\n        return {\n            isSitting: parrot.isSitting(),\n            isFlying: parrot.isFlying(),\n            isDancing: parrot.isPartying(),\n            isStanding: parrot.isStanding(),\n            isOnShoulder: parrot.isSittingOnShoulder(),\n            isTamed: parrot.isTamed()\n        };\n    }\n\n    updateParrotState(uuid, parrot) {\n        const parrotData = this.monitoredParrots.get(uuid);\n        const currentState = this.getParrotState(parrot);\n        const previousState = parrotData.lastState;\n        const currentTime = Client.getTime();\n\n        // Check for state changes\n        this.detectStateChanges(parrotData, previousState, currentState, currentTime);\n\n        // Update stored data\n        parrotData.lastState = currentState;\n    }\n\n    detectStateChanges(parrotData, previousState, currentState, currentTime) {\n        const duration = currentTime - parrotData.stateStartTime;\n        const { name } = parrotData;\n        let changes = [];\n\n        // Sitting state changes\n        if (previousState.isSitting !== currentState.isSitting) {\n            if (currentState.isSitting) {\n                changes.push(\"Sat down\");\n                Chat.log(`ü¶ú ${name} sat down`);\n            } else {\n                changes.push(\"Stood up\");\n                Chat.log(`ü¶ú ${name} stood up after ${duration} ticks`);\n            }\n            this.sittingStats.totalTimeSitting += duration;\n        }\n\n        // Flying state changes\n        if (previousState.isFlying !== currentState.isFlying) {\n            if (currentState.isFlying) {\n                changes.push(\"Started flying\");\n                Chat.log(`ü¶ú ${name} took flight`);\n            } else {\n                changes.push(\"Landed\");\n                Chat.log(`ü¶ú ${name} landed after ${duration} ticks`);\n            }\n            this.sittingStats.totalTimeFlying += duration;\n        }\n\n        // Dancing state changes\n        if (previousState.isDancing !== currentState.isDancing) {\n            if (currentState.isDancing) {\n                changes.push(\"Started dancing üéµ\");\n                Chat.log(`ü¶ú ${name} is dancing to music!`);\n            } else {\n                changes.push(\"Stopped dancing\");\n                Chat.log(`ü¶ú ${name} stopped dancing after ${duration} ticks`);\n            }\n            this.sittingStats.totalTimeDancing += duration;\n        }\n\n        // Shoulder perching changes\n        if (previousState.isOnShoulder !== currentState.isOnShoulder) {\n            if (currentState.isOnShoulder) {\n                changes.push(\"Perched on shoulder\");\n                Chat.log(`ü¶ú ${name} is now perched on a player's shoulder!`);\n            } else {\n                changes.push(\"Left shoulder\");\n                Chat.log(`ü¶ú ${name} left player's shoulder after ${duration} ticks`);\n            }\n        }\n\n        // Report significant state changes\n        if (changes.length > 0) {\n            const changesText = changes.join(\", \");\n            Chat.log(`ü¶ú ${name}: ${changesText}`);\n        }\n\n        // Update state start time\n        parrotData.stateStartTime = currentTime;\n    }\n\n    generateActivityReport() {\n        if (this.monitoredParrots.size === 0) {\n            Chat.log(\"No parrots currently being monitored\");\n            return;\n        }\n\n        Chat.log(\"ü¶ú=== Parrot Activity Report ===\");\n        Chat.log(`Currently monitoring: ${this.monitoredParrots.size} parrot(s)`);\n\n        // Current status summary\n        let sittingCount = 0;\n        let flyingCount = 0;\n        let dancingCount = 0;\n        let shoulderCount = 0;\n        let tamedCount = 0;\n\n        for (const [uuid, parrotData] of this.monitoredParrots) {\n            const state = parrotData.lastState;\n            if (state.isSitting) sittingCount++;\n            if (state.isFlying) flyingCount++;\n            if (state.isDancing) dancingCount++;\n            if (state.isOnShoulder) shoulderCount++;\n            if (state.isTamed) tamedCount++;\n\n            Chat.log(`\\n${parrotData.name}:`);\n            Chat.log(`  Status: ${state.isSitting ? \"Sitting\" : state.isFlying ? \"Flying\" : state.isStanding ? \"Standing\" : \"Unknown\"}`);\n            Chat.log(`  Dancing: ${state.isDancing ? \"Yes üéµ\" : \"No\"}`);\n            Chat.log(`  Shoulder: ${state.isOnShoulder ? \"Yes\" : \"No\"}`);\n            Chat.log(`  Tamed: ${state.isTamed ? \"Yes\" : \"No\"}`);\n        }\n\n        Chat.log(`\\nüìä Activity Summary:`);\n        Chat.log(`  Sitting: ${sittingCount}`);\n        Chat.log(`  Flying: ${flyingCount}`);\n        Chat.log(`  Dancing: ${dancingCount}`);\n        Chat.log(`  On shoulder: ${shoulderCount}`);\n        Chat.log(`  Tamed: ${tamedCount}`);\n    }\n}\n\nconst parrotMonitor = new ParrotActivityMonitor();\n\n// Monitor parrot activity every second\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    if (Client.getTime() % 20 === 0) {\n        parrotMonitor.updateParrotActivity();\n    }\n}));\n\n// Generate report on keypress\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.p\" && e.action === 1) { // P key\n        parrotMonitor.generateActivityReport();\n    }\n}));\n\nChat.log(\"ü¶ú Parrot Activity Monitor activated!\");"
      ]
    },
    {
      "name": "isFlying",
      "signature": "isFlying()",
      "returnType": "boolean",
      "description": "Returns whether this parrot is currently flying. Parrots fly when moving between locations, escaping threats, or following their owner.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Parrot flight pattern analysis and monitoring\nfunction analyzeParrotFlightPatterns() {\n    const parrots = World.getEntities(\"minecraft:parrot\");\n    const player = Player.getPlayer();\n\n    if (!player) return;\n\n    const flightData = [];\n    const playerPos = player.getPos();\n\n    Chat.log(\"ü¶ú=== Parrot Flight Analysis ===\");\n\n    parrots.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= 48) { // 48 block range\n            const parrot = entity.as(\"minecraft:parrot\");\n            const pos = entity.getPos();\n            const variant = parrot.getVariant();\n            const isFlying = parrot.isFlying();\n            const isTamed = parrot.isTamed();\n\n            flightData.push({\n                entity: entity,\n                parrot: parrot,\n                position: pos,\n                variant: variant,\n                isFlying: isFlying,\n                isTamed: isTamed,\n                distance: distance,\n                height: pos.y - playerPos.y // Height relative to player\n            });\n\n            // Log individual parrot status\n            const variantName = getVariantDisplayName(variant);\n            Chat.log(`${variantName} parrot [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]:`);\n            Chat.log(`  Status: ${isFlying ? \"‚úàÔ∏è Flying\" : \"üèÉ Grounded\"}`);\n            Chat.log(`  Tamed: ${isTamed ? \"Yes\" : \"No\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`  Relative height: ${pos.y - playerPos.y.toFixed(1)} blocks`);\n\n            if (isFlying) {\n                Chat.log(`  Flight characteristics:`);\n                Chat.log(`    Current altitude: ${pos.y.toFixed(1)}`);\n                Chat.log(`    Ground distance: ${Math.sqrt(Math.pow(pos.x - playerPos.x, 2) + Math.pow(pos.z - playerPos.z, 2)).toFixed(1)}m`);\n\n                // Check if parrot is following player\n                if (isTamed && distance <= 16) {\n                    Chat.log(`    Following owner: Yes (close range)`);\n                }\n\n                // Check if parrot is escaping or being called\n                const isDancing = parrot.isPartying();\n                if (isDancing) {\n                    Chat.log(`    Special behavior: Dancing while flying!`);\n                }\n            }\n        }\n    });\n\n    // Flight analysis summary\n    const flyingParrots = flightData.filter(p => p.isFlying);\n    const groundedParrots = flightData.filter(p => !p.isFlying);\n    const tamedFlying = flyingParrots.filter(p => p.isTamed);\n    const wildFlying = flyingParrots.filter(p => !p.isTamed);\n\n    Chat.log(`\\nüìä Flight Analysis Summary:`);\n    Chat.log(`Total parrots found: ${flightData.length}`);\n    Chat.log(`Currently flying: ${flyingParrots.length} (${(flyingParrots.length / flightData.length * 100).toFixed(1)}%)`);\n    Chat.log(`Currently grounded: ${groundedParrots.length} (${(groundedParrots.length / flightData.length * 100).toFixed(1)}%)`);\n    Chat.log(`Tamed parrots flying: ${tamedFlying.length}`);\n    Chat.log(`Wild parrots flying: ${wildFlying.length}`);\n\n    // Height analysis\n    if (flyingParrots.length > 0) {\n        const altitudes = flyingParrots.map(p => p.position.y);\n        const avgAltitude = altitudes.reduce((sum, alt) => sum + alt, 0) / altitudes.length;\n        const maxAltitude = Math.max(...altitudes);\n        const minAltitude = Math.min(...altitudes);\n\n        Chat.log(`\\nüìà Altitude Statistics:`);\n        Chat.log(`Average flight altitude: ${avgAltitude.toFixed(1)}`);\n        Chat.log(`Maximum altitude: ${maxAltitude.toFixed(1)}`);\n        Chat.log(`Minimum altitude: ${minAltitude.toFixed(1)}`);\n        Chat.log(`Altitude range: ${(maxAltitude - minAltitude).toFixed(1)} blocks`);\n    }\n\n    // Behavior patterns\n    Chat.log(`\\nüîç Behavior Patterns:`);\n\n    if (tamedFlying.length > 0) {\n        Chat.log(`‚úàÔ∏è Tamed parrots in flight: ${tamedFlying.length}`);\n        Chat.log(`  These parrots are likely following their owner or responding to commands`);\n\n        const avgTamedDistance = tamedFlying.reduce((sum, p) => sum + p.distance, 0) / tamedFlying.length;\n        Chat.log(`  Average distance from owner: ${avgTamedDistance.toFixed(1)}m`);\n    }\n\n    if (wildFlying.length > 0) {\n        Chat.log(`üåø Wild parrots in flight: ${wildFlying.length}`);\n        Chat.log(`  These parrots may be exploring, fleeing from threats, or moving between perches`);\n    }\n\n    // Flight recommendations\n    if (flightData.length > 0) {\n        Chat.log(`\\nüí° Parrot Flight Tips:`);\n        Chat.log(`- Tamed parrots will fly to follow their owner within a reasonable range`);\n        Chat.log(`- Wild parrots fly more often and are more skittish`);\n        Chat.log(`- Parrots can fly through small openings due to their small size`);\n        Chat.log(`- Flying parrots will perch on nearby blocks or player shoulders`);\n        Chat.log(`- Use seeds to tame wild parrots and make them follow you`);\n\n        if (player.getMainHand() && player.getMainHand().getId().includes(\"seed\")) {\n            Chat.log(`‚úÖ You're holding seeds - good for taming nearby parrots!`);\n        }\n    }\n\n    if (flightData.length === 0) {\n        Chat.log(\"No parrots found in the area. Parrots spawn naturally in jungle biomes!\");\n    }\n}\n\nfunction getVariantDisplayName(variantId) {\n    const variantNames = {\n        \"minecraft:red\": \"Red\",\n        \"minecraft:blue\": \"Blue\",\n        \"minecraft:green\": \"Green\",\n        \"minecraft:cyan\": \"Cyan\",\n        \"minecraft:gray\": \"Gray\"\n    };\n    return variantNames[variantId] || variantId.replace(\"minecraft:\", \"\");\n}\n\n// Run flight analysis\nanalyzeParrotFlightPatterns();\n\n// Set up keybind to refresh analysis\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.f\" && e.action === 1) { // F key\n        analyzeParrotFlightPatterns();\n    }\n}));"
      ]
    },
    {
      "name": "isPartying",
      "signature": "isPartying()",
      "returnType": "boolean",
      "description": "Returns whether this parrot is currently dancing to music. Parrots dance when they hear music from jukeboxes or note blocks within a certain range.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive parrot party monitoring system\nclass ParrotPartyMonitor {\n    constructor() {\n        this.partyingParrots = new Set();\n        this.partyHistory = [];\n        this.musicSources = new Map(); // Track detected music sources\n        this.lastMusicCheck = 0;\n    }\n\n    updateParrotParties() {\n        const parrots = World.getEntities(\"minecraft:parrot\");\n        const currentTime = Client.getTime();\n        const newPartyParrots = new Set();\n\n        parrots.forEach(entity => {\n            const parrot = entity.as(\"minecraft:parrot\");\n            if (parrot.isPartying()) {\n                const uuid = entity.getUUID();\n                const variant = parrot.getVariant();\n                const pos = entity.getPos();\n                const isTamed = parrot.isTamed();\n\n                newPartyParrots.add(uuid);\n\n                if (!this.partyingParrots.has(uuid)) {\n                    // Parrot just started dancing!\n                    this.partyHistory.push({\n                        startTime: currentTime,\n                        parrotUuid: uuid,\n                        variant: variant,\n                        position: { x: pos.x, y: pos.y, z: pos.z },\n                        isTamed: isTamed,\n                        name: isTamed ? entity.getName().getString() : \"Wild Parrot\"\n                    });\n\n                    Chat.log(`üéµü¶ú ${this.partyHistory[this.partyHistory.length - 1].name} started dancing!`);\n                    Chat.log(`   Variant: ${getVariantDisplayName(variant)}`);\n                    Chat.log(`   Position: [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}]`);\n\n                    // Highlight dancing parrots\n                    entity.setGlowing(true);\n                    entity.setGlowingColor(0xFF00FF); // Purple glow for dancing\n                }\n            } else {\n                // Parrot stopped dancing if it was before\n                if (this.partyingParrots.has(entity.getUUID())) {\n                    const uuid = entity.getUUID();\n                    const partyInfo = this.partyHistory.find(p => p.parrotUuid === uuid && !p.endTime);\n\n                    if (partyInfo) {\n                        partyInfo.endTime = currentTime;\n                        partyInfo.duration = currentTime - partyInfo.startTime;\n\n                        Chat.log(`ü¶ú ${partyInfo.name} stopped dancing after ${partyInfo.duration} ticks`);\n\n                        // Remove glow effect\n                        entity.resetGlowing();\n                    }\n                }\n            }\n        });\n\n        this.partyingParrots = newPartyParrots;\n\n        // Detect music sources periodically\n        if (currentTime - this.lastMusicCheck >= 100) { // Every 5 seconds\n            this.detectMusicSources();\n            this.lastMusicCheck = currentTime;\n        }\n    }\n\n    detectMusicSources() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const playerPos = player.getPos();\n        const detectionRange = 32; // Jukebox/note block detection range\n        const foundSources = [];\n\n        // Note: In actual implementation, you'd check for jukeboxes/note blocks\n        // For now, we'll detect based on parrot dancing behavior\n        if (this.partyingParrots.size > 0) {\n            Chat.log(`üéµ Music detected! ${this.partyingParrots.size} parrot(s) are dancing`);\n\n            // Estimate music source based on parrot positions\n            const parrots = World.getEntities(\"minecraft:parrot\");\n            const dancingParrots = parrots.filter(entity => {\n                const parrot = entity.as(\"minecraft:parrot\");\n                return parrot.isPartying() && player.distanceTo(entity) <= detectionRange;\n            });\n\n            if (dancingParrots.length > 0) {\n                // Calculate center of dancing parrots\n                const avgX = dancingParrots.reduce((sum, e) => sum + e.getPos().x, 0) / dancingParrots.length;\n                const avgY = dancingParrots.reduce((sum, e) => sum + e.getPos().y, 0) / dancingParrots.length;\n                const avgZ = dancingParrots.reduce((sum, e) => sum + e.getPos().z, 0) / dancingParrots.length;\n\n                const distance = Math.sqrt(\n                    Math.pow(avgX - playerPos.x, 2) +\n                    Math.pow(avgY - playerPos.y, 2) +\n                    Math.pow(avgZ - playerPos.z, 2)\n                );\n\n                Chat.log(`üìç Estimated music source: [${avgX.toFixed(1)}, ${avgY.toFixed(1)}, ${avgZ.toFixed(1)}]`);\n                Chat.log(`   Distance from you: ${distance.toFixed(1)}m`);\n\n                // Check what type of music might be playing\n                if (distance <= 16) {\n                    Chat.log(`üé∂ Music is very close - likely a nearby note block or jukebox!`);\n                    this.suggestMusicActions();\n                } else {\n                    Chat.log(`üé∂ Music is playing at a distance`);\n                }\n            }\n        }\n    }\n\n    suggestMusicActions() {\n        const player = Player.getPlayer();\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n\n        let hasMusicDisc = false;\n        let hasNoteBlock = false;\n\n        if (mainHand) {\n            if (mainHand.getId().includes(\"music_disc\")) hasMusicDisc = true;\n            if (mainHand.getId() === \"minecraft:note_block\") hasNoteBlock = true;\n        }\n\n        if (offHand) {\n            if (offHand.getId().includes(\"music_disc\")) hasMusicDisc = true;\n            if (offHand.getId() === \"minecraft:note_block\") hasNoteBlock = true;\n        }\n\n        Chat.log(`üí° Music Party Tips:`);\n        Chat.log(`- Use jukeboxes with music discs to make parrots dance`);\n        Chat.log(`- Note blocks can also make parrots dance`);\n        Chat.log(`- Multiple parrots will dance together to music`);\n        Chat.log(`- Tamed parrots will dance more reliably than wild ones`);\n\n        if (hasMusicDisc) {\n            Chat.log(`‚úÖ You have a music disc ready for jukebox play!`);\n        }\n\n        if (hasNoteBlock) {\n            Chat.log(`‚úÖ You have a note block - place it and play some music!`);\n        }\n    }\n\n    generatePartyReport() {\n        Chat.log(`üéµ=== Parrot Party Report ===`);\n        Chat.log(`Currently dancing: ${this.partyingParrots.size} parrot(s)`);\n\n        if (this.partyHistory.length > 0) {\n            const recentParties = this.partyHistory.filter(p =>\n                Client.getTime() - p.startTime <= 6000 // Last 5 minutes\n            );\n\n            if (recentParties.length > 0) {\n                Chat.log(`\\nüìä Recent Party History:`);\n\n                const totalDanceTime = recentParties\n                    .filter(p => p.duration)\n                    .reduce((sum, p) => sum + p.duration, 0);\n\n                Chat.log(`Parties in last 5 minutes: ${recentParties.length}`);\n                Chat.log(`Total dance time: ${totalDanceTime} ticks (${(totalDanceTime / 20).toFixed(1)} seconds)`);\n\n                // Variant breakdown\n                const variantCounts = new Map();\n                recentParties.forEach(party => {\n                    variantCounts.set(party.variant, (variantCounts.get(party.variant) || 0) + 1);\n                });\n\n                Chat.log(`\\nü¶ú Dancing Variants:`);\n                for (const [variant, count] of variantCounts) {\n                    const variantName = getVariantDisplayName(variant);\n                    Chat.log(`  ${variantName}: ${count} times`);\n                }\n\n                // Tamed vs wild\n                const tamedParties = recentParties.filter(p => p.isTamed).length;\n                const wildParties = recentParties.filter(p => !p.isTamed).length;\n\n                Chat.log(`\\nüë• Party Participants:`);\n                Chat.log(`  Tamed parrots: ${tamedParties}`);\n                Chat.log(`  Wild parrots: ${wildParties}`);\n            }\n        }\n\n        if (this.partyingParrots.size > 0) {\n            Chat.log(`\\nüéâ Active Party Now!`);\n            Chat.log(`Start a dance party with your parrots:`);\n            Chat.log(`1. Place a jukebox nearby`);\n            Chat.log(`2. Insert any music disc`);\n            Chat.log(`3. Watch the parrots dance!`);\n            Chat.log(`4. Try different music discs for variety`);\n        } else {\n            Chat.log(`\\nüí° How to Start a Party:`);\n            Chat.log(`1. Find or tame some parrots`);\n            Chat.log(`2. Place a jukebox within 16 blocks`);\n            Chat.log(`3. Insert a music disc to play music`);\n            Chat.log(`4. Parrots within range will automatically start dancing!`);\n        }\n    }\n}\n\nfunction getVariantDisplayName(variantId) {\n    const variantNames = {\n        \"minecraft:red\": \"Red\",\n        \"minecraft:blue\": \"Blue\",\n        \"minecraft:green\": \"Green\",\n        \"minecraft:cyan\": \"Cyan\",\n        \"minecraft:gray\": \"Gray\"\n    };\n    return variantNames[variantId] || variantId.replace(\"minecraft:\", \"\");\n}\n\nconst partyMonitor = new ParrotPartyMonitor();\n\n// Monitor parrot parties every tick for real-time updates\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    partyMonitor.updateParrotParties();\n}));\n\n// Generate party report on keypress\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.d\" && e.action === 1) { // D key\n        partyMonitor.generatePartyReport();\n    }\n}));\n\nChat.log(\"üéµü¶ú Parrot Party Monitor activated!\");"
      ]
    },
    {
      "name": "isStanding",
      "signature": "isStanding()",
      "returnType": "boolean",
      "description": "Returns whether this parrot is currently standing still. This method returns true when the parrot is neither sitting, flying, nor dancing - essentially when it's just standing on the ground in a neutral state.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Parrot behavior state analysis including standing detection\nfunction analyzeParrotBehaviorStates() {\n    const parrots = World.getEntities(\"minecraft:parrot\");\n    const player = Player.getPlayer();\n\n    if (!player) return;\n\n    const stateAnalysis = {\n        sitting: 0,\n        flying: 0,\n        dancing: 0,\n        standing: 0,\n        total: 0\n    };\n\n    const parrotDetails = [];\n\n    Chat.log(\"ü¶ú=== Parrot State Analysis ===\");\n\n    parrots.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= 32) { // 32 block range\n            const parrot = entity.as(\"minecraft:parrot\");\n            const pos = entity.getPos();\n            const variant = parrot.getVariant();\n\n            // Get all states\n            const isSitting = parrot.isSitting();\n            const isFlying = parrot.isFlying();\n            const isDancing = parrot.isPartying();\n            const isStanding = parrot.isStanding();\n            const isTamed = parrot.isTamed();\n            const isOnShoulder = parrot.isSittingOnShoulder();\n\n            // Count states\n            if (isSitting) stateAnalysis.sitting++;\n            if (isFlying) stateAnalysis.flying++;\n            if (isDancing) stateAnalysis.dancing++;\n            if (isStanding) stateAnalysis.standing++;\n            stateAnalysis.total++;\n\n            // Store details\n            const stateStr = isDancing ? \"Dancing üéµ\" :\n                           isFlying ? \"Flying ‚úàÔ∏è\" :\n                           isSitting ? \"Sitting ü™ë\" :\n                           isStanding ? \"Standing üèÉ\" : \"Unknown\";\n\n            parrotDetails.push({\n                entity: entity,\n                variant: variant,\n                state: stateStr,\n                distance: distance,\n                position: pos,\n                isTamed: isTamed,\n                isOnShoulder: isOnShoulder,\n                isStanding: isStanding\n            });\n\n            // Log individual parrot\n            const variantName = getVariantDisplayName(variant);\n            Chat.log(`${variantName} parrot at [${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}] (${distance.toFixed(1)}m):`);\n            Chat.log(`  State: ${stateStr}`);\n            Chat.log(`  Tamed: ${isTamed ? \"Yes\" : \"No\"}`);\n            Chat.log(`  On shoulder: ${isOnShoulder ? \"Yes\" : \"No\"}`);\n\n            // Standing-specific analysis\n            if (isStanding) {\n                Chat.log(`  Standing behavior: Parrot is alert but inactive`);\n                Chat.log(`  This is a neutral state - parrot may be observing or resting`);\n            }\n        }\n    });\n\n    // Display state analysis summary\n    if (stateAnalysis.total > 0) {\n        Chat.log(`\\nüìä State Distribution Analysis:`);\n        Chat.log(`Total parrots analyzed: ${stateAnalysis.total}`);\n\n        const states = [\n            { name: \"Standing\", count: stateAnalysis.standing, icon: \"üèÉ\" },\n            { name: \"Flying\", count: stateAnalysis.flying, icon: \"‚úàÔ∏è\" },\n            { name: \"Sitting\", count: stateAnalysis.sitting, icon: \"ü™ë\" },\n            { name: \"Dancing\", count: stateAnalysis.dancing, icon: \"üéµ\" }\n        ];\n\n        states.forEach(state => {\n            const percentage = (state.count / stateAnalysis.total * 100).toFixed(1);\n            Chat.log(`${state.icon} ${state.name}: ${state.count} (${percentage}%)`);\n        });\n\n        // Standing behavior analysis\n        if (stateAnalysis.standing > 0) {\n            Chat.log(`\\nüèÉ Standing Parrot Analysis:`);\n            Chat.log(`${stateAnalysis.standing} parrot(s) are currently standing`);\n\n            const standingParrots = parrotDetails.filter(p => p.isStanding);\n            const tamedStanding = standingParrots.filter(p => p.isTamed).length;\n            const wildStanding = standingParrots.filter(p => !p.isTamed).length;\n\n            Chat.log(`  Tamed parrots standing: ${tamedStanding}`);\n            Chat.log(`  Wild parrots standing: ${wildStanding}`);\n\n            // Analyze standing behavior context\n            if (tamedStanding > 0) {\n                Chat.log(`  Tamed standing parrots may be:`);\n                Chat.log(`    - Waiting for owner commands`);\n                Chat.log(`    - Observing surroundings`);\n                Chat.log(`    - Resting between activities`);\n                Chat.log(`    - Preparing to follow owner`);\n            }\n\n            if (wildStanding > 0) {\n                Chat.log(`  Wild standing parrots may be:`);\n                Chat.log(`    - Scanning for food (seeds)`);\n                Chat.log(`    - Observing potential threats`);\n                Chat.log(`    - Resting after flying`);\n                Chat.log(`    - Preparing to take flight`);\n            }\n\n            // Proximity analysis for standing parrots\n            const nearbyStanding = standingParrots.filter(p => p.distance <= 16);\n            if (nearbyStanding.length > 0) {\n                Chat.log(`\\n  Standing parrots within 16 blocks: ${nearbyStanding.length}`);\n                nearbyStanding.forEach(parrot => {\n                    const variantName = getVariantDisplayName(parrot.variant);\n                    Chat.log(`    ${variantName}: ${parrot.distance.toFixed(1)}m away`);\n                });\n\n                Chat.log(`  üí° These parrots are close enough to interact with!`);\n                Chat.log(`     Approach slowly with seeds to tame wild parrots`);\n                Chat.log(`     Give commands to tamed parrots`);\n            }\n        }\n\n        // Behavioral insights\n        Chat.log(`\\nüß† Behavioral Insights:`);\n\n        if (stateAnalysis.standing > stateAnalysis.flying) {\n            Chat.log(`Most parrots are grounded - they may be resting or observing`);\n        } else if (stateAnalysis.flying > stateAnalysis.standing) {\n            Chat.log(`Most parrots are active - they may be following owners or exploring`);\n        }\n\n        if (stateAnalysis.dancing > 0) {\n            Chat.log(`Music is detected nearby - parrots are enjoying the party! üéµ`);\n        }\n\n        if (stateAnalysis.sitting > 0) {\n            Chat.log(`Some parrots are sitting - they may be commanded to stay or resting`);\n        }\n\n        // Interaction suggestions\n        Chat.log(`\\nüí° Interaction Suggestions:`);\n\n        if (stateAnalysis.standing > 0) {\n            Chat.log(`- Standing parrots are receptive to interactions`);\n            Chat.log(`- Wild parrots: approach with seeds for taming`);\n            Chat.log(`- Tamed parrots: give commands or lead them to locations`);\n        }\n\n        const playerInventory = Player.openInventory();\n        const hasSeeds = playerInventory.getSlots().some(slot =>\n            slot && slot.getId() && (\n                slot.getId().includes(\"seed\") ||\n                slot.getId() === \"minecraft:wheat_seeds\" ||\n                slot.getId() === \"minecraft:melon_seeds\" ||\n                slot.getId() === \"minecraft:pumpkin_seeds\" ||\n                slot.getId() === \"minecraft:beetroot_seeds\"\n            )\n        );\n\n        if (hasSeeds) {\n            Chat.log(`‚úÖ You have seeds - perfect for taming standing wild parrots!`);\n        }\n else {\n            Chat.log(`üå± Get seeds from grass to tame wild parrots`);\n        }\n\n    } else {\n        Chat.log(\"No parrots found within 32 blocks\");\n        Chat.log(\"Parrots spawn naturally in jungle biomes!\");\n    }\n}\n\nfunction getVariantDisplayName(variantId) {\n    const variantNames = {\n        \"minecraft:red\": \"Red\",\n        \"minecraft:blue\": \"Blue\",\n        \"minecraft:green\": \"Green\",\n        \"minecraft:cyan\": \"Cyan\",\n        \"minecraft:gray\": \"Gray\"\n    };\n    return variantNames[variantId] || variantId.replace(\"minecraft:\", \"\");\n}\n\n// Run state analysis\nanalyzeParrotBehaviorStates();\n\n// Set up keybind to refresh analysis\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.s\" && e.action === 1) { // S key\n        analyzeParrotBehaviorStates();\n    }\n}));"
      ]
    },
    {
      "name": "isSittingOnShoulder",
      "signature": "isSittingOnShoulder()",
      "returnType": "boolean",
      "description": "Returns whether this parrot is currently perched on any player's shoulder. Tamed parrots can sit on player shoulders, making them portable companions.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive shoulder parrot monitoring and management system\nclass ShoulderParrotManager {\n    constructor() {\n        this.shoulderParrots = new Map(); // Track parrots on shoulders\n        this.parrotHistory = []; // Track shoulder perching history\n        this.lastShoulderCheck = 0;\n        this.shoulderStats = {\n            totalShoulderTime: 0,\n            leftShoulderUses: 0,\n            rightShoulderUses: 0,\n            uniqueParrotsOnShoulder: new Set()\n        };\n    }\n\n    updateShoulderParrots() {\n        const currentTime = Client.getTime();\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        const parrots = World.getEntities(\"minecraft:parrot\");\n        const currentShoulderParrots = new Set();\n\n        parrots.forEach(entity => {\n            const parrot = entity.as(\"minecraft:parrot\");\n            if (parrot.isSittingOnShoulder()) {\n                const uuid = entity.getUUID();\n                const variant = parrot.getVariant();\n                const isTamed = parrot.isTamed();\n                const name = isTamed ? entity.getName().getString() : \"Wild Parrot\";\n\n                currentShoulderParrots.add(uuid);\n\n                // Check if this is a new shoulder parrot\n                if (!this.shoulderParrots.has(uuid)) {\n                    this.handleParrotLandedOnShoulder(entity, parrot, uuid, variant, name, currentTime);\n                } else {\n                    // Update existing shoulder parrot data\n                    const shoulderData = this.shoulderParrots.get(uuid);\n                    shoulderData.lastCheck = currentTime;\n                }\n            } else {\n                // Check if parrot just left shoulder\n                if (this.shoulderParrots.has(entity.getUUID())) {\n                    this.handleParrotLeftShoulder(entity, entity.getUUID(), currentTime);\n                }\n            }\n        });\n\n        // Clean up parrots that are no longer detected on shoulders\n        for (const [uuid, shoulderData] of this.shoulderParrots) {\n            if (!currentShoulderParrots.has(uuid)) {\n                this.handleParrotLeftShoulder(null, uuid, currentTime);\n            }\n        }\n    }\n\n    handleParrotLandedOnShoulder(entity, parrot, uuid, variant, name, currentTime) {\n        const shoulderData = {\n            entity: entity,\n            parrot: parrot,\n            name: name,\n            variant: variant,\n            isTamed: parrot.isTamed(),\n            startTime: currentTime,\n            lastCheck: currentTime\n        };\n\n        this.shoulderParrots.set(uuid, shoulderData);\n        this.shoulderStats.uniqueParrotsOnShoulder.add(uuid);\n\n        Chat.log(`ü¶ú ${name} landed on a player's shoulder!`);\n        Chat.log(`   Variant: ${getVariantDisplayName(variant)}`);\n        Chat.log(`   Tamed: ${shoulderData.isTamed ? \"Yes\" : \"No\"}`);\n\n        // Highlight the parrot if it's visible\n        if (entity) {\n            entity.setGlowing(true);\n            entity.setGlowingColor(0xFFD700); // Gold glow for shoulder parrots\n        }\n\n        this.parrotHistory.push({\n            uuid: uuid,\n            name: name,\n            variant: variant,\n            action: \"landed_on_shoulder\",\n            timestamp: currentTime,\n            details: { isTamed: shoulderData.isTamed }\n        });\n    }\n\n    handleParrotLeftShoulder(entity, uuid, currentTime) {\n        const shoulderData = this.shoulderParrots.get(uuid);\n        if (shoulderData) {\n            const duration = currentTime - shoulderData.startTime;\n\n            Chat.log(`ü¶ú ${shoulderData.name} left player's shoulder after ${duration} ticks (${(duration / 20).toFixed(1)} seconds)`);\n\n            this.shoulderStats.totalShoulderTime += duration;\n\n            // Reset glow if entity is still visible\n            if (entity) {\n                entity.resetGlowing();\n            }\n\n            this.parrotHistory.push({\n                uuid: uuid,\n                name: shoulderData.name,\n                variant: shoulderData.variant,\n                action: \"left_shoulder\",\n                timestamp: currentTime,\n                duration: duration,\n                details: { isTamed: shoulderData.isTamed }\n            });\n\n            this.shoulderParrots.delete(uuid);\n        }\n    }\n\n    generateShoulderReport() {\n        Chat.log(`ü¶ú=== Shoulder Parrot Report ===`);\n        Chat.log(`Currently on shoulders: ${this.shoulderParrots.size} parrot(s)`);\n\n        if (this.shoulderParrots.size > 0) {\n            Chat.log(`\\nüìã Current Shoulder Parrots:`);\n\n            for (const [uuid, shoulderData] of this.shoulderParrots) {\n                const currentDuration = Client.getTime() - shoulderData.startTime;\n                const variantName = getVariantDisplayName(shoulderData.variant);\n\n                Chat.log(`ü¶ú ${shoulderData.name}:`);\n                Chat.log(`   Variant: ${variantName}`);\n                Chat.log(`   Tamed: ${shoulderData.isTamed ? \"Yes\" : \"No\"}`);\n                Chat.log(`   Time on shoulder: ${currentDuration} ticks (${(currentDuration / 20).toFixed(1)} seconds)`);\n                Chat.log(`   Status: Currently riding`);\n\n                if (shoulderData.isTamed) {\n                    Chat.log(`   Owner: ${shoulderData.parrot.getOwner() || \"Unknown\"}`);\n                }\n            }\n        }\n\n        // Historical analysis\n        if (this.parrotHistory.length > 0) {\n            const recentHistory = this.parrotHistory.filter(h =>\n                Client.getTime() - h.timestamp <= 12000 // Last 10 minutes\n            );\n\n            if (recentHistory.length > 0) {\n                Chat.log(`\\nüìä Recent Shoulder Activity (last 10 minutes):`);\n\n                const landingEvents = recentHistory.filter(h => h.action === \"landed_on_shoulder\").length;\n                const leavingEvents = recentHistory.filter(h => h.action === \"left_shoulder\").length;\n\n                Chat.log(`Parrots landed on shoulders: ${landingEvents}`);\n                Chat.log(`Parrots left shoulders: ${leavingEvents}`);\n\n                // Average shoulder time\n                const leftEventsWithDurations = recentHistory.filter(h => h.action === \"left_shoulder\" && h.duration);\n                if (leftEventsWithDurations.length > 0) {\n                    const avgDuration = leftEventsWithDurations.reduce((sum, h) => sum + h.duration, 0) / leftEventsWithDurations.length;\n                    Chat.log(`Average shoulder time: ${(avgDuration / 20).toFixed(1)} seconds`);\n                }\n\n                // Variant analysis\n                const variantCounts = new Map();\n                recentHistory.forEach(h => {\n                    variantCounts.set(h.variant, (variantCounts.get(h.variant) || 0) + 1);\n                });\n\n                if (variantCounts.size > 0) {\n                    Chat.log(`\\nü¶ú Shoulder Variants:`);\n                    for (const [variant, count] of variantCounts) {\n                        const variantName = getVariantDisplayName(variant);\n                        Chat.log(`   ${variantName}: ${count} time(s)`);\n                    }\n                }\n            }\n        }\n\n        // Overall statistics\n        Chat.log(`\\nüìà Overall Statistics:`);\n        Chat.log(`Total unique parrots on shoulders: ${this.shoulderStats.uniqueParrotsOnShoulder.size}`);\n        Chat.log(`Total shoulder time: ${(this.shoulderStats.totalShoulderTime / 20).toFixed(1)} seconds`);\n\n        // Shoulder parrot tips\n        Chat.log(`\\nüí° Shoulder Parrot Tips:`);\n        Chat.log(`- Tamed parrots will sit on player shoulders when close enough`);\n        Chat.log(`- Parrots on shoulders are portable and travel with the player`);\n        Chat.log(`- Parrots may occasionally mimic sounds while on shoulders`);\n        Chat.log(`- Players can have one parrot on each shoulder`);\n        Chat.log(`- Shoulder parrots will dismount when the player enters water or takes damage`);\n        Chat.log(`- Feed seeds to tamed parrots to encourage shoulder behavior`);\n\n        // Taming advice\n        const playerInventory = Player.openInventory();\n        const hasSeeds = playerInventory.getSlots().some(slot =>\n            slot && slot.getId() && (\n                slot.getId().includes(\"seed\") ||\n                slot.getId() === \"minecraft:wheat_seeds\" ||\n                slot.getId() === \"minecraft:melon_seeds\" ||\n                slot.getId() === \"minecraft:pumpkin_seeds\" ||\n                slot.getId() === \"minecraft:beetroot_seeds\"\n            )\n        );\n\n        if (hasSeeds) {\n            Chat.log(`‚úÖ You have seeds - good for taming parrots to get shoulder companions!`);\n        } else {\n            Chat.log(`üå± Get seeds from grass to tame parrots for shoulder companionship`);\n        }\n\n        // Current player shoulder check\n        this.checkPlayerShoulders();\n    }\n\n    checkPlayerShoulders() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        Chat.log(`\\nüë§ Your Shoulder Status:`);\n\n        // Note: In actual implementation, you'd check player shoulder entities\n        // For this example, we'll provide general information\n        const shoulderParrots = this.shoulderParrots.size;\n\n        if (shoulderParrots > 0) {\n            Chat.log(`You have ${shoulderParrots} parrot(s) on nearby players' shoulders`);\n            Chat.log(`Get closer to tamed parrots to have them sit on your shoulders`);\n        } else {\n            Chat.log(`No parrots currently on shoulders in your vicinity`);\n            Chat.log(`Tame some parrots and stay close to them for shoulder companionship`);\n        }\n    }\n\n    highlightShoulderParrots() {\n        Chat.log(`üåü Highlighting ${this.shoulderParrots.size} shoulder parrot(s)`);\n\n        for (const [uuid, shoulderData] of this.shoulderParrots) {\n            if (shoulderData.entity) {\n                // Create rainbow effect for shoulder parrots\n                const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];\n                const colorIndex = Math.floor(Client.getTime() / 20) % colors.length;\n\n                shoulderData.entity.setGlowing(true);\n                shoulderData.entity.setGlowingColor(colors[colorIndex]);\n            }\n        }\n\n        Chat.log(`Shoulder parrots are now highlighted with rainbow colors!`);\n    }\n}\n\nfunction getVariantDisplayName(variantId) {\n    const variantNames = {\n        \"minecraft:red\": \"Red\",\n        \"minecraft:blue\": \"Blue\",\n        \"minecraft:green\": \"Green\",\n        \"minecraft:cyan\": \"Cyan\",\n        \"minecraft:gray\": \"Gray\"\n    };\n    return variantNames[variantId] || variantId.replace(\"minecraft:\", \"\");\n}\n\nconst shoulderManager = new ShoulderParrotManager();\n\n// Monitor shoulder parrots every tick for real-time updates\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    shoulderManager.updateShoulderParrots();\n}));\n\n// Generate shoulder report on keypress\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.h\" && e.action === 1) { // H key\n        shoulderManager.generateShoulderReport();\n    }\n}));\n\n// Highlight shoulder parrots on keypress\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.l\" && e.action === 1) { // L key\n        shoulderManager.highlightShoulderParrots();\n    }\n}));\n\nChat.log(\"ü¶ú Shoulder Parrot Manager activated!\");"
      ]
    }
  ]
}