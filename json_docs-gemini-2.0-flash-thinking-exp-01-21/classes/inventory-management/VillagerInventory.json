{
  "name": "VillagerInventory",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.classes.inventory.VillagerInventory",
  "extends": "Inventory<MerchantScreen>",
  "since": "1.3.1",
  "description": "The `VillagerInventory` class provides specialized access to Minecraft's villager trading interface, allowing scripts to interact with villager trades, experience systems, and merchant mechanics. This class extends the base `Inventory` class and adds villager-specific functionality for managing trades, selecting offers, and monitoring villager progression.",
  "overview": "Villager trading in Minecraft consists of:\n- **Trade Offers:** Available trades that can be selected and executed\n- **Experience System:** Villager gains experience from trades and levels up\n- **Level Progress:** Visual indicator of villager's current level progress\n- **Trade Refreshing:** Ability to refresh trades under certain conditions\n\n## Accessing VillagerInventory\n\nYou typically get `VillagerInventory` instances when the player has a villager trading screen open:\n\n```javascript\n// Check if current screen is a villager\nconst inv = Inventory.create();\nif (inv && inv.getType() === \"Villager\") {\n    const villagerInv = inv; // Already typed as VillagerInventory\n    Chat.log(\"Villager inventory detected!\");\n\n    const trades = villagerInv.getTrades();\n    Chat.log(`Available trades: ${trades.length}`);\n}\n```",
  "constructors": [],
  "methods": [
    {
      "name": "selectTrade",
      "signature": "selectTrade(index: number)",
      "returnType": "void",
      "description": "Selects a trade offer by its index in the villager's trade list.",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "description": "The 0-based index of the trade offer to select."
        }
      ],
      "static": false,
      "examples": [
        "function autoTrade(targetItemId, maxTrades = 10) {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return false;\n    }\n\n    const trades = inv.getTrades();\n    let successfulTrades = 0;\n\n    Chat.log(`Looking for trades involving: ${targetItemId}`);\n\n    for (let i = 0; i < trades.length && successfulTrades < maxTrades; i++) {\n        const trade = trades[i];\n\n        if (!trade.isAvailable()) {\n            continue; // Skip locked trades\n        }\n\n        // Check if trade involves the target item (either as input or output)\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const involvesTarget = inputs.some(item => item.getItemId() === targetItemId) ||\n                              output.getItemId() === targetItemId;\n\n        if (involvesTarget) {\n            // Select the trade\n            inv.selectTrade(i);\n\n            // Get inventory slot mappings for villager interface\n            const slotMap = inv.getMap();\n            const inputSlots = slotMap[\"input\"] || [];\n            const outputSlots = slotMap[\"output\"] || [];\n\n            if (inputSlots.length > 0 && outputSlots.length > 0) {\n                const outputSlot = outputSlots[0];\n                const outputItem = inv.getSlot(outputSlot);\n\n                if (!outputItem.isEmpty()) {\n                    // Check if player has required input items\n                    const hasRequiredItems = inputs.every(inputItem => {\n                        const playerInv = Player.getPlayer().getInventory();\n                        return playerInv.contains(inputItem) ||\n                               inv.contains(inputItem);\n                    });\n\n                    if (hasRequiredItems) {\n                        // Execute the trade by clicking the output slot\n                        inv.click(outputSlot);\n                        successfulTrades++;\n\n                        const inputDesc = inputs.map(item => `${item.getName().getString()} x${item.getCount()}`).join(\" + \");\n                        Chat.log(`Trade ${successfulTrades}: ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n\n                        // Small delay between trades\n                        Client.waitTick();\n                    } else {\n                        Chat.log(`Skipping trade - missing required items: ${inputs.map(i => i.getName().getString()).join(\", \")}`);\n                    }\n                }\n            }\n        }\n    }\n\n    Chat.log(`Auto-trading completed. Executed ${successfulTrades} trades.`);\n    return successfulTrades > 0;\n}\n\n// Example usage - auto-trade with emeralds\nautoTrade(\"minecraft:emerald\", 5);",
        "function smartTradeManager() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const playerInv = Player.getPlayer().getInventory();\n    const emeraldCount = playerInv.count(\"minecraft:emerald\");\n\n    Chat.log(`=== Smart Trade Manager ===`);\n    Chat.log(`Player emeralds: ${emeraldCount}`);\n\n    // Categorize trades\n    const buyingTrades = []; // Player gives items, gets emeralds\n    const sellingTrades = []; // Player gives emeralds, gets items\n\n    trades.forEach((trade, index) => {\n        if (!trade.isAvailable()) return;\n\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n\n        const hasEmeraldInput = inputs.some(item => item.getItemId() === \"minecraft:emerald\");\n        const hasEmeraldOutput = output.getItemId() === \"minecraft:emerald\";\n\n        if (hasEmeraldOutput && !hasEmeraldInput) {\n            buyingTrades.push({ trade, index });\n        } else if (hasEmeraldInput && !hasEmeraldOutput) {\n            sellingTrades.push({ trade, index });\n        }\n    });\n\n    Chat.log(`Found ${buyingTrades.length} buying trades and ${sellingTrades.length} selling trades`);\n\n    // Execute selling trades if player has enough emeralds\n    if (emeraldCount >= 64) {\n        Chat.log(\"Selling excess emeralds for valuable items...\");\n\n        for (const { trade, index } of sellingTrades) {\n            const inputs = trade.getInput();\n            const emeraldCost = inputs.find(item => item.getItemId() === \"minecraft:emerald\")?.getCount() || 0;\n\n            if (emeraldCost <= emeraldCount && trade.isAvailable()) {\n                inv.selectTrade(index);\n\n                const output = trade.getOutput();\n                Chat.log(`Selling: ${emeraldCost} emeralds → ${output.getName().getString()} x${output.getCount()}`);\n\n                // Execute trade\n                const slotMap = inv.getMap();\n                const outputSlot = slotMap[\"output\"]?.[0];\n                if (outputSlot) {\n                    inv.click(outputSlot);\n                    Client.waitTick();\n                }\n            }\n        }\n    }\n\n    // Execute buying trades if player has the required items\n    Chat.log(\"Buying items for emeralds...\");\n\n    for (const { trade, index } of buyingTrades) {\n        const inputs = trade.getInput();\n        const canAfford = inputs.every(input => playerInv.contains(input) || inv.contains(input));\n\n        if (canAfford && trade.isAvailable()) {\n            inv.selectTrade(index);\n\n            const output = trade.getOutput();\n            const inputDesc = inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \");\n            Chat.log(`Buying: ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n\n            // Execute trade\n            const slotMap = inv.getMap();\n            const outputSlot = slotMap[\"output\"]?.[0];\n            if (outputSlot) {\n                inv.click(outputSlot);\n                Client.waitTick();\n            }\n        }\n    }\n\n    // Check for villager level up\n    if (inv.isLeveled()) {\n        Chat.log(\"&a&lVillager can level up! Close and reopen trading to unlock new trades.\");\n    }\n\n    Chat.log(\"Smart trading completed!\");\n}\n\n// Example usage\nsmartTradeManager();"
      ]
    },
    {
      "name": "getTrades",
      "signature": "getTrades(): TradeOffer[]",
      "returnType": "TradeOffer[]",
      "description": "Retrieves a list of all available and locked trade offers from the villager.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Check if current screen is a villager\nconst inv = Inventory.create();\nif (inv && inv.getType() === \"Villager\") {\n    const villagerInv = inv; // Already typed as VillagerInventory\n    Chat.log(\"Villager inventory detected!\");\n\n    const trades = villagerInv.getTrades();\n    Chat.log(`Available trades: ${trades.length}`);\n}",
        "function analyzeVillagerTrades() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const exp = inv.getExperience();\n    const progress = inv.getLevelProgress();\n    const canRefresh = inv.canRefreshTrades();\n    const isLeveled = inv.isLeveled();\n\n    Chat.log(\"=== Villager Information ===\");\n    Chat.log(`Experience: ${exp}`);\n    Chat.log(`Level Progress: ${progress}%`);\n    Chat.log(`Can Refresh Trades: ${canRefresh ? \"Yes\" : \"No\"}`);\n    Chat.log(`Can Level Up: ${isLeveled ? \"Yes\" : \"No\"}`);\n    Chat.log(`Total Trades: ${trades.length}`);\n\n    Chat.log(\"\\n=== Available Trades ===\");\n\n    let availableTrades = 0;\n    let lockedTrades = 0;\n\n    trades.forEach((trade, index) => {\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const available = trade.isAvailable();\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n\n        if (available) {\n            availableTrades++;\n            Chat.log(`${index + 1}. ✓ ${inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \")} → ${output.getName().getString()} x${output.getCount()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses}`);\n        } else {\n            lockedTrades++;\n            Chat.log(`${index + 1}. ✗ [LOCKED] ${inputs.map(i => `${i.getName().getString()}`).join(\" + \")} → ${output.getName().getString()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses} (Locked until restock)`);\n        }\n\n        // Show price adjustments\n        const originalPrice = trade.getOriginalPrice();\n        const adjustedPrice = trade.getAdjustedPrice();\n        if (originalPrice !== adjustedPrice) {\n            const discount = originalPrice - adjustedPrice;\n            Chat.log(`   Price adjustment: ${discount > 0 ? \"+\" : \"\"}${discount} (${discount > 0 ? \"premium\" : \"discount\"})`);\n        }\n    });\n\n    Chat.log(`\\nSummary: ${availableTrades} available, ${lockedTrades} locked trades`);\n}\n\n// Example usage\nanalyagerTrades();",
        "function autoTrade(targetItemId, maxTrades = 10) {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return false;\n    }\n\n    const trades = inv.getTrades();\n    let successfulTrades = 0;\n\n    Chat.log(`Looking for trades involving: ${targetItemId}`);\n\n    for (let i = 0; i < trades.length && successfulTrades < maxTrades; i++) {\n        const trade = trades[i];\n\n        if (!trade.isAvailable()) {\n            continue; // Skip locked trades\n        }\n\n        // Check if trade involves the target item (either as input or output)\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const involvesTarget = inputs.some(item => item.getItemId() === targetItemId) ||\n                              output.getItemId() === targetItemId;\n\n        if (involvesTarget) {\n            // Select the trade\n            inv.selectTrade(i);\n\n            // Get inventory slot mappings for villager interface\n            const slotMap = inv.getMap();\n            const inputSlots = slotMap[\"input\"] || [];\n            const outputSlots = slotMap[\"output\"] || [];\n\n            if (inputSlots.length > 0 && outputSlots.length > 0) {\n                const outputSlot = outputSlots[0];\n                const outputItem = inv.getSlot(outputSlot);\n\n                if (!outputItem.isEmpty()) {\n                    // Check if player has required input items\n                    const hasRequiredItems = inputs.every(inputItem => {\n                        const playerInv = Player.getPlayer().getInventory();\n                        return playerInv.contains(inputItem) ||\n                               inv.contains(inputItem);\n                    });\n\n                    if (hasRequiredItems) {\n                        // Execute the trade by clicking the output slot\n                        inv.click(outputSlot);\n                        successfulTrades++;\n\n                        const inputDesc = inputs.map(item => `${item.getName().getString()} x${item.getCount()}`).join(\" + \");\n                        Chat.log(`Trade ${successfulTrades}: ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n\n                        // Small delay between trades\n                        Client.waitTick();\n                    } else {\n                        Chat.log(`Skipping trade - missing required items: ${inputs.map(i => i.getName().getString()).join(\", \")}`);\n                    }\n                }\n            }\n        }\n    }\n\n    Chat.log(`Auto-trading completed. Executed ${successfulTrades} trades.`);\n    return successfulTrades > 0;\n}\n\n// Example usage - auto-trade with emeralds\nautoTrade(\"minecraft:emerald\", 5);",
        "function monitorVillagerProgress() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let lastExp = inv.getExperience();\n    let lastProgress = inv.getLevelProgress();\n    let tradeCount = 0;\n\n    Chat.log(\"Started villager progress monitoring\");\n\n    const monitor = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(monitor);\n            Chat.log(\"Villager trading closed - monitoring stopped\");\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n        const currentProgress = currentInv.getLevelProgress();\n        const isLeveled = currentInv.isLeveled();\n\n        // Check for experience changes\n        if (currentExp > lastExp) {\n            const expGained = currentExp - lastExp;\n            tradeCount++;\n            Chat.log(`Trade completed! +${expGained} XP (Total: ${currentExp}, Trades: ${tradeCount})`);\n        }\n\n        // Check for level progress changes\n        if (currentProgress !== lastProgress) {\n            Chat.log(`Level progress updated: ${lastProgress}% → ${currentProgress}%`);\n        }\n\n        // Check if villager can level up\n        if (isLeveled && currentProgress >= 100) {\n            Chat.actionbar(\"&a&lVILLAGER CAN LEVEL UP! Close and reopen trading.\");\n            // Play a sound notification if possible\n            Player.getPlayer().playSound(\"entity.villager.yes\", 1.0, 1.0);\n        }\n\n        // Update status display every 20 ticks (1 second)\n        if (tradeCount % 20 === 0) {\n            const trades = currentInv.getTrades();\n            const availableTrades = trades.filter(t => t.isAvailable()).length;\n            const totalTrades = trades.length;\n\n            Chat.actionbar(`&7Villager: &a${currentExp} XP &8| &b${currentProgress}% &8| &f${availableTrades}/${totalTrades} trades &8| &e${tradeCount} completed`);\n        }\n\n        lastExp = currentExp;\n        lastProgress = currentProgress;\n    }));\n}\n\n// Example usage\nmonitorVillagerProgress();",
        "function calculateTradeProfitability() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const playerInv = Player.getPlayer().getInventory();\n\n    Chat.log(\"=== Trade Profitability Analysis ===\");\n\n    trades.forEach((trade, index) => {\n        if (!trade.isAvailable()) {\n            return; // Skip locked trades\n        }\n\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n\n        // Calculate input value (simplified - based on item rarity)\n        let inputValue = 0;\n        inputs.forEach(input => {\n            if (input.getItemId() === \"minecraft:emerald\") {\n                inputValue += input.getCount() * 100; // Emeralds as baseline\n            } else {\n                inputValue += input.getCount() * 10; // Other items as lower value\n            }\n        });\n\n        // Calculate output value\n        let outputValue = 0;\n        if (output.getItemId() === \"minecraft:emerald\") {\n            outputValue += output.getCount() * 100;\n        } else {\n            outputValue += output.getCount() * 15; // Slightly higher for non-emerald outputs\n        }\n\n        const profit = outputValue - inputValue;\n        const profitMargin = inputValue > 0 ? (profit / inputValue) * 100 : 0;\n\n        // Display analysis\n        const inputDesc = inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \");\n\n        Chat.log(`${index + 1}. ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n        Chat.log(`   Input Value: ${inputValue} | Output Value: ${outputValue} | Profit: ${profit > 0 ? \"+\" : \"\"}${profit} (${profitMargin > 0 ? \"+\" : \"\"}${profitMargin.toFixed(1)}%)`);\n\n        // Check if player can afford this trade\n        const canAfford = inputs.every(input => playerInv.contains(input) || inv.contains(input));\n        Chat.log(`   Can afford: ${canAfford ? \"✓ Yes\" : \"✗ No\"}`);\n\n        // Show trade availability info\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n        const remainingUses = maxUses - uses;\n\n        if (remainingUses < maxUses * 0.2) {\n            Chat.log(`   ⚠ Warning: Only ${remainingUses} uses remaining (${(remainingUses/maxUses*100).toFixed(0)}%)`);\n        }\n\n        Chat.log(\"\");\n    });\n}\n\n// Example usage\ncalculateTradeProfitability();",
        "function smartTradeManager() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const playerInv = Player.getPlayer().getInventory();\n    const emeraldCount = playerInv.count(\"minecraft:emerald\");\n\n    Chat.log(`=== Smart Trade Manager ===`);\n    Chat.log(`Player emeralds: ${emeraldCount}`);\n\n    // Categorize trades\n    const buyingTrades = []; // Player gives items, gets emeralds\n    const sellingTrades = []; // Player gives emeralds, gets items\n\n    trades.forEach((trade, index) => {\n        if (!trade.isAvailable()) return;\n\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n\n        const hasEmeraldInput = inputs.some(item => item.getItemId() === \"minecraft:emerald\");\n        const hasEmeraldOutput = output.getItemId() === \"minecraft:emerald\";\n\n        if (hasEmeraldOutput && !hasEmeraldInput) {\n            buyingTrades.push({ trade, index });\n        } else if (hasEmeraldInput && !hasEmeraldOutput) {\n            sellingTrades.push({ trade, index });\n        }\n    });\n\n    Chat.log(`Found ${buyingTrades.length} buying trades and ${sellingTrades.length} selling trades`);\n\n    // Execute selling trades if player has enough emeralds\n    if (emeraldCount >= 64) {\n        Chat.log(\"Selling excess emeralds for valuable items...\");\n\n        for (const { trade, index } of sellingTrades) {\n            const inputs = trade.getInput();\n            const emeraldCost = inputs.find(item => item.getItemId() === \"minecraft:emerald\")?.getCount() || 0;\n\n            if (emeraldCost <= emeraldCount && trade.isAvailable()) {\n                inv.selectTrade(index);\n\n                const output = trade.getOutput();\n                Chat.log(`Selling: ${emeraldCost} emeralds → ${output.getName().getString()} x${output.getCount()}`);\n\n                // Execute trade\n                const slotMap = inv.getMap();\n                const outputSlot = slotMap[\"output\"]?.[0];\n                if (outputSlot) {\n                    inv.click(outputSlot);\n                    Client.waitTick();\n                }\n            }\n        }\n    }\n\n    // Execute buying trades if player has the required items\n    Chat.log(\"Buying items for emeralds...\");\n\n    for (const { trade, index } of buyingTrades) {\n        const inputs = trade.getInput();\n        const canAfford = inputs.every(input => playerInv.contains(input) || inv.contains(input));\n\n        if (canAfford && trade.isAvailable()) {\n            inv.selectTrade(index);\n\n            const output = trade.getOutput();\n            const inputDesc = inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \");\n            Chat.log(`Buying: ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n\n            // Execute trade\n            const slotMap = inv.getMap();\n            const outputSlot = slotMap[\"output\"]?.[0];\n            if (outputSlot) {\n                inv.click(outputSlot);\n                Client.waitTick();\n            }\n        }\n    }\n\n    // Check for villager level up\n    if (inv.isLeveled()) {\n        Chat.log(\"&a&lVillager can level up! Close and reopen trading to unlock new trades.\");\n    }\n\n    Chat.log(\"Smart trading completed!\");\n}\n\n// Example usage\nsmartTradeManager();",
        "function logTradeHistory() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let tradeHistory = [];\n    let lastExp = inv.getExperience();\n\n    Chat.log(\"Started trade history logging\");\n\n    const logger = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(logger);\n\n            // Print final summary\n            Chat.log(\"=== Trade Session Summary ===\");\n            Chat.log(`Total trades executed: ${tradeHistory.length}`);\n\n            const itemTotals = {};\n            tradeHistory.forEach(trade => {\n                const outputKey = `${trade.outputItem} x${trade.outputCount}`;\n                itemTotals[outputKey] = (itemTotals[outputKey] || 0) + 1;\n            });\n\n            Chat.log(\"Items received:\");\n            Object.entries(itemTotals).forEach(([item, count]) => {\n                Chat.log(`  ${item}: ${count} times`);\n            });\n\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n\n        // Detect when a trade occurs (experience increases)\n        if (currentExp > lastExp) {\n            const trades = currentInv.getTrades();\n            const expGained = currentExp - lastExp;\n\n            // Try to identify which trade was executed\n            let executedTrade = null;\n            let maxExpMatch = 0;\n\n            for (const trade of trades) {\n                const tradeExp = trade.getExperience();\n                if (tradeExp === expGained && trade.isAvailable()) {\n                    executedTrade = trade;\n                    break;\n                } else if (tradeExp > maxExpMatch && tradeExp <= expGained) {\n                    executedTrade = trade;\n                    maxExpMatch = tradeExp;\n                }\n            }\n\n            if (executedTrade) {\n                const inputs = executedTrade.getInput();\n                const output = executedTrade.getOutput();\n                const timestamp = new Date().toLocaleTimeString();\n\n                const tradeRecord = {\n                    timestamp,\n                    inputs: inputs.map(i => `${i.getName().getString()} x${i.getCount()}`),\n                    outputItem: output.getName().getString(),\n                    outputCount: output.getCount(),\n                    expGained,\n                    villagerExp: currentExp\n                };\n\n                tradeHistory.push(tradeRecord);\n\n                // Log the trade\n                const inputDesc = tradeRecord.inputs.join(\" + \");\n                Chat.log(`[${timestamp}] Trade: ${inputDesc} → ${tradeRecord.outputItem} x${tradeRecord.outputCount} (+${expGained} XP, Villager: ${currentExp})`);\n            }\n\n            lastExp = currentExp;\n        }\n    }));\n}\n\n// Example usage\nlogTradeHistory();"
      ]
    },
    {
      "name": "getExperience",
      "signature": "getExperience(): number",
      "returnType": "number",
      "description": "Returns the current experience points of the villager.",
      "parameters": [],
      "static": false,
      "examples": [
        "function analyzeVillagerTrades() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const exp = inv.getExperience();\n    const progress = inv.getLevelProgress();\n    const canRefresh = inv.canRefreshTrades();\n    const isLeveled = inv.isLeveled();\n\n    Chat.log(\"=== Villager Information ===\");\n    Chat.log(`Experience: ${exp}`);\n    Chat.log(`Level Progress: ${progress}%`);\n    Chat.log(`Can Refresh Trades: ${canRefresh ? \"Yes\" : \"No\"}`);\n    Chat.log(`Can Level Up: ${isLeveled ? \"Yes\" : \"No\"}`);\n    Chat.log(`Total Trades: ${trades.length}`);\n\n    Chat.log(\"\\n=== Available Trades ===\");\n\n    let availableTrades = 0;\n    let lockedTrades = 0;\n\n    trades.forEach((trade, index) => {\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const available = trade.isAvailable();\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n\n        if (available) {\n            availableTrades++;\n            Chat.log(`${index + 1}. ✓ ${inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \")} → ${output.getName().getString()} x${output.getCount()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses}`);\n        } else {\n            lockedTrades++;\n            Chat.log(`${index + 1}. ✗ [LOCKED] ${inputs.map(i => `${i.getName().getString()}`).join(\" + \")} → ${output.getName().getString()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses} (Locked until restock)`);\n        }\n\n        // Show price adjustments\n        const originalPrice = trade.getOriginalPrice();\n        const adjustedPrice = trade.getAdjustedPrice();\n        if (originalPrice !== adjustedPrice) {\n            const discount = originalPrice - adjustedPrice;\n            Chat.log(`   Price adjustment: ${discount > 0 ? \"+\" : \"\"}${discount} (${discount > 0 ? \"premium\" : \"discount\"})`);\n        }\n    });\n\n    Chat.log(`\\nSummary: ${availableTrades} available, ${lockedTrades} locked trades`);\n}\n\n// Example usage\nanalyzeVillagerTrades();",
        "function monitorVillagerProgress() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let lastExp = inv.getExperience();\n    let lastProgress = inv.getLevelProgress();\n    let tradeCount = 0;\n\n    Chat.log(\"Started villager progress monitoring\");\n\n    const monitor = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(monitor);\n            Chat.log(\"Villager trading closed - monitoring stopped\");\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n        const currentProgress = currentInv.getLevelProgress();\n        const isLeveled = currentInv.isLeveled();\n\n        // Check for experience changes\n        if (currentExp > lastExp) {\n            const expGained = currentExp - lastExp;\n            tradeCount++;\n            Chat.log(`Trade completed! +${expGained} XP (Total: ${currentExp}, Trades: ${tradeCount})`);\n        }\n\n        // Check for level progress changes\n        if (currentProgress !== lastProgress) {\n            Chat.log(`Level progress updated: ${lastProgress}% → ${currentProgress}%`);\n        }\n\n        // Check if villager can level up\n        if (isLeveled && currentProgress >= 100) {\n            Chat.actionbar(\"&a&lVILLAGER CAN LEVEL UP! Close and reopen trading.\");\n            // Play a sound notification if possible\n            Player.getPlayer().playSound(\"entity.villager.yes\", 1.0, 1.0);\n        }\n\n        // Update status display every 20 ticks (1 second)\n        if (tradeCount % 20 === 0) {\n            const trades = currentInv.getTrades();\n            const availableTrades = trades.filter(t => t.isAvailable()).length;\n            const totalTrades = trades.length;\n\n            Chat.actionbar(`&7Villager: &a${currentExp} XP &8| &b${currentProgress}% &8| &f${availableTrades}/${totalTrades} trades &8| &e${tradeCount} completed`);\n        }\n\n        lastExp = currentExp;\n        lastProgress = currentProgress;\n    }));\n}\n\n// Example usage\nmonitorVillagerProgress();",
        "function logTradeHistory() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let tradeHistory = [];\n    let lastExp = inv.getExperience();\n\n    Chat.log(\"Started trade history logging\");\n\n    const logger = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(logger);\n\n            // Print final summary\n            Chat.log(\"=== Trade Session Summary ===\");\n            Chat.log(`Total trades executed: ${tradeHistory.length}`);\n\n            const itemTotals = {};\n            tradeHistory.forEach(trade => {\n                const outputKey = `${trade.outputItem} x${trade.outputCount}`;\n                itemTotals[outputKey] = (itemTotals[outputKey] || 0) + 1;\n            });\n\n            Chat.log(\"Items received:\");\n            Object.entries(itemTotals).forEach(([item, count]) => {\n                Chat.log(`  ${item}: ${count} times`);\n            });\n\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n\n        // Detect when a trade occurs (experience increases)\n        if (currentExp > lastExp) {\n            const trades = currentInv.getTrades();\n            const expGained = currentExp - lastExp;\n\n            // Try to identify which trade was executed\n            let executedTrade = null;\n            let maxExpMatch = 0;\n\n            for (const trade of trades) {\n                const tradeExp = trade.getExperience();\n                if (tradeExp === expGained && trade.isAvailable()) {\n                    executedTrade = trade;\n                    break;\n                } else if (tradeExp > maxExpMatch && tradeExp <= expGained) {\n                    executedTrade = trade;\n                    maxExpMatch = tradeExp;\n                }\n            }\n\n            if (executedTrade) {\n                const inputs = executedTrade.getInput();\n                const output = executedTrade.getOutput();\n                const timestamp = new Date().toLocaleTimeString();\n\n                const tradeRecord = {\n                    timestamp,\n                    inputs: inputs.map(i => `${i.getName().getString()} x${i.getCount()}`),\n                    outputItem: output.getName().getString(),\n                    outputCount: output.getCount(),\n                    expGained,\n                    villagerExp: currentExp\n                };\n\n                tradeHistory.push(tradeRecord);\n\n                // Log the trade\n                const inputDesc = tradeRecord.inputs.join(\" + \");\n                Chat.log(`[${timestamp}] Trade: ${inputDesc} → ${tradeRecord.outputItem} x${tradeRecord.outputCount} (+${expGained} XP, Villager: ${currentExp})`);\n            }\n\n            lastExp = currentExp;\n        }\n    }));\n}\n\n// Example usage\nlogTradeHistory();"
      ]
    },
    {
      "name": "getLevelProgress",
      "signature": "getLevelProgress(): number",
      "returnType": "number",
      "description": "Retrieves the villager's current level progress as a percentage (0-100).",
      "parameters": [],
      "static": false,
      "examples": [
        "function analyzeVillagerTrades() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const exp = inv.getExperience();\n    const progress = inv.getLevelProgress();\n    const canRefresh = inv.canRefreshTrades();\n    const isLeveled = inv.isLeveled();\n\n    Chat.log(\"=== Villager Information ===\");\n    Chat.log(`Experience: ${exp}`);\n    Chat.log(`Level Progress: ${progress}%`);\n    Chat.log(`Can Refresh Trades: ${canRefresh ? \"Yes\" : \"No\"}`);\n    Chat.log(`Can Level Up: ${isLeveled ? \"Yes\" : \"No\"}`);\n    Chat.log(`Total Trades: ${trades.length}`);\n\n    Chat.log(\"\\n=== Available Trades ===\");\n\n    let availableTrades = 0;\n    let lockedTrades = 0;\n\n    trades.forEach((trade, index) => {\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const available = trade.isAvailable();\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n\n        if (available) {\n            availableTrades++;\n            Chat.log(`${index + 1}. ✓ ${inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \")} → ${output.getName().getString()} x${output.getCount()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses}`);\n        } else {\n            lockedTrades++;\n            Chat.log(`${index + 1}. ✗ [LOCKED] ${inputs.map(i => `${i.getName().getString()}`).join(\" + \")} → ${output.getName().getString()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses} (Locked until restock)`);\n        }\n\n        // Show price adjustments\n        const originalPrice = trade.getOriginalPrice();\n        const adjustedPrice = trade.getAdjustedPrice();\n        if (originalPrice !== adjustedPrice) {\n            const discount = originalPrice - adjustedPrice;\n            Chat.log(`   Price adjustment: ${discount > 0 ? \"+\" : \"\"}${discount} (${discount > 0 ? \"premium\" : \"discount\"})`);\n        }\n    });\n\n    Chat.log(`\\nSummary: ${availableTrades} available, ${lockedTrades} locked trades`);\n}\n\n// Example usage\nanalyzeVillagerTrades();",
        "function monitorVillagerProgress() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let lastExp = inv.getExperience();\n    let lastProgress = inv.getLevelProgress();\n    let tradeCount = 0;\n\n    Chat.log(\"Started villager progress monitoring\");\n\n    const monitor = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(monitor);\n            Chat.log(\"Villager trading closed - monitoring stopped\");\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n        const currentProgress = currentInv.getLevelProgress();\n        const isLeveled = currentInv.isLeveled();\n\n        // Check for experience changes\n        if (currentExp > lastExp) {\n            const expGained = currentExp - lastExp;\n            tradeCount++;\n            Chat.log(`Trade completed! +${expGained} XP (Total: ${currentExp}, Trades: ${tradeCount})`);\n        }\n\n        // Check for level progress changes\n        if (currentProgress !== lastProgress) {\n            Chat.log(`Level progress updated: ${lastProgress}% → ${currentProgress}%`);\n        }\n\n        // Check if villager can level up\n        if (isLeveled && currentProgress >= 100) {\n            Chat.actionbar(\"&a&lVILLAGER CAN LEVEL UP! Close and reopen trading.\");\n            // Play a sound notification if possible\n            Player.getPlayer().playSound(\"entity.villager.yes\", 1.0, 1.0);\n        }\n\n        // Update status display every 20 ticks (1 second)\n        if (tradeCount % 20 === 0) {\n            const trades = currentInv.getTrades();\n            const availableTrades = trades.filter(t => t.isAvailable()).length;\n            const totalTrades = trades.length;\n\n            Chat.actionbar(`&7Villager: &a${currentExp} XP &8| &b${currentProgress}% &8| &f${availableTrades}/${totalTrades} trades &8| &e${tradeCount} completed`);\n        }\n\n        lastExp = currentExp;\n        lastProgress = currentProgress;\n    }));\n}\n\n// Example usage\nmonitorVillagerProgress();"
      ]
    },
    {
      "name": "getMerchantRewardedExperience",
      "signature": "getMerchantRewardedExperience(): number",
      "returnType": "number",
      "description": "Returns the amount of experience a merchant receives for the currently selected trade.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "canRefreshTrades",
      "signature": "canRefreshTrades(): boolean",
      "returnType": "boolean",
      "description": "Checks if the villager's trades can be refreshed (e.g., after a restock).",
      "parameters": [],
      "static": false,
      "examples": [
        "function analyzeVillagerTrades() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const exp = inv.getExperience();\n    const progress = inv.getLevelProgress();\n    const canRefresh = inv.canRefreshTrades();\n    const isLeveled = inv.isLeveled();\n\n    Chat.log(\"=== Villager Information ===\");\n    Chat.log(`Experience: ${exp}`);\n    Chat.log(`Level Progress: ${progress}%`);\n    Chat.log(`Can Refresh Trades: ${canRefresh ? \"Yes\" : \"No\"}`);\n    Chat.log(`Can Level Up: ${isLeveled ? \"Yes\" : \"No\"}`);\n    Chat.log(`Total Trades: ${trades.length}`);\n\n    Chat.log(\"\\n=== Available Trades ===\");\n\n    let availableTrades = 0;\n    let lockedTrades = 0;\n\n    trades.forEach((trade, index) => {\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const available = trade.isAvailable();\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n\n        if (available) {\n            availableTrades++;\n            Chat.log(`${index + 1}. ✓ ${inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \")} → ${output.getName().getString()} x${output.getCount()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses}`);\n        } else {\n            lockedTrades++;\n            Chat.log(`${index + 1}. ✗ [LOCKED] ${inputs.map(i => `${i.getName().getString()}`).join(\" + \")} → ${output.getName().getString()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses} (Locked until restock)`);\n        }\n\n        // Show price adjustments\n        const originalPrice = trade.getOriginalPrice();\n        const adjustedPrice = trade.getAdjustedPrice();\n        if (originalPrice !== adjustedPrice) {\n            const discount = originalPrice - adjustedPrice;\n            Chat.log(`   Price adjustment: ${discount > 0 ? \"+\" : \"\"}${discount} (${discount > 0 ? \"premium\" : \"discount\"})`);\n        }\n    });\n\n    Chat.log(`\\nSummary: ${availableTrades} available, ${lockedTrades} locked trades`);\n}\n\n// Example usage\nanalyzeVillagerTrades();"
      ]
    },
    {
      "name": "isLeveled",
      "signature": "isLeveled(): boolean",
      "returnType": "boolean",
      "description": "Indicates if the villager has gained enough experience to level up.",
      "parameters": [],
      "static": false,
      "examples": [
        "function analyzeVillagerTrades() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const exp = inv.getExperience();\n    const progress = inv.getLevelProgress();\n    const canRefresh = inv.canRefreshTrades();\n    const isLeveled = inv.isLeveled();\n\n    Chat.log(\"=== Villager Information ===\");\n    Chat.log(`Experience: ${exp}`);\n    Chat.log(`Level Progress: ${progress}%`);\n    Chat.log(`Can Refresh Trades: ${canRefresh ? \"Yes\" : \"No\"}`);\n    Chat.log(`Can Level Up: ${isLeveled ? \"Yes\" : \"No\"}`);\n    Chat.log(`Total Trades: ${trades.length}`);\n\n    Chat.log(\"\\n=== Available Trades ===\");\n\n    let availableTrades = 0;\n    let lockedTrades = 0;\n\n    trades.forEach((trade, index) => {\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n        const available = trade.isAvailable();\n        const uses = trade.getUses();\n        const maxUses = trade.getMaxUses();\n\n        if (available) {\n            availableTrades++;\n            Chat.log(`${index + 1}. ✓ ${inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \")} → ${output.getName().getString()} x${output.getCount()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses}`);\n        } else {\n            lockedTrades++;\n            Chat.log(`${index + 1}. ✗ [LOCKED] ${inputs.map(i => `${i.getName().getString()}`).join(\" + \")} → ${output.getName().getString()}`);\n            Chat.log(`   Uses: ${uses}/${maxUses} (Locked until restock)`);\n        }\n\n        // Show price adjustments\n        const originalPrice = trade.getOriginalPrice();\n        const adjustedPrice = trade.getAdjustedPrice();\n        if (originalPrice !== adjustedPrice) {\n            const discount = originalPrice - adjustedPrice;\n            Chat.log(`   Price adjustment: ${discount > 0 ? \"+\" : \"\"}${discount} (${discount > 0 ? \"premium\" : \"discount\"})`);\n        }\n    });\n\n    Chat.log(`\\nSummary: ${availableTrades} available, ${lockedTrades} locked trades`);\n}\n\n// Example usage\nanalyzeVillagerTrades();",
        "function monitorVillagerProgress() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    let lastExp = inv.getExperience();\n    let lastProgress = inv.getLevelProgress();\n    let tradeCount = 0;\n\n    Chat.log(\"Started villager progress monitoring\");\n\n    const monitor = JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync(() => {\n        const currentInv = Inventory.create();\n\n        if (!currentInv || !currentInv.is(\"Villager\")) {\n            JsMacros.off(monitor);\n            Chat.log(\"Villager trading closed - monitoring stopped\");\n            return;\n        }\n\n        const currentExp = currentInv.getExperience();\n        const currentProgress = currentInv.getLevelProgress();\n        const isLeveled = currentInv.isLeveled();\n\n        // Check for experience changes\n        if (currentExp > lastExp) {\n            const expGained = currentExp - lastExp;\n            tradeCount++;\n            Chat.log(`Trade completed! +${expGained} XP (Total: ${currentExp}, Trades: ${tradeCount})`);\n        }\n\n        // Check for level progress changes\n        if (currentProgress !== lastProgress) {\n            Chat.log(`Level progress updated: ${lastProgress}% → ${currentProgress}%`);\n        }\n\n        // Check if villager can level up\n        if (isLeveled && currentProgress >= 100) {\n            Chat.actionbar(\"&a&lVILLAGER CAN LEVEL UP! Close and reopen trading.\");\n            // Play a sound notification if possible\n            Player.getPlayer().playSound(\"entity.villager.yes\", 1.0, 1.0);\n        }\n\n        // Update status display every 20 ticks (1 second)\n        if (tradeCount % 20 === 0) {\n            const trades = currentInv.getTrades();\n            const availableTrades = trades.filter(t => t.isAvailable()).length;\n            const totalTrades = trades.length;\n\n            Chat.actionbar(`&7Villager: &a${currentExp} XP &8| &b${currentProgress}% &8| &f${availableTrades}/${totalTrades} trades &8| &e${tradeCount} completed`);\n        }\n\n        lastExp = currentExp;\n        lastProgress = currentProgress;\n    }));\n}\n\n// Example usage\nmonitorVillagerProgress();",
        "function smartTradeManager() {\n    const inv = Inventory.create();\n\n    if (!inv || !inv.is(\"Villager\")) {\n        Chat.log(\"Please open a villager trading interface first\");\n        return;\n    }\n\n    const trades = inv.getTrades();\n    const playerInv = Player.getPlayer().getInventory();\n    const emeraldCount = playerInv.count(\"minecraft:emerald\");\n\n    Chat.log(`=== Smart Trade Manager ===`);\n    Chat.log(`Player emeralds: ${emeraldCount}`);\n\n    // Categorize trades\n    const buyingTrades = []; // Player gives items, gets emeralds\n    const sellingTrades = []; // Player gives emeralds, gets items\n\n    trades.forEach((trade, index) => {\n        if (!trade.isAvailable()) return;\n\n        const inputs = trade.getInput();\n        const output = trade.getOutput();\n\n        const hasEmeraldInput = inputs.some(item => item.getItemId() === \"minecraft:emerald\");\n        const hasEmeraldOutput = output.getItemId() === \"minecraft:emerald\";\n\n        if (hasEmeraldOutput && !hasEmeraldInput) {\n            buyingTrades.push({ trade, index });\n        } else if (hasEmeraldInput && !hasEmeraldOutput) {\n            sellingTrades.push({ trade, index });\n        }\n    });\n\n    Chat.log(`Found ${buyingTrades.length} buying trades and ${sellingTrades.length} selling trades`);\n\n    // Execute selling trades if player has enough emeralds\n    if (emeraldCount >= 64) {\n        Chat.log(\"Selling excess emeralds for valuable items...\");\n\n        for (const { trade, index } of sellingTrades) {\n            const inputs = trade.getInput();\n            const emeraldCost = inputs.find(item => item.getItemId() === \"minecraft:emerald\")?.getCount() || 0;\n\n            if (emeraldCost <= emeraldCount && trade.isAvailable()) {\n                inv.selectTrade(index);\n\n                const output = trade.getOutput();\n                Chat.log(`Selling: ${emeraldCost} emeralds → ${output.getName().getString()} x${output.getCount()}`);\n\n                // Execute trade\n                const slotMap = inv.getMap();\n                const outputSlot = slotMap[\"output\"]?.[0];\n                if (outputSlot) {\n                    inv.click(outputSlot);\n                    Client.waitTick();\n                }\n            }\n        }\n    }\n\n    // Execute buying trades if player has the required items\n    Chat.log(\"Buying items for emeralds...\");\n\n    for (const { trade, index } of buyingTrades) {\n        const inputs = trade.getInput();\n        const canAfford = inputs.every(input => playerInv.contains(input) || inv.contains(input));\n\n        if (canAfford && trade.isAvailable()) {\n            inv.selectTrade(index);\n\n            const output = trade.getOutput();\n            const inputDesc = inputs.map(i => `${i.getName().getString()} x${i.getCount()}`).join(\" + \");\n            Chat.log(`Buying: ${inputDesc} → ${output.getName().getString()} x${output.getCount()}`);\n\n            // Execute trade\n            const slotMap = inv.getMap();\n            const outputSlot = slotMap[\"output\"]?.[0];\n            if (outputSlot) {\n                inv.click(outputSlot);\n                Client.waitTick();\n            }\n        }\n    }\n\n    // Check for villager level up\n    if (inv.isLeveled()) {\n        Chat.log(\"&a&lVillager can level up! Close and reopen trading to unlock new trades.\");\n    }\n\n    Chat.log(\"Smart trading completed!\");\n}\n\n// Example usage\nsmartTradeManager();"
      ]
    }
  ]
}