{
  "name": "sortFile",
  "fullClassName": "xyz.wagyourl.jsmacros.client.gui.overlays.FileChooser.sortFile",
  "extends": "Comparator<File>",
  "since": "JsMacros 1.0.0",
  "description": "The `FileChooser.sortFile` class is a specialized comparator that provides intelligent file sorting functionality for the FileChooser component. It implements a hierarchical sorting strategy that prioritizes directories over files while maintaining alphabetical ordering within each category. This sorting approach ensures an intuitive and user-friendly file browsing experience by presenting directories first, followed by files, both sorted alphabetically.",
  "overview": "The `sortFile` class implements Java's `Comparator<File>` interface to provide a consistent and predictable sorting order for file listings in JSMacros' FileChooser interface. The sorting logic follows a user-friendly pattern commonly found in file explorers and operating systems:\n\n1. **Directory Priority**: Directories are always displayed before files, regardless of their names\n2. **Alphabetical Ordering**: Within each category (directories or files), items are sorted alphabetically by name\n3. **Case Sensitivity**: Uses Java's default string comparison, which is case-sensitive\n4. **Natural Ordering**: Provides the expected behavior users anticipate from file browsers\n\nThis comparator is essential for creating an organized and navigable file interface where users can easily locate directories and files in a logical order.",
  "constructors": [
    {
      "signature": "new FileChooser.sortFile()",
      "description": "Creates a new instance of the sortFile comparator.",
      "parameters": [],
      "examples": [
        "// Create a new comparator instance\nconst fileSorter = new FileChooser.sortFile();"
      ]
    }
  ],
  "methods": [
    {
      "name": "compare",
      "signature": "compare(a, b)",
      "returnType": "int",
      "description": "Compares two File objects to determine their sorting order. This method implements the core sorting logic of the comparator.\n\nSorting Logic:\n1. If one file is a directory and the other is not, the directory comes first\n2. If both files are directories or both are regular files, they are sorted alphabetically by name",
      "parameters": [
        {
          "name": "a",
          "type": "File",
          "description": "The first file to compare"
        },
        {
          "name": "b",
          "type": "File",
          "description": "The second file to compare"
        }
      ],
      "static": false,
      "examples": [
        "const sorter = new FileChooser.sortFile();\n\n// Compare two files\nconst file1 = new File(\"/path/to/file.txt\");\nconst file2 = new File(\"/path/to/another.txt\");\nconst result = sorter.compare(file1, file2);\n\nif (result < 0) {\n    Chat.log(\"file1 comes before file2\");\n} else if (result > 0) {\n    Chat.log(\"file1 comes after file2\");\n} else {\n    Chat.log(\"file1 and file2 are equal in order\");\n}",
        "const sorter = new FileChooser.sortFile();\nconst directory = new File(\"/path/documents\");\nconst file = new File(\"/path/document.txt\");\n\n// Returns negative value (directory comes first)\nconst result = sorter.compare(directory, file);\nChat.log(`Directory vs File: ${result < 0 ? \"Directory first\" : \"File first\"}`);",
        "const sorter = new FileChooser.sortFile();\n\n// Comparing two files\nconst fileA = new File(\"/path/apple.txt\");\nconst fileB = new File(\"/path/banana.txt\");\nChat.log(`File comparison: ${sorter.compare(fileA, fileB) < 0 ? \"apple.txt comes first\" : \"banana.txt comes first\"}`);",
        "// Comparing two directories\nconst dirA = new File(\"/path/archive\");\nconst dirB = new File(\"/path/backup\");\nChat.log(`Directory comparison: ${sorter.compare(dirA, dirB) < 0 ? \"archive comes first\" : \"backup comes first\"}`);",
        "const sorter = new FileChooser.sortFile();\n\n// Uppercase letters come before lowercase in ASCII ordering\nconst upperFile = new File(\"/path/Zeus.txt\");\nconst lowerFile = new File(\"/path/apple.txt\");\nChat.log(`Case sensitive: ${sorter.compare(upperFile, lowerFile) < 0 ? \"Zeus comes before apple\" : \"apple comes before Zeus\"}`);",
        "function sortFileList(directory) {\n    const sorter = new FileChooser.sortFile();\n    const files = directory.listFiles();\n\n    if (files) {\n        // Convert Java array to JavaScript array for easier manipulation\n        const fileList = Array.from(files);\n\n        // Sort using the FileChooser.sortFile comparator\n        fileList.sort(sorter);\n\n        // Display the sorted results\n        Chat.log(\"¬ß6Sorted File List:\");\n        fileList.forEach((file, index) => {\n            const type = file.isDirectory() ? \"¬ße[DIR]\" : \"¬ßf[FILE]\";\n            const name = file.getName();\n            Chat.log(`${(index + 1).toString().padStart(3, \" \")}. ${type} ${name}`);\n        });\n    }\n}\n\n// Usage\nconst macroFolder = JsMacros.getFile(\"macros\").getFile();\nsortFileList(macroFolder);",
        "function createCustomFileBrowser(startDirectory) {\n    const sorter = new FileChooser.sortFile();\n\n    return {\n        currentDirectory: startDirectory,\n\n        getSortedFiles: function() {\n            const files = this.currentDirectory.listFiles();\n            if (!files) return [];\n\n            const fileList = Array.from(files);\n            fileList.sort(sorter);\n\n            return fileList.map(file => ({\n                name: file.getName(),\n                isDirectory: file.isDirectory(),\n                size: file.isDirectory() ? null : file.length(),\n                lastModified: new Date(file.lastModified()),\n                file: file\n            }));\n        },\n\n        navigateToDirectory: function(directory) {\n            if (directory && directory.isDirectory()) {\n                this.currentDirectory = directory;\n                Chat.log(`¬ßaNavigated to: ¬ßf${directory.getAbsolutePath()}`);\n                this.displayContents();\n            } else {\n                Chat.log(`¬ßcInvalid directory: ${directory}`);\n            }\n        },\n\n        displayContents: function() {\n            const sortedFiles = this.getSortedFiles();\n\n            Chat.log(`¬ß7=== Contents of ${this.currentDirectory.getName()} ===`);\n            Chat.log(`¬ß7Total items: ${sortedFiles.length}`);\n\n            // Display directories\n            const directories = sortedFiles.filter(item => item.isDirectory);\n            if (directories.length > 0) {\n                Chat.log(`¬ßeDirectories (${directories.length}):`);\n                directories.forEach(dir => {\n                    Chat.log(`  ¬ßeüìÅ ${dir.name}`);\n                });\n            }\n\n            // Display files\n            const files = sortedFiles.filter(item => !item.isDirectory);\n            if (files.length > 0) {\n                Chat.log(`¬ßfFiles (${files.length}):`);\n                files.forEach(file => {\n                    const size = file.size ? `${(file.size / 1024).toFixed(2)} KB` : \"N/A\";\n                    Chat.log(`  ¬ßfüìÑ ${file.name} ¬ß7(${size})`);\n                });\n            }\n        },\n\n        // Navigate to parent directory\n        goBack: function() {\n            const parent = this.currentDirectory.getParentFile();\n            if (parent && !parent.equals(this.currentDirectory)) {\n                this.navigateToDirectory(parent);\n            } else {\n                Chat.log(\"¬ßcAlready at root directory\");\n            }\n        }\n    };\n}\n\n// Usage example\nconst browser = createCustomFileBrowser(JsMacros.getFile(\"macros\").getFile());\nbrowser.displayContents();\n\n// Navigate to a subdirectory (if it exists)\n// browser.navigateToDirectory(new File(browser.currentDirectory, \"scripts\"));",
        "function analyzeDirectoryStructure(directory) {\n    const sorter = new FileChooser.sortFile();\n    const files = directory.listFiles();\n\n    if (!files) return null;\n\n    const fileList = Array.from(files);\n    fileList.sort(sorter);\n\n    const analysis = {\n        totalItems: fileList.length,\n        directories: 0,\n        regularFiles: 0,\n        totalSize: 0,\n        largestFile: null,\n        smallestFile: null,\n        newestFile: null,\n        oldestFile: null,\n        items: []\n    };\n\n    fileList.forEach(file => {\n        const itemInfo = {\n            name: file.getName(),\n            isDirectory: file.isDirectory(),\n            size: file.isDirectory() ? 0 : file.length(),\n            lastModified: file.lastModified()\n        };\n\n        analysis.items.push(itemInfo);\n\n        if (file.isDirectory()) {\n            analysis.directories++;\n        } else {\n            analysis.regularFiles++;\n            analysis.totalSize += file.length();\n\n            // Track largest and smallest files\n            if (!analysis.largestFile || file.length() > analysis.largestFile.size) {\n                analysis.largestFile = itemInfo;\n            }\n            if (!analysis.smallestFile || file.length() < analysis.smallestFile.size) {\n                analysis.smallestFile = itemInfo;\n            }\n\n            // Track newest and oldest files\n            if (!analysis.newestFile || file.lastModified() > analysis.newestFile.lastModified) {\n                analysis.newestFile = itemInfo;\n            }\n            if (!analysis.oldestFile || file.lastModified() < analysis.oldestFile.lastModified) {\n                analysis.oldestFile = itemInfo;\n            }\n        }\n    });\n\n    return analysis;\n}\n\nfunction displayDirectoryAnalysis(directory) {\n    const analysis = analyzeDirectoryStructure(directory);\n    if (!analysis) {\n        Chat.log(\"¬ßcFailed to analyze directory\");\n        return;\n    }\n\n    Chat.log(`¬ß6=== Directory Analysis: ${directory.getName()} ===`);\n    Chat.log(`¬ß7Total items: ¬ßf${analysis.totalItems}`);\n    Chat.log(`¬ß7Directories: ¬ße${analysis.directories}`);\n    Chat.log(`¬ß7Files: ¬ßf${analysis.regularFiles}`);\n    Chat.log(`¬ß7Total size: ¬ßf${(analysis.totalSize / 1024 / 1024).toFixed(2)} MB`);\n\n    if (analysis.largestFile) {\n        Chat.log(`¬ß7Largest file: ¬ßf${analysis.largestFile.name} ¬ß7(${(analysis.largestFile.size / 1024).toFixed(2)} KB)`);\n    }\n    if (analysis.smallestFile) {\n        Chat.log(`¬ß7Smallest file: ¬ßf${analysis.smallestFile.name} ¬ß7(${analysis.smallestFile.size} bytes)`);\n    }\n    if (analysis.newestFile) {\n        Chat.log(`¬ß7Newest file: ¬ßf${analysis.newestFile.name} ¬ß7(${new Date(analysis.newestFile.lastModified).toLocaleDateString()})`);\n    }\n    if (analysis.oldestFile) {\n        Chat.log(`¬ß7Oldest file: ¬ßf${analysis.oldestFile.name} ¬ß7(${new Date(analysis.oldestFile.lastModified).toLocaleDateString()})`);\n    }\n\n    // Show first few items in sorted order\n    Chat.log(`¬ß7First 10 items (sorted):`);\n    analysis.items.slice(0, 10).forEach((item, index) => {\n        const icon = item.isDirectory ? \"üìÅ\" : \"üìÑ\";\n        const type = item.isDirectory ? \"¬ße\" : \"¬ßf\";\n        Chat.log(`  ${type}${icon} ${item.name}`);\n    });\n}\n\n// Usage\nconst macroFolder = JsMacros.getFile(\"macros\").getFile();\ndisplayDirectoryAnalysis(macroFolder);",
        "function buildDirectoryTree(directory, maxDepth = 3, currentDepth = 0) {\n    const sorter = new FileChooser.sortFile();\n\n    if (currentDepth >= maxDepth) {\n        return null;\n    }\n\n    const files = directory.listFiles();\n    if (!files) return null;\n\n    const fileList = Array.from(files);\n    fileList.sort(sorter);\n\n    const tree = {\n        name: directory.getName(),\n        path: directory.getAbsolutePath(),\n        isDirectory: true,\n        children: [],\n        fileCount: 0,\n        directoryCount: 0\n    };\n\n    fileList.forEach(file => {\n        if (file.isDirectory()) {\n            tree.directoryCount++;\n            const subtree = buildDirectoryTree(file, maxDepth, currentDepth + 1);\n            if (subtree) {\n                tree.children.push(subtree);\n                tree.fileCount += subtree.fileCount;\n                tree.directoryCount += subtree.directoryCount;\n            }\n        } else {\n            tree.fileCount++;\n            tree.children.push({\n                name: file.getName(),\n                path: file.getAbsolutePath(),\n                isDirectory: false,\n                size: file.length(),\n                lastModified: file.lastModified()\n            });\n        }\n    });\n\n    return tree;\n}\n\nfunction displayDirectoryTree(tree, prefix = \"\", isLast = true) {\n    if (!tree) return;\n\n    const connector = isLast ? \"‚îî‚îÄ‚îÄ \" : \"‚îú‚îÄ‚îÄ \";\n    const icon = tree.isDirectory ? \"üìÅ\" : \"üìÑ\";\n    const color = tree.isDirectory ? \"¬ße\" : \"¬ßf\";\n\n    Chat.log(`${prefix}${connector}${color}${icon} ${tree.name}`);\n\n    if (tree.isDirectory && tree.children.length > 0) {\n        const newPrefix = prefix + (isLast ? \"    \" : \"‚îÇ   \");\n        tree.children.forEach((child, index) => {\n            const isLastChild = index === tree.children.length - 1;\n            displayDirectoryTree(child, newPrefix, isLastChild);\n        });\n    }\n}\n\nfunction showDirectoryTree(directory, maxDepth = 2) {\n    const tree = buildDirectoryTree(directory, maxDepth);\n    if (tree) {\n        Chat.log(`¬ß6=== Directory Tree: ${tree.name} ===`);\n        Chat.log(`¬ß7Directories: ${tree.directoryCount}, Files: ${tree.fileCount}`);\n        displayDirectoryTree(tree);\n    }\n}\n\n// Usage\nconst macroFolder = JsMacros.getFile(\"macros\").getFile();\nshowDirectoryTree(macroFolder, 2);",
        "function searchFiles(directory, searchTerm, includeContent = false) {\n    const sorter = new FileChooser.sortFile();\n    const results = [];\n\n    function searchRecursive(dir, term, includeContent) {\n        const files = dir.listFiles();\n        if (!files) return;\n\n        const fileList = Array.from(files);\n        fileList.sort(sorter);\n\n        fileList.forEach(file => {\n            // Check if filename matches search term\n            if (file.getName().toLowerCase().includes(term.toLowerCase())) {\n                results.push({\n                    name: file.getName(),\n                    path: file.getAbsolutePath(),\n                    isDirectory: file.isDirectory(),\n                    size: file.isDirectory() ? 0 : file.length(),\n                    lastModified: file.lastModified(),\n                    matchType: \"filename\"\n                });\n            }\n\n            // Search in subdirectories\n            if (file.isDirectory()) {\n                searchRecursive(file, term, includeContent);\n            }\n            // Optional: search within file content\n            else if (includeContent && file.length() < 1024 * 1024) { // Limit to files < 1MB\n                try {\n                    const content = File.readText(file.getAbsolutePath());\n                    if (content.toLowerCase().includes(term.toLowerCase())) {\n                        results.push({\n                            name: file.getName(),\n                            path: file.getAbsolutePath(),\n                            isDirectory: false,\n                            size: file.length(),\n                            lastModified: file.lastModified(),\n                            matchType: \"content\"\n                        });\n                    }\n                } catch (e) {\n                    // Skip files that can't be read\n                }\n            }\n        });\n    }\n\n    searchRecursive(directory, searchTerm, includeContent);\n\n    // Sort results using the same comparator\n    results.sort((a, b) => {\n        if (a.isDirectory ^ b.isDirectory) {\n            return a.isDirectory ? -1 : 1;\n        } else {\n            return a.name.localeCompare(b.name);\n        }\n    });\n\n    return results;\n}\n\nfunction performFileSearch(searchTerm, includeContent = false) {\n    const macroFolder = JsMacros.getFile(\"macros\").getFile();\n    const results = searchFiles(macroFolder, searchTerm, includeContent);\n\n    Chat.log(`¬ß6=== Search Results for \"${searchTerm}\" ===`);\n    Chat.log(`¬ß7Found ${results.length} items:`);\n\n    results.forEach((result, index) => {\n        const icon = result.isDirectory ? \"üìÅ\" : \"üìÑ\";\n        const color = result.isDirectory ? \"¬ße\" : \"¬ßf\";\n        const type = result.matchType === \"content\" ? \"¬ßa[CONTENT]\" : \"¬ßb[NAME]\";\n        const size = result.isDirectory ? \"\" : ` ¬ß7(${(result.size / 1024).toFixed(2)} KB)`;\n\n        Chat.log(`${(index + 1).toString().padStart(3, \" \")}. ${color}${icon} ${type} ${result.name}${size}`);\n        Chat.log(`    ¬ß7Path: ${result.path}`);\n    });\n}\n\n// Usage examples\nperformFileSearch(\"config\"); // Search by filename only\n// performFileSearch(\"function\", true); // Search by filename and content",
        "// This happens automatically inside FileChooser.setDir()\nconst files = new ArrayList<>(Arrays.asList(directory.listFiles()));\nfiles.sort(new sortFile()); // Uses this comparator",
        "function createCustomFileSelector(directory, callback) {\n    const sorter = new FileChooser.sortFile();\n    const files = directory.listFiles();\n\n    if (files) {\n        const sortedFiles = Array.from(files);\n        sortedFiles.sort(sorter);\n\n        // Create selection menu (simplified example)\n        Chat.log(\"¬ß6=== Select a File ===\");\n        sortedFiles.forEach((file, index) => {\n            const type = file.isDirectory() ? \"¬ße[DIR]\" : \"¬ßf[FILE]\";\n            Chat.log(`${(index + 1).toString().padStart(2, \" \")}. ${type} ${file.getName()}`);\n        });\n\n        // In a real implementation, you would handle user input here\n        // and call the callback with the selected file\n    }\n}",
        "const sorter = new FileChooser.sortFile();\n\n// Handles null values (though File objects shouldn't be null in normal usage)\ntry {\n    // This would normally not occur in FileChooser usage\n    const result = sorter.compare(null, null);\n} catch (e) {\n    Chat.log(\"¬ßcComparator error: \" + e.message);\n}",
        "// Handles files with the same name\nconst file1 = new File(\"/path/test.txt\");\nconst file2 = new File(\"/path/test.txt\");\nChat.log(`Same files: ${sorter.compare(file1, file2) === 0 ? \"Equal\" : \"Different\"}`);"
      ]
    }
  ]
}