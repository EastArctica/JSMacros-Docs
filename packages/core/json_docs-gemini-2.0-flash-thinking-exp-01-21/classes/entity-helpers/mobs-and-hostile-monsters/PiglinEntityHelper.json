{
  "name": "PiglinEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.PiglinEntityHelper",
  "extends": "AbstractPiglinEntityHelper<PiglinEntity>",
  "since": "JsMacros 1.8.4",
  "description": "The `PiglinEntityHelper` class provides specialized access to piglin entities in Minecraft, offering detailed insight into their activities, behaviors, and combat states. This class extends the base functionality of `AbstractPiglinEntityHelper` with piglin-specific activity detection that is essential for understanding piglin AI behavior, bartering interactions, and combat patterns.",
  "overview": "Piglins are complex hostile mobs that exhibit unique behaviors like bartering with players, dancing to music, admiring items, and switching between melee and ranged combat. This helper class allows scripters to monitor these behavioral states and create sophisticated piglin interaction systems, automated bartering monitors, combat analysis tools, and behavioral research utilities.\n\n## Usage Examples\n\n### Comprehensive Piglin Combat Analysis\n```js\n// Advanced piglin combat behavior analyzer\nclass PiglinCombatAnalyzer {\n    constructor() {\n        this.combatLog = [];\n        this.threatAssessment = new Map();\n        this.weaponAnalysis = new Map();\n        this.tacticalRecommendations = [];\n    }\n\n    analyzePiglinCombat(entity) {\n        const piglin = entity.asPiglin();\n        if (!piglin) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n\n        const combatState = this.assessCombatState(piglin);\n        const threatLevel = this.calculateThreatLevel(piglin, combatState);\n        const tacticalData = this.gatherTacticalData(piglin, entity);\n\n        // Update threat assessment\n        this.threatAssessment.set(uuid, {\n            entity: entity,\n            name: name,\n            combatState: combatState,\n            threatLevel: threatLevel,\n            tacticalData: tacticalData,\n            lastUpdate: Client.getTime(),\n            position: pos\n        });\n\n        // Log combat state changes\n        this.logCombatStateChange(uuid, name, combatState, threatLevel);\n\n        // Generate tactical recommendations\n        this.updateTacticalRecommendations(uuid, combatState, threatLevel);\n\n        // Update weapon analysis\n        this.updateWeaponAnalysis(uuid, combatState);\n    }\n\n    assessCombatState(piglin) {\n        const states = {\n            wandering: piglin.isWandering(),\n            dancing: piglin.isDancing(),\n            admiring: piglin.isAdmiring(),\n            meleeAttacking: piglin.isMeleeAttacking(),\n            chargingCrossbow: piglin.isChargingCrossbow(),\n            crossbowReady: piglin.hasCrossbowReady()\n        };\n\n        // Determine primary state\n        if (states.meleeAttacking) return \"MELEE_COMBAT\";\n        if (states.chargingCrossbow) return \"RANGED_PREPARING\";\n        if (states.crossbowReady) return \"RANGED_READY\";\n        if (states.admiring) return \"ADMIRING\";\n        if (states.dancing) return \"DANCING\";\n        if (states.wandering) return \"WANDERING\";\n\n        return \"UNKNOWN\";\n    }\n\n    calculateThreatLevel(piglin, combatState) {\n        const baseThreat = {\n            \"MELEE_COMBAT\": 8,\n            \"RANGED_READY\": 9,\n            \"RANGED_PREPARING\": 7,\n            \"ADMIRING\": 1,\n            \"DANCING\": 0,\n            \"WANDERING\": 3,\n            \"UNKNOWN\": 4\n        };\n\n        let threatLevel = baseThreat[combatState] || 4;\n\n        // Distance modifier\n        const player = Player.getPlayer();\n        if (player) {\n            const distance = player.distanceTo(piglin);\n            if (distance <= 4) threatLevel += 3;\n            else if (distance <= 8) threatLevel += 2;\n            else if (distance <= 16) threatLevel += 1;\n        }\n\n        // Health modifier\n        const living = piglin.asLiving();\n        if (living) {\n            const healthPercent = living.getHealth() / living.getMaxHealth();\n            if (healthPercent > 0.8) threatLevel += 1;\n            else if (healthPercent < 0.3) threatLevel -= 2;\n        }\n\n        // Environmental factors\n        if (!piglin.isInWater()) threatLevel += 1;\n        if (piglin.isOnFire()) threatLevel -= 1;\n\n        return Math.max(0, Math.min(10, threatLevel));\n    }\n\n    gatherTacticalData(piglin, entity) {\n        const player = Player.getPlayer();\n        const living = entity.asLiving();\n\n        return {\n            distance: player ? player.distanceTo(entity) : Infinity,\n            health: living ? living.getHealth() : 0,\n            maxHealth: living ? living.getMaxHealth() : 0,\n            healthPercent: living ? (living.getHealth() / living.getMaxHealth()) * 100 : 0,\n            inWater: entity.isInWater(),\n            onFire: entity.isOnFire(),\n            canBeZombified: piglin.canBeZombified(),\n            dimension: World.getDimension(),\n            equipment: this.getEquipmentInfo(entity),\n            nearbyThreats: this.countNearbyThreats(entity)\n        };\n    }\n\n    getEquipmentInfo(entity) {\n        const living = entity.asLiving();\n        if (!living) return null;\n\n        return {\n            mainHand: living.getMainHand()?.toString() || \"empty\",\n            offHand: living.getOffHand()?.toString() || \"empty\",\n            armor: living.getArmor() || 0\n        };\n    }\n\n    countNearbyThreats(entity) {\n        const entities = World.getEntities(16);\n        let threatCount = 0;\n\n        entities.forEach(other => {\n            if (other === entity) return;\n            const distance = entity.distanceTo(other);\n            if (distance <= 12 && this.isThreatToPlayer(other)) {\n                threatCount++;\n            }\n        });\n\n        return threatCount;\n    }\n\n    isThreatToPlayer(entity) {\n        const hostileTypes = [\n            \"minecraft:piglin\", \"minecraft:zombie\", \"minecraft:skeleton\",\n            \"minecraft:spider\", \"minecraft:creeper\", \"minecraft:witch\",\n            \"minecraft:ghast\", \"minecraft:blaze\"\n        ];\n        return entity.is(...hostileTypes);\n    }\n\n    logCombatStateChange(uuid, name, combatState, threatLevel) {\n        const lastLog = this.combatLog.filter(log => log.uuid === uuid).pop();\n\n        if (!lastLog || lastLog.combatState !== combatState) {\n            const logEntry = {\n                timestamp: Client.getTime(),\n                uuid: uuid,\n                name: name,\n                combatState: combatState,\n                threatLevel: threatLevel,\n                formattedTime: new Date().toLocaleTimeString()\n            };\n\n            this.combatLog.push(logEntry);\n\n            // Keep only recent logs\n            if (this.combatLog.length > 100) {\n                this.combatLog = this.combatLog.slice(-50);\n            }\n\n            Chat.log(`&câš”ï¸ [${logEntry.formattedTime}] ${name}: ${combatState} (Threat: ${threatLevel}/10)`);\n        }\n    }\n\n    updateTacticalRecommendations(uuid, combatState, threatLevel) {\n        const recommendations = [];\n\n        switch (combatState) {\n            case \"MELEE_COMBAT\":\n                if (threatLevel >= 8) {\n                    recommendations.push(\"URGENT: Retreat to distance or use ranged weapon\");\n                    recommendations.push(\"Block incoming attacks - consider shield\");\n                } else {\n                    recommendations.push(\"Engage with appropriate weapon\");\n                    recommendations.push(\"Watch for backup piglins\");\n                }               \n                break;\n\n            case \"RANGED_READY\":\n                recommendations.push(\"CRITICAL: Take cover immediately\");\n                recommendations.push(\"Use shield to block arrows\");\n                recommendations.push(\"Charge attack while they're stationary\");\n                break;\n\n            case \"RANGED_PREPARING\":\n                recommendations.push(\"Interrupt charging with quick attack\");\n                recommendations.push(\"Use ranged weapon before they fire\");\n                recommendations.push(\"Prepare to dodge incoming arrow\");\n                break;\n\n            case \"ADMIRING\":\n                recommendations.push(\"SAFE: Good time for attack or escape\");\n                recommendations.push(\"Piglin is distracted - tactical advantage\");\n                break;\n\n            case \"DANCING\":\n                recommendations.push(\"PERFECT: Completely distracted\");\n                recommendations.push(\"Free attack opportunity or escape chance\");\n                break;\n\n            case \"WANDERING\":\n                if (threatLevel <= 5) {\n                    recommendations.push(\"APPROACH CAUTIOUSLY: May attack if provoked\");\n                    recommendations.push(\"Maintain safe distance\");\n                } else {\n                    recommendations.push(\"AVOID: High threat even when wandering\");\n                }\n                break;\n        }\n\n        this.tacticalRecommendations = recommendations;\n    }\n\n    updateWeaponAnalysis(uuid, combatState) {\n        if (!this.weaponAnalysis.has(uuid)) {\n            this.weaponAnalysis.set(uuid, {\n                meleeCount: 0,\n                rangedCount: 0,\n                stateChanges: []\n            });\n        }\n\n        const analysis = this.weaponAnalysis.get(uuid);\n        const currentTime = Client.getTime();\n\n        // Track weapon usage\n        if (combatState === \"MELEE_COMBAT\") {\n            analysis.meleeCount++;\n        } else if (combatState.includes(\"RANGED\")) {\n            analysis.rangedCount++;\n        }\n\n        // Track state changes\n        if (analysis.stateChanges.length === 0 ||\n            analysis.stateChanges[analysis.stateChanges.length - 1].state !== combatState) {\n\n            analysis.stateChanges.push({\n                time: currentTime,\n                state: combatState\n            });\n\n            // Keep only recent changes\n            if (analysis.stateChanges.length > 20) {\n                analysis.stateChanges = analysis.stateChanges.slice(-10);\n            }\n        }\n    }\n\n    generateCombatReport() {\n        Chat.log(\"\\n&6=== Piglin Combat Analysis Report ===\");\n\n        if (this.threatAssessment.size === 0) {\n            Chat.log(\"No piglins currently tracked\");\n            return;\n        }\n\n        // Sort piglins by threat level\n        const sortedPiglins = Array.from(this.threatAssessment.entries())\n            .sort(([,a], [,b]) => b.threatLevel - a.threatLevel);\n\n        // Threat analysis\n        Chat.log(\"\\n&cðŸŽ¯ Current Threats (by priority):\");\n        sortedPiglins.forEach(([uuid, data]) => {\n            const threatColor = data.threatLevel >= 8 ? \"&c\" :\n                               data.threatLevel >= 6 ? \"&e\" :\n                               data.threatLevel >= 4 ? \"&6\" : \"&a\";\n\n            Chat.log(`${threatColor}  ${data.name}: ${data.combatState} (Threat: ${data.threatLevel}/10)`);\n            Chat.log(`    Distance: ${data.tacticalData.distance.toFixed(1)}m, Health: ${data.tacticalData.healthPercent.toFixed(0)}%`);\n            Chat.log(`    Equipment: ${data.tacticalData.equipment?.mainHand || \"unknown\"}`);\n        });\n\n        // Weapon preference analysis\n        Chat.log(\"\\n&bâš”ï¸ Combat Style Analysis:\");\n        for (const [uuid, analysis] of this.weaponAnalysis) {\n            const data = this.threatAssessment.get(uuid);\n            const totalActions = analysis.meleeCount + analysis.rangedCount;\n\n            if (totalActions > 0) {\n                const meleePercent = ((analysis.meleeCount / totalActions) * 100).toFixed(1);\n                const rangedPercent = ((analysis.rangedCount / totalActions) * 100).toFixed(1);\n\n                Chat.log(`  ${data.name}: Melee ${meleePercent}%, Ranged ${rangedPercent}%`);\n            }\n        }\n\n        // Tactical recommendations\n        if (this.tacticalRecommendations.length > 0) {\n            Chat.log(\"\\n&eðŸŽ¯ Tactical Recommendations:\");\n            this.tacticalRecommendations.forEach(rec => {\n                Chat.log(`  â€¢ ${rec}`);\n            });\n        }\n\n        // Combat statistics\n        const totalPiglins = this.threatAssessment.size;\n        const highThreats = Array.from(this.threatAssessment.values()).filter(data => data.threatLevel >= 7).length;\n        const activeCombat = Array.from(this.threatAssessment.values()).filter(data =>\n            data.combatState.includes(\"COMBAT\") || data.combatState.includes(\"RANGED\")\n        ).length;\n\n        Chat.log(\"\\n&7ðŸ“Š Combat Statistics:\");\n        Chat.log(`  Total piglins tracked: ${totalPiglins}`);\n        Chat.log(`  High-threat piglins: ${highThreats} (${((highThreats/totalPiglins)*100).toFixed(1)}%)`);\n        Chat.log(`  Currently in combat: ${activeCombat}`);\n        Chat.log(`  Combat log entries: ${this.combatLog.length}`);\n    }\n\n    findHighestThreat() {\n        if (this.threatAssessment.size === 0) {\n            Chat.log(\"No piglins to assess\");\n            return;\n        }\n\n        let highestThreat = null;\n        let maxThreatLevel = -1;\n\n        for (const [uuid, data] of this.threatAssessment) {\n            if (data.threatLevel > maxThreatLevel) {\n                maxThreatLevel = data.threatLevel;\n                highestThreat = data;\n            }\n        }\n\n        if (highestThreat) {\n            Chat.log(`&cðŸš¨ HIGHEST THREAT: ${highestThreat.name}`);\n            Chat.log(`  Combat State: ${highestThreat.combatState}`);\n            Chat.log(`  Threat Level: ${highestThreat.threatLevel}/10`);\n            Chat.log(`  Position: [${highestThreat.position.x.toFixed(0)}, ${highestThreat.position.y.toFixed(0)}, ${highestThreat.position.z.toFixed(0)}]`);\n            Chat.log(`  Distance: ${highestThreat.tacticalData.distance.toFixed(1)} blocks`);\n            Chat.log(`  Equipment: ${highestThreat.tacticalData.equipment?.mainHand || \"unknown\"}`);\n\n            // Priority recommendations\n            if (highestThreat.combatState === \"RANGED_READY\") {\n                Chat.log(\"\\n&câš ï¸ IMMEDIATE ACTION REQUIRED:\");\n                Chat.log(\"  - Take cover behind blocks\");\n                Chat.log(\"  - Use shield to block arrows\");\n                Chat.log(\"  - Close distance or retreat\");\n            } else if (highestThreat.combatState === \"MELEE_COMBAT\") {\n                Chat.log(\"\\n&eâš”ï¸ COMBAT ENGAGEMENT:\");\n                Chat.log(\"  - Use appropriate weapon for range\");\n                Chat.log(\"  - Watch for attack patterns\");\n                Chat.log(\"  - Consider tactical retreat if overwhelmed\");\n            }\n        }\n    }\n}\n\nconst combatAnalyzer = new PiglinCombatAnalyzer();\n\n// Monitor piglin combat every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities(48);\n    const piglins = entities.filter(entity => entity.is(\"minecraft:piglin\"));\n\n    piglins.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= 40) {\n            combatAnalyzer.analyzePiglinCombat(entity);\n        }\n    });\n\n    // Clean up old data\n    // This method is not defined in the example, adding a placeholder if it were meant to be there.\n    // combatAnalyzer.cleanup(); \n}));\n\n// Commands for combat analysis\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.c\" && e.action === 1) { // C key\n        combatAnalyzer.generateCombatReport();\n    }\n}));\n\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.t\" && e.action === 1) { // T key\n        combatAnalyzer.findHighestThreat();\n    }\n}));\n```\n\n---\n\n## Notes and Limitations\n\n- PiglinEntityHelper provides detailed insight into piglin behavioral states beyond general piglin functionality\n- Activity states are mutually exclusive - a piglin can only be in one primary state at a time\n- The `isAdmiring()` state is particularly valuable for successful bartering operations\n- Crossbow states (`isChargingCrossbow()`, `hasCrossbowReady()`) indicate different phases of ranged combat\n- Piglins switch between melee and ranged combat based on distance and equipment availability\n- Dancing indicates nearby music sources and represents a completely safe state\n- Activity states change frequently in combat situations, requiring continuous monitoring for accurate analysis\n- Piglins may exhibit different behaviors in different dimensions (especially Nether vs Overworld)\n- Baby piglins have different behavior patterns and may not use all combat states\n- The activity detection methods are based on the underlying Minecraft piglin AI states and are highly accurate\n- Combat state transitions can be predicted with some reliability based on distance and player actions\n- The combination of activity states with other entity data provides comprehensive tactical intelligence\n\n---\n\n## Version Information\n\n- Extends AbstractPiglinEntityHelper with detailed activity state monitoring\n- Part of the specialized piglin entity helper hierarchy\n- Provides comprehensive piglin behavioral analysis capabilities\n- Designed for advanced piglin interaction systems and combat intelligence\n- All methods delegate to the underlying Minecraft PiglinEntity implementation\n- Supports both regular piglins and piglin brutes with identical activity states",
  "constructors": [
    {
      "signature": "PiglinEntityHelper()",
      "description": "PiglinEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through: Entity-related events (e.g., EntitySpawn, EntityDeath, EntityInteract), World entity queries using type filtering for `minecraft:piglin`, Casting from generic EntityHelper instances using `as(\"minecraft:piglin\")`, Methods that return piglin entities.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isWandering",
      "signature": "isWandering()",
      "returnType": "boolean",
      "description": "Checks if the piglin is currently in a wandering state.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isDancing",
      "signature": "isDancing()",
      "returnType": "boolean",
      "description": "Checks if the piglin is currently dancing.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isAdmiring",
      "signature": "isAdmiring()",
      "returnType": "boolean",
      "description": "Checks if the piglin is currently admiring an item.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isMeleeAttacking",
      "signature": "isMeleeAttacking()",
      "returnType": "boolean",
      "description": "Checks if the piglin is currently engaged in a melee attack.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isChargingCrossbow",
      "signature": "isChargingCrossbow()",
      "returnType": "boolean",
      "description": "Checks if the piglin is currently charging its crossbow.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "hasCrossbowReady",
      "signature": "hasCrossbowReady()",
      "returnType": "boolean",
      "description": "Checks if the piglin has its crossbow ready to fire.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "canBeZombified",
      "signature": "canBeZombified()",
      "returnType": "boolean",
      "description": "Checks if the piglin can be zombified (e.g., in the Overworld). Inherited from `AbstractPiglinEntityHelper`.",
      "parameters": [],
      "static": false,
      "examples": []
    }
  ]
}