{
  "name": "AbstractPiglinEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.AbstractPiglinEntityHelper<T extends AbstractPiglinEntity>",
  "extends": "MobEntityHelper<T>",
  "since": "JsMacros 1.8.4",
  "description": "The `AbstractPiglinEntityHelper` class provides specialized access to piglin-like entities in Minecraft, including piglins, hoglins, and zombified piglins. This class offers essential methods for monitoring piglin-specific behaviors such as zombification immunity, which is critical for understanding entity state transitions in different dimensions.",
  "overview": "This helper serves as a base class for more specific piglin helpers (like `PiglinEntityHelper`) while providing core functionality common to all abstract piglin entities. It's particularly useful for creating scripts that track piglin behaviors, manage bartering systems, coordinate combat scenarios, or monitor dimensional transformations of piglin-type entities.",
  "constructors": [
    {
      "signature": "N/A (Instances obtained indirectly)",
      "description": "AbstractPiglinEntityHelper instances are not typically created directly by scripters. They are instead acquired through various means such as entity-related events (e.g., `EntitySpawn`, `EntityDeath`, `EntityInteract`), results from world entity queries with type filtering, or by casting from generic `EntityHelper` instances using type-specific methods (e.g., `entity.asAbstractPiglin()`).",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "canBeZombified",
      "signature": "canBeZombified()",
      "returnType": "boolean",
      "description": "Checks if the piglin-like entity can undergo zombification. This method evaluates dimensional immunity and other conditions that prevent transformation, such as being in the Nether. It delegates to the underlying Minecraft AbstractPiglinEntity implementation for accurate state checking. Zombification is a permanent transformation, and its immunity can be affected by game difficulty, mob-specific traits, and environmental factors. Returns `true` if the entity is susceptible to zombification, `false` otherwise.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Quick piglin safety assessment\nevents.on(\"EntityInteract\", JavaWrapper.methodToJavaAsync((event) => {\n    const entity = event.getTarget();\n    if (entity.is(\"minecraft:piglin\", \"minecraft:piglin_brute\", \"minecraft:hoglin\")) {\n        const piglin = entity.asAbstractPiglin();\n        const canBeZombified = piglin.canBeZombified();\n        const dimension = World.getDimension();\n\n        Chat.log(`=== ${entity.getName().getString()} ===`);\n        Chat.log(`Dimension: ${dimension}`);\n        Chat.log(`Zombification Risk: ${canBeZombified ? \"&cHIGH\" : \"&aLOW\"}`);\n\n        if (canBeZombified && dimension === \"minecraft:overworld\") {\n            Chat.log(\"&c⚠️ This piglin will transform to Zombified Piglin!\");\n            Chat.log(\"   Move to Nether or apply protection immediately!\");\n\n            // Highlight with emergency color\n            entity.setGlowing(true);\n            entity.setGlowingColor(0xFF0000);\n        }\n    }\n}));",
        "// Monitor piglin state for safe bartering operations\nclass PiglinBarteringMonitor {\n    constructor() {\n        this.barteringPiglins = new Map();\n        this.safeBarteringConditions = new Set([\"minecraft:the_nether\"]);\n    }\n\n    checkBarteringSafety(piglin) {\n        const canBeZombified = piglin.canBeZombified();\n        const currentDimension = World.getDimension();\n        const isSafeDimension = this.safeBarteringConditions.has(currentDimension);\n\n        const barteringSafe = !canBeZombified || isSafeDimension;\n\n        return {\n            safe: barteringSafe,\n            reason: barteringSafe ?\n                (isSafeDimension ? \"Safe dimension\" : \"Immune to transformation\") :\n                \"Vulnerable to zombification in current dimension\",\n            dimension: currentDimension\n        };\n    }\n\n    analyzePiglinForBartering(piglin) {\n        const uuid = piglin.getUUID();\n        const name = piglin.getName().getString();\n        const safety = this.checkBarteringSafety(piglin);\n\n        // Living entity access for additional info\n        const living = piglin.asLiving();\n        let healthInfo = \"\";\n        if (living) {\n            const health = living.getHealth();\n            const maxHealth = living.getMaxHealth();\n            healthInfo = `Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`;\n        }\n\n        Chat.log(`=== Bartering Analysis: ${name} ===`);\n        Chat.log(`Bartering Safe: ${safety.safe ? \"&a✅ Yes\" : \"&c❌ No\"}`);\n        Chat.log(`Reason: ${safety.reason}`);\n        Chat.log(`Dimension: ${safety.dimension}`);\n        if (healthInfo) Chat.log(healthInfo);\n\n        if (!safety.safe) {\n            Chat.log(\"\\n&c⚠️ Bartering Dangers:\");\n            Chat.log(\"- Piglin may transform during bartering\");\n            Chat.log(\"- Items could be lost to transformation\");\n            Chat.log(\"- Aggression may occur after transformation\");\n\n            // Solutions\n            Chat.log(\"\\n&eSolutions:\");\n            Chat.log(\"- Move piglin to Nether before bartering\");\n            Chat.log(\"- Use fire resistance protection\");\n            Chat.log(\"- Complete bartering quickly if unavoidable\");\n\n            // Highlight dangerous piglins\n            piglin.setGlowing(true);\n            piglin.setGlowingColor(0xFFA500); // Orange for caution\n        } else {\n            Chat.log(\"\\n&a✅ Safe for bartering operations\");\n            piglin.setGlowing(true);\n            piglin.setGlowingColor(0x00FF00); // Green for safe\n        }\n\n        return safety;\n    }\n\n    scanForBarteringPiglins() {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const entities = World.getEntities(30);\n        const piglinTypes = [\"minecraft:piglin\", \"minecraft:piglin_brute\"];\n\n        let safePiglins = 0;\n        let unsafePiglins = 0;\n\n        entities.forEach(entity => {\n            if (entity.is(...piglinTypes)) {\n                const piglin = entity.asAbstractPiglin();\n                const distance = player.distanceTo(entity);\n\n                if (distance <= 25) {\n                    const safety = this.analyzePiglinForBartering(piglin);\n\n                    if (safety.safe) {\n                        safePiglins++;\n                    } else {\n                        unsafePiglins++;\n                    }\n\n                    Chat.log(\"\"); // Spacing between analyses\n                }\n            }\n        });\n\n        Chat.log(`\\n=== Bartering Safety Summary ===`);\n        Chat.log(`Safe piglins: ${safePiglins} &a✅`);\n        Chat.log(`Unsafe piglins: ${unsafePiglins} &c⚠️`);\n\n        if (unsafePiglins > 0) {\n            Chat.log(\"\\n&c⚠️ Unsafe piglins detected - take precautions before bartering!\");\n        } else if (safePiglins > 0) {\n            Chat.log(\"\\n&a✅ All piglins are safe for bartering!\");\n        } else {\n            Chat.log(\"\\n&eNo piglins found for bartering analysis\");\n        }\n    }\n}\n\n// Initialize bartering monitor\nconst barteringMonitor = new PiglinBarteringMonitor();\n\n// Command to scan for bartering piglins\nbarteringMonitor.scanForBarteringPiglins();"
      ]
    }
  ]
}