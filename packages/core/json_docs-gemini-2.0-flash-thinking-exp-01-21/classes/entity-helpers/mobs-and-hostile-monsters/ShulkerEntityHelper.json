{
  "name": "ShulkerEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.ShulkerEntityHelper",
  "extends": "MobEntityHelper<ShulkerEntity>",
  "since": "JSMacros 1.8.4",
  "description": "The `ShulkerEntityHelper` class provides specialized access to shulker entities in Minecraft, offering methods to monitor and interact with shulker-specific behaviors such as their closed/open state, attachment position, and color. This class extends `MobEntityHelper` and inherits all functionality for living entities including health monitoring, status effects, and AI states.",
  "overview": "This helper is particularly useful for creating scripts that detect shulker positions, monitor their attack state, track shulker boxes in end cities, or analyze shulker behavior patterns during exploration or combat.",
  "constructors": [
    {
      "signature": "ShulkerEntityHelper()",
      "description": "ShulkerEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through: Entity-related events (e.g., `EntitySpawn`, `EntityDeath`, `EntityInteract`), World entity queries using type filtering, Casting from generic EntityHelper instances using `asShulker()` method.",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isClosed",
      "signature": "isClosed()",
      "returnType": "boolean",
      "description": "Provides real-time information about shulker attack state. Returns `true` if the shulker is currently closed and potentially attacking, `false` otherwise. This method may have slight delays due to network synchronization.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Advanced shulker detection and tactical warning system\nclass ShulkerWarningSystem {\n    constructor() {\n        this.trackedShulkers = new Map();\n        this.warningLevels = {\n            safe: { distance: 32, color: 0x00FF00, message: \"Safe distance\" },\n            caution: { distance: 24, color: 0xFFFF00, message: \"Caution advised\" },\n            danger: { distance: 16, color: 0xFF8800, message: \"Danger zone\" },\n            critical: { distance: 8, color: 0xFF0000, message: \"Critical danger!\" }\n        };\n        this.lastWarning = 0;\n    }\n\n    analyzeShulker(shulker) {\n        const uuid = shulker.getUUID();\n        const pos = shulker.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(shulker);\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Calculate threat level based on multiple factors\n        let threatLevel = \"low\";\n        let threatScore = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance <= 8) threatScore += 50;\n        else if (distance <= 16) threatScore += 30;\n        else if (distance <= 24) threatScore += 15;\n\n        // Attack state threat\n        if (isClosed) {\n            threatScore += 40;\n            threatLevel = \"high\";\n        }\n\n        // Position threat (ceiling shulkers are more dangerous)\n        if (attachedSide.getName() === \"up\") {\n            threatScore += 20;\n        }\n\n        // Combined threat assessment\n        if (threatScore >= 70) threatLevel = \"critical\";\n        else if (threatScore >= 50) threatLevel = \"high\";\n        else if (threatScore >= 30) threatLevel = \"medium\";\n        else if (threatScore >= 15) threatLevel = \"elevated\";\n\n        // Update tracking data\n        this.trackedShulkers.set(uuid, {\n            shulker: shulker,\n            position: pos,\n            distance: distance,\n            isClosed: isClosed,\n            attachedSide: attachedSide,\n            color: color,\n            threatLevel: threatLevel,\n            threatScore: threatScore,\n            lastUpdate: Client.getTime()\n        });\n\n        return { threatLevel, distance, isClosed, attachedSide, color };\n    }\n\n    generateTacticalAdvice(shulkerData) {\n        const { threatLevel, distance, isClosed, attachedSide, color } = shulkerData;\n        const side = attachedSide.getName();\n        let advice = [];\n\n        if (threatLevel === \"critical\") {\n            advice.push(\"&&lIMMEDIATE DANGER!\");\n            if (isClosed) advice.push(\"Shulker is attacking - take cover!\");\n            advice.push(\"Distance: \" + distance.toFixed(1) + \"m\");\n        } else if (threatLevel === \"high\") {\n            advice.push(\"&&lHIGH THREAT LEVEL\");\n            if (isClosed) advice.push(\"Preparing to shoot - dodge projectiles\");\n            if (side === \"up\") advice.push(\"Ceiling shulker - watch for falling bullets\");\n        } else if (threatLevel === \"medium\") {\n            advice.push(\"&&lMODERATE THREAT\");\n            if (!isClosed) advice.push(\"Good opportunity to attack\");\n        }\n\n        // Position-specific advice\n        if (side === \"up\") {\n            advice.push(\"Ceiling attachment - attack from below\");\n        } else if (side === \"down\") {\n            advice.push(\"Floor attachment - vulnerable from above\");\n        } else if (attachedSide.isHorizontal()) {\n            advice.push(`Wall attachment (${side} face)`);\n            advice.push(\"Consider flanking approach\");\n        }\n\n        // Color-based identification\n        if (color) {\n            advice.push(`Color: ${color.getName()}`);\n        }\n\n        return advice;\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentShulkerUUIDs = new Set();\n        const currentTime = Client.getTime();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentShulkerUUIDs.add(uuid);\n\n                const shulkerData = this.analyzeShulker(shulker);\n                const advice = this.generateTacticalAdvice(shulkerData);\n\n                // Apply visual warnings based on threat level\n                if (shulkerData.threatLevel !== \"low\") {\n                    const warningColor = this.getWarningColor(shulkerData.threatLevel);\n                    shulker.setGlowing(true);\n                    shulker.setGlowingColor(warningColor);\n\n                    // Show actionbar warnings for dangerous shulkers\n                    if (shulkerData.threatLevel === \"critical\" || shulkerData.threatLevel === \"high\") {\n                        if (currentTime - this.lastWarning > 20) { // Throttle warnings\n                            const warning = advice[0]; // Show most important advice\n                            Chat.actionbar(`&c${warning} &[${shulkerData.distance.toFixed(1)}m]`);\n                            this.lastWarning = currentTime;\n                        }\n                    }\n                } else {\n                    // Remove glow from safe shulkers\n                    shulker.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed shulker data\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentShulkerUUIDs.has(uuid)) {\n                Chat.log(`&7Shulker removed from tracking: ${data.threatLevel} threat level`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n\n    getWarningColor(threatLevel) {\n        switch (threatLevel) {\n            case \"critical\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"elevated\": return 0xFFFF00; // Yellow\n            default: return 0x00FF00; // Green\n        }\n    }\n}\n\n// Initialize and run the warning system\nconst shulkerWarning = new ShulkerWarningSystem();\n\n// Update every tick for real-time monitoring\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    shulkerWarning.update();\n}));\n\nChat.log(\"&aShulker Warning System activated - Monitoring for dangerous shulkers\");"
      ]
    },
    {
      "name": "getAttachedSide",
      "signature": "getAttachedSide()",
      "returnType": "DirectionHelper",
      "description": "Returns the `DirectionHelper` representing the face the shulker is attached to. This is important for tactical positioning and understanding attack angles.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Advanced shulker detection and tactical warning system\nclass ShulkerWarningSystem {\n    constructor() {\n        this.trackedShulkers = new Map();\n        this.warningLevels = {\n            safe: { distance: 32, color: 0x00FF00, message: \"Safe distance\" },\n            caution: { distance: 24, color: 0xFFFF00, message: \"Caution advised\" },\n            danger: { distance: 16, color: 0xFF8800, message: \"Danger zone\" },\n            critical: { distance: 8, color: 0xFF0000, message: \"Critical danger!\" }\n        };\n        this.lastWarning = 0;\n    }\n\n    analyzeShulker(shulker) {\n        const uuid = shulker.getUUID();\n        const pos = shulker.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(shulker);\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Calculate threat level based on multiple factors\n        let threatLevel = \"low\";\n        let threatScore = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance <= 8) threatScore += 50;\n        else if (distance <= 16) threatScore += 30;\n        else if (distance <= 24) threatScore += 15;\n\n        // Attack state threat\n        if (isClosed) {\n            threatScore += 40;\n            threatLevel = \"high\";\n        }\n\n        // Position threat (ceiling shulkers are more dangerous)\n        if (attachedSide.getName() === \"up\") {\n            threatScore += 20;\n        }\n\n        // Combined threat assessment\n        if (threatScore >= 70) threatLevel = \"critical\";\n        else if (threatScore >= 50) threatLevel = \"high\";\n        else if (threatScore >= 30) threatLevel = \"medium\";\n        else if (threatScore >= 15) threatLevel = \"elevated\";\n\n        // Update tracking data\n        this.trackedShulkers.set(uuid, {\n            shulker: shulker,\n            position: pos,\n            distance: distance,\n            isClosed: isClosed,\n            attachedSide: attachedSide,\n            color: color,\n            threatLevel: threatLevel,\n            threatScore: threatScore,\n            lastUpdate: Client.getTime()\n        });\n\n        return { threatLevel, distance, isClosed, attachedSide, color };\n    }\n\n    generateTacticalAdvice(shulkerData) {\n        const { threatLevel, distance, isClosed, attachedSide, color } = shulkerData;\n        const side = attachedSide.getName();\n        let advice = [];\n\n        if (threatLevel === \"critical\") {\n            advice.push(\"&&lIMMEDIATE DANGER!\");\n            if (isClosed) advice.push(\"Shulker is attacking - take cover!\");\n            advice.push(\"Distance: \" + distance.toFixed(1) + \"m\");\n        } else if (threatLevel === \"high\") {\n            advice.push(\"&&lHIGH THREAT LEVEL\");\n            if (isClosed) advice.push(\"Preparing to shoot - dodge projectiles\");\n            if (side === \"up\") advice.push(\"Ceiling shulker - watch for falling bullets\");\n        } else if (threatLevel === \"medium\") {\n            advice.push(\"&&lMODERATE THREAT\");\n            if (!isClosed) advice.push(\"Good opportunity to attack\");\n        }\n\n        // Position-specific advice\n        if (side === \"up\") {\n            advice.push(\"Ceiling attachment - attack from below\");\n        } else if (side === \"down\") {\n            advice.push(\"Floor attachment - vulnerable from above\");\n        } else if (attachedSide.isHorizontal()) {\n            advice.push(`Wall attachment (${side} face)`);\n            advice.push(\"Consider flanking approach\");\n        }\n\n        // Color-based identification\n        if (color) {\n            advice.push(`Color: ${color.getName()}`);\n        }\n\n        return advice;\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentShulkerUUIDs = new Set();\n        const currentTime = Client.getTime();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentShulkerUUIDs.add(uuid);\n\n                const shulkerData = this.analyzeShulker(shulker);\n                const advice = this.generateTacticalAdvice(shulkerData);\n\n                // Apply visual warnings based on threat level\n                if (shulkerData.threatLevel !== \"low\") {\n                    const warningColor = this.getWarningColor(shulkerData.threatLevel);\n                    shulker.setGlowing(true);\n                    shulker.setGlowingColor(warningColor);\n\n                    // Show actionbar warnings for dangerous shulkers\n                    if (shulkerData.threatLevel === \"critical\" || shulkerData.threatLevel === \"high\") {\n                        if (currentTime - this.lastWarning > 20) { // Throttle warnings\n                            const warning = advice[0]; // Show most important advice\n                            Chat.actionbar(`&c${warning} &[${shulkerData.distance.toFixed(1)}m]`);\n                            this.lastWarning = currentTime;\n                        }\n                    }\n                } else {\n                    // Remove glow from safe shulkers\n                    shulker.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed shulker data\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentShulkerUUIDs.has(uuid)) {\n                Chat.log(`&7Shulker removed from tracking: ${data.threatLevel} threat level`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n\n    getWarningColor(threatLevel) {\n        switch (threatLevel) {\n            case \"critical\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"elevated\": return 0xFFFF00; // Yellow\n            default: return 0x00FF00; // Green\n        }\n    }\n}\n\n// Initialize and run the warning system\nconst shulkerWarning = new ShulkerWarningSystem();\n\n// Update every tick for real-time monitoring\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    shulkerWarning.update();\n}));\n\nChat.log(\"&aShulker Warning System activated - Monitoring for dangerous shulkers\");",
        "// Analyze shulker behavior patterns and attack statistics\nclass ShulkerBehaviorAnalyzer {\n    constructor() {\n        this.stats = {\n            totalEncountered: 0,\n            attackCycles: 0,\n            averageAttackInterval: 0,\n            colorDistribution: {},\n            positionAnalysis: {\n                ceiling: 0,\n                floor: 0,\n                walls: 0\n            },\n            attackData: []\n        };\n        this.trackedShulkers = new Map();\n    }\n\n    analyzeShulkerBehavior(shulker) {\n        const uuid = shulker.getUUID();\n        const currentTime = Client.getTime();\n        const pos = shulker.getPos();\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Initialize tracking data if new shulker\n        if (!this.trackedShulkers.has(uuid)) {\n            this.stats.totalEncountered++;\n            this.trackedShulkers.set(uuid, {\n                firstSeen: currentTime,\n                lastState: isClosed,\n                stateChanges: [],\n                attackCount: 0,\n                color: color ? color.getName() : \"purple (default)\"\n            });\n\n            // Update position statistics\n            if (attachedSide.getName() === \"up\") {\n                this.stats.positionAnalysis.ceiling++;\n            } else if (attachedSide.getName() === \"down\") {\n                this.stats.positionAnalysis.floor++;\n            } else {\n                this.stats.positionAnalysis.walls++;\n            }\n\n            // Update color distribution\n            const colorName = color ? color.getName() : \"purple (default)\";\n            this.stats.colorDistribution[colorName] = (this.stats.colorDistribution[colorName] || 0) + 1;\n        }\n\n        const shulkerData = this.trackedShulkers.get(uuid);\n\n        // Track state changes (open/closed)\n        if (shulkerData.lastState !== isClosed) {\n            shulkerData.stateChanges.push({\n                time: currentTime,\n                fromState: shulkerData.lastState,\n                toState: isClosed\n            });\n\n            // Count attack cycles (closing indicates attack preparation)\n            if (isClosed && !shulkerData.lastState) {\n                shulkerData.attackCount++;\n                this.stats.attackCycles++;\n\n                // Calculate attack interval\n                if (shulkerData.lastAttackTime) {\n                    const interval = currentTime - shulkerData.lastAttackTime;\n                    this.stats.attackData.push(interval);\n                    this.updateAverageAttackInterval();\n                }\n                shulkerData.lastAttackTime = currentTime;\n            }\n\n            shulkerData.lastState = isClosed;\n        }\n\n        return shulkerData;\n    }\n\n    updateAverageAttackInterval() {\n        if (this.stats.attackData.length > 0) {\n            const sum = this.stats.attackData.reduce((a, b) => a + b, 0);\n            this.stats.averageAttackInterval = sum / this.stats.attackData.length;\n        }\n    }\n\n    generateBehaviorReport() {\n        Chat.log(\"=== Shulker Behavior Analysis Report ===\");\n        Chat.log(`Total shulkers encountered: ${this.stats.totalEncountered}`);\n        Chat.log(`Attack cycles observed: ${this.stats.attackCycles}`);\n\n        if (this.stats.averageAttackInterval > 0) {\n            Chat.log(`Average attack interval: ${(this.stats.averageAttackInterval/20).toFixed(1)} seconds`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(\"=== Position Analysis ===\");\n        Chat.log(`Ceiling shulkers: ${this.stats.positionAnalysis.ceiling}`);\n        Chat.log(`Floor shulkers: ${this.stats.positionAnalysis.floor}`);\n        Chat.log(`Wall shulkers: ${this.stats.positionAnalysis.walls}`);\n\n        Chat.log(\"\");\n        Chat.log(\"=== Color Distribution ===\");\n        for (const [color, count] of Object.entries(this.stats.colorDistribution)) {\n            const percentage = ((count / this.stats.totalEncountered) * 100).toFixed(1);\n            Chat.log(`${color}: ${count} (${percentage}%)`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(`Currently tracked shulkers: ${this.trackedShulkers.size}`);\n    }\n\n    getMostDangerousPosition() {\n        const { ceiling, floor, walls } = this.stats.positionAnalysis;\n        const total = ceiling + floor + walls;\n\n        if (total === 0) return \"none\";\n\n        const ceilingPercent = (ceiling / total) * 100;\n        const floorPercent = (floor / total) * 100;\n        const wallPercent = (walls / total) * 100;\n\n        if (ceilingPercent >= wallPercent && ceilingPercent >= floorPercent) {\n            return \"ceiling\";\n        } else if (wallPercent >= ceilingPercent && wallPercent >= floorPercent) {\n            return \"walls\";\n        } else {\n            return \"floor\";\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentUUIDs.add(uuid);\n\n                this.analyzeShulkerBehavior(shulker);\n            }\n        });\n\n        // Remove despawned shulkers\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - data.firstSeen) / 20;\n                Chat.log(`&7Shulker despawned - Lifetime: ${lifetime.toFixed(1)}s, Attacks: ${data.attackCount}`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n}\n\n// Initialize analyzer\nconst behaviorAnalyzer = new ShulkerBehaviorAnalyzer();\n\n// Update analysis every 10 ticks (twice per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 10 === 0) {\n        behaviorAnalyzer.update();\n    }\n}));\n\n// Generate report every 3 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 3) === 0) {\n        behaviorAnalyzer.generateBehaviorReport();\n\n        const mostDangerous = behaviorAnalyzer.getMostDangerousPosition();\n        Chat.log(`&6Most common dangerous position: ${mostDangerous} shulkers`);\n    }\n}));\n\nChat.log(\"&aShulker Behavior Analyzer activated\");"
      ]
    },
    {
      "name": "getAttachedSide",
      "signature": "getAttachedSide()",
      "returnType": "DirectionHelper",
      "description": "Returns the `DirectionHelper` representing the face the shulker is attached to. This is important for tactical positioning and understanding attack angles.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Advanced shulker detection and tactical warning system\nclass ShulkerWarningSystem {\n    constructor() {\n        this.trackedShulkers = new Map();\n        this.warningLevels = {\n            safe: { distance: 32, color: 0x00FF00, message: \"Safe distance\" },\n            caution: { distance: 24, color: 0xFFFF00, message: \"Caution advised\" },\n            danger: { distance: 16, color: 0xFF8800, message: \"Danger zone\" },\n            critical: { distance: 8, color: 0xFF0000, message: \"Critical danger!\" }\n        };\n        this.lastWarning = 0;\n    }\n\n    analyzeShulker(shulker) {\n        const uuid = shulker.getUUID();\n        const pos = shulker.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(shulker);\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Calculate threat level based on multiple factors\n        let threatLevel = \"low\";\n        let threatScore = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance <= 8) threatScore += 50;\n        else if (distance <= 16) threatScore += 30;\n        else if (distance <= 24) threatScore += 15;\n\n        // Attack state threat\n        if (isClosed) {\n            threatScore += 40;\n            threatLevel = \"high\";\n        }\n\n        // Position threat (ceiling shulkers are more dangerous)\n        if (attachedSide.getName() === \"up\") {\n            threatScore += 20;\n        }\n\n        // Combined threat assessment\n        if (threatScore >= 70) threatLevel = \"critical\";\n        else if (threatScore >= 50) threatLevel = \"high\";\n        else if (threatScore >= 30) threatLevel = \"medium\";\n        else if (threatScore >= 15) threatLevel = \"elevated\";\n\n        // Update tracking data\n        this.trackedShulkers.set(uuid, {\n            shulker: shulker,\n            position: pos,\n            distance: distance,\n            isClosed: isClosed,\n            attachedSide: attachedSide,\n            color: color,\n            threatLevel: threatLevel,\n            threatScore: threatScore,\n            lastUpdate: Client.getTime()\n        });\n\n        return { threatLevel, distance, isClosed, attachedSide, color };\n    }\n\n    generateTacticalAdvice(shulkerData) {\n        const { threatLevel, distance, isClosed, attachedSide, color } = shulkerData;\n        const side = attachedSide.getName();\n        let advice = [];\n\n        if (threatLevel === \"critical\") {\n            advice.push(\"&&lIMMEDIATE DANGER!\");\n            if (isClosed) advice.push(\"Shulker is attacking - take cover!\");\n            advice.push(\"Distance: \" + distance.toFixed(1) + \"m\");\n        } else if (threatLevel === \"high\") {\n            advice.push(\"&&lHIGH THREAT LEVEL\");\n            if (isClosed) advice.push(\"Preparing to shoot - dodge projectiles\");\n            if (side === \"up\") advice.push(\"Ceiling shulker - watch for falling bullets\");\n        } else if (threatLevel === \"medium\") {\n            advice.push(\"&&lMODERATE THREAT\");\n            if (!isClosed) advice.push(\"Good opportunity to attack\");\n        }\n\n        // Position-specific advice\n        if (side === \"up\") {\n            advice.push(\"Ceiling attachment - attack from below\");\n        } else if (side === \"down\") {\n            advice.push(\"Floor attachment - vulnerable from above\");\n        } else if (attachedSide.isHorizontal()) {\n            advice.push(`Wall attachment (${side} face)`);\n            advice.push(\"Consider flanking approach\");\n        }\n\n        // Color-based identification\n        if (color) {\n            advice.push(`Color: ${color.getName()}`);\n        }\n\n        return advice;\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentShulkerUUIDs = new Set();\n        const currentTime = Client.getTime();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentShulkerUUIDs.add(uuid);\n\n                const shulkerData = this.analyzeShulker(shulker);\n                const advice = this.generateTacticalAdvice(shulkerData);\n\n                // Apply visual warnings based on threat level\n                if (shulkerData.threatLevel !== \"low\") {\n                    const warningColor = this.getWarningColor(shulkerData.threatLevel);\n                    shulker.setGlowing(true);\n                    shulker.setGlowingColor(warningColor);\n\n                    // Show actionbar warnings for dangerous shulkers\n                    if (shulkerData.threatLevel === \"critical\" || shulkerData.threatLevel === \"high\") {\n                        if (currentTime - this.lastWarning > 20) { // Throttle warnings\n                            const warning = advice[0]; // Show most important advice\n                            Chat.actionbar(`&c${warning} &[${shulkerData.distance.toFixed(1)}m]`);\n                            this.lastWarning = currentTime;\n                        }\n                    }\n                } else {\n                    // Remove glow from safe shulkers\n                    shulker.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed shulker data\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentShulkerUUIDs.has(uuid)) {\n                Chat.log(`&7Shulker removed from tracking: ${data.threatLevel} threat level`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n\n    getWarningColor(threatLevel) {\n        switch (threatLevel) {\n            case \"critical\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"elevated\": return 0xFFFF00; // Yellow\n            default: return 0x00FF00; // Green\n        }\n    }\n}\n\n// Initialize and run the warning system\nconst shulkerWarning = new ShulkerWarningSystem();\n\n// Update every tick for real-time monitoring\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    shulkerWarning.update();\n}));\n\nChat.log(\"&aShulker Warning System activated - Monitoring for dangerous shulkers\");",
        "// Analyze shulker behavior patterns and attack statistics\nclass ShulkerBehaviorAnalyzer {\n    constructor() {\n        this.stats = {\n            totalEncountered: 0,\n            attackCycles: 0,\n            averageAttackInterval: 0,\n            colorDistribution: {},\n            positionAnalysis: {\n                ceiling: 0,\n                floor: 0,\n                walls: 0\n            },\n            attackData: []\n        };\n        this.trackedShulkers = new Map();\n    }\n\n    analyzeShulkerBehavior(shulker) {\n        const uuid = shulker.getUUID();\n        const currentTime = Client.getTime();\n        const pos = shulker.getPos();\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Initialize tracking data if new shulker\n        if (!this.trackedShulkers.has(uuid)) {\n            this.stats.totalEncountered++;\n            this.trackedShulkers.set(uuid, {\n                firstSeen: currentTime,\n                lastState: isClosed,\n                stateChanges: [],\n                attackCount: 0,\n                color: color ? color.getName() : \"purple (default)\"\n            });\n\n            // Update position statistics\n            if (attachedSide.getName() === \"up\") {\n                this.stats.positionAnalysis.ceiling++;\n            } else if (attachedSide.getName() === \"down\") {\n                this.stats.positionAnalysis.floor++;\n            } else {\n                this.stats.positionAnalysis.walls++;\n            }\n\n            // Update color distribution\n            const colorName = color ? color.getName() : \"purple (default)\";\n            this.stats.colorDistribution[colorName] = (this.stats.colorDistribution[colorName] || 0) + 1;\n        }\n\n        const shulkerData = this.trackedShulkers.get(uuid);\n\n        // Track state changes (open/closed)\n        if (shulkerData.lastState !== isClosed) {\n            shulkerData.stateChanges.push({\n                time: currentTime,\n                fromState: shulkerData.lastState,\n                toState: isClosed\n            });\n\n            // Count attack cycles (closing indicates attack preparation)\n            if (isClosed && !shulkerData.lastState) {\n                shulkerData.attackCount++;\n                this.stats.attackCycles++;\n\n                // Calculate attack interval\n                if (shulkerData.lastAttackTime) {\n                    const interval = currentTime - shulkerData.lastAttackTime;\n                    this.stats.attackData.push(interval);\n                    this.updateAverageAttackInterval();\n                }\n                shulkerData.lastAttackTime = currentTime;\n            }\n\n            shulkerData.lastState = isClosed;\n        }\n\n        return shulkerData;\n    }\n\n    updateAverageAttackInterval() {\n        if (this.stats.attackData.length > 0) {\n            const sum = this.stats.attackData.reduce((a, b) => a + b, 0);\n            this.stats.averageAttackInterval = sum / this.stats.attackData.length;\n        }\n    }\n\n    generateBehaviorReport() {\n        Chat.log(\"=== Shulker Behavior Analysis Report ===\");\n        Chat.log(`Total shulkers encountered: ${this.stats.totalEncountered}`);\n        Chat.log(`Attack cycles observed: ${this.stats.attackCycles}`);\n\n        if (this.stats.averageAttackInterval > 0) {\n            Chat.log(`Average attack interval: ${(this.stats.averageAttackInterval/20).toFixed(1)} seconds`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(\"=== Position Analysis ===\");\n        Chat.log(`Ceiling shulkers: ${this.stats.positionAnalysis.ceiling}`);\n        Chat.log(`Floor shulkers: ${this.stats.positionAnalysis.floor}`);\n        Chat.log(`Wall shulkers: ${this.stats.positionAnalysis.walls}`);\n\n        Chat.log(\"\");\n        Chat.log(\"=== Color Distribution ===\");\n        for (const [color, count] of Object.entries(this.stats.colorDistribution)) {\n            const percentage = ((count / this.stats.totalEncountered) * 100).toFixed(1);\n            Chat.log(`${color}: ${count} (${percentage}%)`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(`Currently tracked shulkers: ${this.trackedShulkers.size}`);\n    }\n\n    getMostDangerousPosition() {\n        const { ceiling, floor, walls } = this.stats.positionAnalysis;\n        const total = ceiling + floor + walls;\n\n        if (total === 0) return \"none\";\n\n        const ceilingPercent = (ceiling / total) * 100;\n        const floorPercent = (floor / total) * 100;\n        const wallPercent = (walls / total) * 100;\n\n        if (ceilingPercent >= wallPercent && ceilingPercent >= floorPercent) {\n            return \"ceiling\";\n        } else if (wallPercent >= ceilingPercent && wallPercent >= floorPercent) {\n            return \"walls\";\n        } else {\n            return \"floor\";\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentUUIDs.add(uuid);\n\n                this.analyzeShulkerBehavior(shulker);\n            }\n        });\n\n        // Remove despawned shulkers\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - data.firstSeen) / 20;\n                Chat.log(`&7Shulker despawned - Lifetime: ${lifetime.toFixed(1)}s, Attacks: ${data.attackCount}`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n}\n\n// Initialize analyzer\nconst behaviorAnalyzer = new ShulkerBehaviorAnalyzer();\n\n// Update analysis every 10 ticks (twice per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 10 === 0) {\n        behaviorAnalyzer.update();\n    }\n}));\n\n// Generate report every 3 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 3) === 0) {\n        behaviorAnalyzer.generateBehaviorReport();\n\n        const mostDangerous = behaviorAnalyzer.getMostDangerousPosition();\n        Chat.log(`&6Most common dangerous position: ${mostDangerous} shulkers`);\n    }\n}));\n\nChat.log(\"&aShulker Behavior Analyzer activated\");"
      ]
    },
    {
      "name": "getColor",
      "signature": "getColor()",
      "returnType": "DyeColorHelper | null",
      "description": "Returns a `DyeColorHelper` representing the shulker's color, or `null` if it's the default purple shulker (uncolored).",
      "parameters": [],
      "static": false,
      "examples": [
        "// Advanced shulker detection and tactical warning system\nclass ShulkerWarningSystem {\n    constructor() {\n        this.trackedShulkers = new Map();\n        this.warningLevels = {\n            safe: { distance: 32, color: 0x00FF00, message: \"Safe distance\" },\n            caution: { distance: 24, color: 0xFFFF00, message: \"Caution advised\" },\n            danger: { distance: 16, color: 0xFF8800, message: \"Danger zone\" },\n            critical: { distance: 8, color: 0xFF0000, message: \"Critical danger!\" }\n        };\n        this.lastWarning = 0;\n    }\n\n    analyzeShulker(shulker) {\n        const uuid = shulker.getUUID();\n        const pos = shulker.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(shulker);\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Calculate threat level based on multiple factors\n        let threatLevel = \"low\";\n        let threatScore = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance <= 8) threatScore += 50;\n        else if (distance <= 16) threatScore += 30;\n        else if (distance <= 24) threatScore += 15;\n\n        // Attack state threat\n        if (isClosed) {\n            threatScore += 40;\n            threatLevel = \"high\";\n        }\n\n        // Position threat (ceiling shulkers are more dangerous)\n        if (attachedSide.getName() === \"up\") {\n            threatScore += 20;\n        }\n\n        // Combined threat assessment\n        if (threatScore >= 70) threatLevel = \"critical\";\n        else if (threatScore >= 50) threatLevel = \"high\";\n        else if (threatScore >= 30) threatLevel = \"medium\";\n        else if (threatScore >= 15) threatLevel = \"elevated\";\n\n        // Update tracking data\n        this.trackedShulkers.set(uuid, {\n            shulker: shulker,\n            position: pos,\n            distance: distance,\n            isClosed: isClosed,\n            attachedSide: attachedSide,\n            color: color,\n            threatLevel: threatLevel,\n            threatScore: threatScore,\n            lastUpdate: Client.getTime()\n        });\n\n        return { threatLevel, distance, isClosed, attachedSide, color };\n    }\n\n    generateTacticalAdvice(shulkerData) {\n        const { threatLevel, distance, isClosed, attachedSide, color } = shulkerData;\n        const side = attachedSide.getName();\n        let advice = [];\n\n        if (threatLevel === \"critical\") {\n            advice.push(\"&&lIMMEDIATE DANGER!\");\n            if (isClosed) advice.push(\"Shulker is attacking - take cover!\");\n            advice.push(\"Distance: \" + distance.toFixed(1) + \"m\");\n        } else if (threatLevel === \"high\") {\n            advice.push(\"&&lHIGH THREAT LEVEL\");\n            if (isClosed) advice.push(\"Preparing to shoot - dodge projectiles\");\n            if (side === \"up\") advice.push(\"Ceiling shulker - watch for falling bullets\");\n        } else if (threatLevel === \"medium\") {\n            advice.push(\"&&lMODERATE THREAT\");\n            if (!isClosed) advice.push(\"Good opportunity to attack\");\n        }\n\n        // Position-specific advice\n        if (side === \"up\") {\n            advice.push(\"Ceiling attachment - attack from below\");\n        } else if (side === \"down\") {\n            advice.push(\"Floor attachment - vulnerable from above\");\n        } else if (attachedSide.isHorizontal()) {\n            advice.push(`Wall attachment (${side} face)`);\n            advice.push(\"Consider flanking approach\");\n        }\n\n        // Color-based identification\n        if (color) {\n            advice.push(`Color: ${color.getName()}`);\n        }\n\n        return advice;\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentShulkerUUIDs = new Set();\n        const currentTime = Client.getTime();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentShulkerUUIDs.add(uuid);\n\n                const shulkerData = this.analyzeShulker(shulker);\n                const advice = this.generateTacticalAdvice(shulkerData);\n\n                // Apply visual warnings based on threat level\n                if (shulkerData.threatLevel !== \"low\") {\n                    const warningColor = this.getWarningColor(shulkerData.threatLevel);\n                    shulker.setGlowing(true);\n                    shulker.setGlowingColor(warningColor);\n\n                    // Show actionbar warnings for dangerous shulkers\n                    if (shulkerData.threatLevel === \"critical\" || shulkerData.threatLevel === \"high\") {\n                        if (currentTime - this.lastWarning > 20) { // Throttle warnings\n                            const warning = advice[0]; // Show most important advice\n                            Chat.actionbar(`&c${warning} &[${shulkerData.distance.toFixed(1)}m]`);\n                            this.lastWarning = currentTime;\n                        }\n                    }\n                } else {\n                    // Remove glow from safe shulkers\n                    shulker.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed shulker data\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentShulkerUUIDs.has(uuid)) {\n                Chat.log(`&7Shulker removed from tracking: ${data.threatLevel} threat level`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n\n    getWarningColor(threatLevel) {\n        switch (threatLevel) {\n            case \"critical\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"elevated\": return 0xFFFF00; // Yellow\n            default: return 0x00FF00; // Green\n        }\n    }\n}\n\n// Initialize and run the warning system\nconst shulkerWarning = new ShulkerWarningSystem();\n\n// Update every tick for real-time monitoring\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    shulkerWarning.update();\n}));\n\nChat.log(\"&aShulker Warning System activated - Monitoring for dangerous shulkers\");",
        "// Analyze shulker behavior patterns and attack statistics\nclass ShulkerBehaviorAnalyzer {\n    constructor() {\n        this.stats = {\n            totalEncountered: 0,\n            attackCycles: 0,\n            averageAttackInterval: 0,\n            colorDistribution: {},\n            positionAnalysis: {\n                ceiling: 0,\n                floor: 0,\n                walls: 0\n            },\n            attackData: []\n        };\n        this.trackedShulkers = new Map();\n    }\n\n    analyzeShulkerBehavior(shulker) {\n        const uuid = shulker.getUUID();\n        const currentTime = Client.getTime();\n        const pos = shulker.getPos();\n        const isClosed = shulker.isClosed();\n        const attachedSide = shulker.getAttachedSide();\n        const color = shulker.getColor();\n\n        // Initialize tracking data if new shulker\n        if (!this.trackedShulkers.has(uuid)) {\n            this.stats.totalEncountered++;\n            this.trackedShulkers.set(uuid, {\n                firstSeen: currentTime,\n                lastState: isClosed,\n                stateChanges: [],\n                attackCount: 0,\n                color: color ? color.getName() : \"purple (default)\"\n            });\n\n            // Update position statistics\n            if (attachedSide.getName() === \"up\") {\n                this.stats.positionAnalysis.ceiling++;\n            } else if (attachedSide.getName() === \"down\") {\n                this.stats.positionAnalysis.floor++;\n            } else {\n                this.stats.positionAnalysis.walls++;\n            }\n\n            // Update color distribution\n            const colorName = color ? color.getName() : \"purple (default)\";\n            this.stats.colorDistribution[colorName] = (this.stats.colorDistribution[colorName] || 0) + 1;\n        }\n\n        const shulkerData = this.trackedShulkers.get(uuid);\n\n        // Track state changes (open/closed)\n        if (shulkerData.lastState !== isClosed) {\n            shulkerData.stateChanges.push({\n                time: currentTime,\n                fromState: shulkerData.lastState,\n                toState: isClosed\n            });\n\n            // Count attack cycles (closing indicates attack preparation)\n            if (isClosed && !shulkerData.lastState) {\n                shulkerData.attackCount++;\n                this.stats.attackCycles++;\n\n                // Calculate attack interval\n                if (shulkerData.lastAttackTime) {\n                    const interval = currentTime - shulkerData.lastAttackTime;\n                    this.stats.attackData.push(interval);\n                    this.updateAverageAttackInterval();\n                }\n                shulkerData.lastAttackTime = currentTime;\n            }\n\n            shulkerData.lastState = isClosed;\n        }\n\n        return shulkerData;\n    }\n\n    updateAverageAttackInterval() {\n        if (this.stats.attackData.length > 0) {\n            const sum = this.stats.attackData.reduce((a, b) => a + b, 0);\n            this.stats.averageAttackInterval = sum / this.stats.attackData.length;\n        }\n    }\n\n    generateBehaviorReport() {\n        Chat.log(\"=== Shulker Behavior Analysis Report ===\");\n        Chat.log(`Total shulkers encountered: ${this.stats.totalEncountered}`);\n        Chat.log(`Attack cycles observed: ${this.stats.attackCycles}`);\n\n        if (this.stats.averageAttackInterval > 0) {\n            Chat.log(`Average attack interval: ${(this.stats.averageAttackInterval/20).toFixed(1)} seconds`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(\"=== Position Analysis ===\");\n        Chat.log(`Ceiling shulkers: ${this.stats.positionAnalysis.ceiling}`);\n        Chat.log(`Floor shulkers: ${this.stats.positionAnalysis.floor}`);\n        Chat.log(`Wall shulkers: ${this.stats.positionAnalysis.walls}`);\n\n        Chat.log(\"\");\n        Chat.log(\"=== Color Distribution ===\");\n        for (const [color, count] of Object.entries(this.stats.colorDistribution)) {\n            const percentage = ((count / this.stats.totalEncountered) * 100).toFixed(1);\n            Chat.log(`${color}: ${count} (${percentage}%)`);\n        }\n\n        Chat.log(\"\");\n        Chat.log(`Currently tracked shulkers: ${this.trackedShulkers.size}`);\n    }\n\n    getMostDangerousPosition() {\n        const { ceiling, floor, walls } = this.stats.positionAnalysis;\n        const total = ceiling + floor + walls;\n\n        if (total === 0) return \"none\";\n\n        const ceilingPercent = (ceiling / total) * 100;\n        const floorPercent = (floor / total) * 100;\n        const wallPercent = (walls / total) * 100;\n\n        if (ceilingPercent >= wallPercent && ceilingPercent >= floorPercent) {\n            return \"ceiling\";\n        } else if (wallPercent >= ceilingPercent && wallPercent >= floorPercent) {\n            return \"walls\";\n        } else {\n            return \"floor\";\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:shulker\")) {\n                const shulker = entity.asShulker();\n                const uuid = shulker.getUUID();\n                currentUUIDs.add(uuid);\n\n                this.analyzeShulkerBehavior(shulker);\n            }\n        });\n\n        // Remove despawned shulkers\n        for (const [uuid, data] of this.trackedShulkers) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - data.firstSeen) / 20;\n                Chat.log(`&7Shulker despawned - Lifetime: ${lifetime.toFixed(1)}s, Attacks: ${data.attackCount}`);\n                this.trackedShulkers.delete(uuid);\n            }\n        }\n    }\n}\n\n// Initialize analyzer\nconst behaviorAnalyzer = new ShulkerBehaviorAnalyzer();\n\n// Update analysis every 10 ticks (twice per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 10 === 0) {\n        behaviorAnalyzer.update();\n    }\n}));\n\n// Generate report every 3 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 3) === 0) {\n        behaviorAnalyzer.generateBehaviorReport();\n\n        const mostDangerous = behaviorAnalyzer.getMostDangerousPosition();\n        Chat.log(`&6Most common dangerous position: ${mostDangerous} shulkers`);\n    }\n}));\n\nChat.log(\"&aShulker Behavior Analyzer activated\");"
      ]
    }
  ]
}