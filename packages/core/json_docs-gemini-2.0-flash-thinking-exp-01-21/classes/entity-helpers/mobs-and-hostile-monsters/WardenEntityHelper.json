{
  "name": "WardenEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.WardenEntityHelper<WardenEntity>",
  "extends": "MobEntityHelper<WardenEntity>",
  "since": "JSMacros 1.8.4",
  "description": "Represents a Warden entity in the world. WardenEntityHelper provides access to warden-specific properties and behaviors such as anger levels, pose states, and special attack animations. This class serves as a specialized helper for interacting with one of Minecraft's most formidable hostile mobs.",
  "overview": "The Warden is a blind but powerful mob that detects players through vibrations and scent. It has unique behaviors including emerging from the ground, sniffing to detect targets, roaring, charging sonic boom attacks, and digging back into the ground when not pursuing targets. The Warden's anger system determines its aggression level toward targets.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, movement, AI control, and other mob properties, while adding warden-specific functionality for monitoring and responding to the Warden's unique behaviors.",
  "constructors": [],
  "methods": [
    {
      "name": "isDigging",
      "signature": "isDigging()",
      "returnType": "boolean",
      "description": "Checks if the Warden entity is currently in the process of digging into or out of the ground.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        } else if (state.includes(\"EMERGING\")) {\n            Chat.log(`&c⚠️ Warden emerging - prepare for fight!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    },
    {
      "name": "isEmerging",
      "signature": "isEmerging()",
      "returnType": "boolean",
      "description": "Checks if the Warden entity is currently emerging from the ground.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        } else if (state.includes(\"EMERGING\")) {\n            Chat.log(`&c⚠️ Warden emerging - prepare for fight!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    },
    {
      "name": "isRoaring",
      "signature": "isRoaring()",
      "returnType": "boolean",
      "description": "Checks if the Warden entity is currently performing its roar attack.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        } else if (state.includes(\"EMERGING\")) {\n            Chat.log(`&c⚠️ Warden emerging - prepare for fight!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    },
    {
      "name": "isSniffing",
      "signature": "isSniffing()",
      "returnType": "boolean",
      "description": "Checks if the Warden entity is currently sniffing to detect nearby entities.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        } else if (state.includes(\"EMERGING\")) {\n            Chat.log(`&c⚠️ Warden emerging - prepare for fight!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    },
    {
      "name": "isChargingSonicBoom",
      "signature": "isChargingSonicBoom()",
      "returnType": "boolean",
      "description": "Checks if the Warden entity is currently charging its powerful sonic boom attack.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    },
    {
      "name": "getAnger",
      "signature": "getAnger()",
      "returnType": "number",
      "description": "Retrieves the current anger level of the Warden entity. A higher value indicates greater aggression towards targets.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Complete warden behavior tracking and threat assessment\nclass WardenTracker {\n    constructor() {\n        this.activeWardens = new Map();\n        this.alertHistory = new Map();\n        this.dangerLevel = \"SAFE\";\n    }\n\n    trackWarden(entity) {\n        const warden = entity.asLiving();\n        if (!warden) return;\n\n        const uuid = entity.getUUID();\n        const name = entity.getName().getString();\n        const pos = entity.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(entity);\n        const anger = warden.getAnger();\n\n        // Determine current warden state\n        const state = {\n            isDigging: warden.isDigging(),\n            isEmerging: warden.isEmerging(),\n            isRoaring: warden.isRoaring(),\n            isSniffing: warden.isSniffing(),\n            isChargingSonicBoom: warden.isChargingSonicBoom()\n        };\n\n        const currentState = this.getWardenStateString(state);\n        const threatLevel = this.calculateThreatLevel(distance, anger, state);\n\n        // Update or create warden tracking\n        if (!this.activeWardens.has(uuid)) {\n            Chat.log(`&c⚠️ NEW WARDEN DETECTED: ${name}`);\n            this.activeWardens.set(uuid, {\n                entity: entity,\n                name: name,\n                firstSeen: Client.getTime(),\n                lastPosition: pos,\n                peakAnger: anger,\n                stateHistory: [],\n                threatHistory: []\n            });\n        }\n\n        const tracking = this.activeWardens.get(uuid);\n        tracking.lastPosition = pos;\n        tracking.currentAnger = anger;\n        tracking.currentState = currentState;\n        tracking.threatLevel = threatLevel;\n        tracking.peakAnger = Math.max(tracking.peakAnger, anger);\n\n        // Add to state history\n        tracking.stateHistory.push({\n            time: Client.getTime(),\n            state: currentState,\n            anger: anger,\n            distance: distance\n        });\n\n        // Keep history manageable\n        if (tracking.stateHistory.length > 100) {\n            tracking.stateHistory.shift();\n        }\n\n        // Generate appropriate alerts\n        this.generateAlerts(tracking, uuid);\n\n        // Update global danger level\n        this.updateDangerLevel();\n    }\n\n    getWardenStateString(state) {\n        const states = [];\n        if (state.isEmerging) states.push(\"EMERGING\");\n        if (state.isDigging) states.push(\"DIGGING\");\n        if (state.isRoaring) states.push(\"ROARING\");\n        if (state.isChargingSonicBoom) states.push(\"SONIC_BOOM\");\n        if (state.isSniffing) states.push(\"SNIFFING\");\n        return states.length > 0 ? states.join(\",\") : \"IDLE\";\n    }\n\n    calculateThreatLevel(distance, anger, state) {\n        let threat = 0;\n\n        // Distance threat (closer = more dangerous)\n        if (distance < 8) threat += 50;\n        else if (distance < 16) threat += 30;\n        else if (distance < 32) threat += 15;\n        else if (distance < 64) threat += 5;\n\n        // Anger threat\n        threat += Math.min(anger, 100);\n\n        // State-based threat multipliers\n        if (state.isChargingSonicBoom) threat += 40;\n        if (state.isRoaring) threat += 30;\n        if (state.isEmerging) threat += 25;\n        if (state.isSniffing) threat += 20;\n        if (state.isDigging) threat -= 10; // Digging is less dangerous\n\n        return Math.min(threat, 150); // Cap at 150\n    }\n\n    generateAlerts(tracking, uuid) {\n        const currentTime = Client.getTime();\n        const alertKey = `${uuid}_${tracking.currentState}`;\n\n        // Rate limit alerts\n        if (this.alertHistory.has(alertKey)) {\n            const lastAlert = this.alertHistory.get(alertKey);\n            if (currentTime - lastAlert < 60) { // 3 second cooldown\n                return;\n            }\n        }\n\n        this.alertHistory.set(alertKey, currentTime);\n\n        const distance = Player.getPlayer().distanceTo(tracking.entity);\n        const anger = tracking.currentAnger;\n        const state = tracking.currentState;\n\n        // Critical alerts\n        if (tracking.threatLevel >= 120) {\n            Chat.actionbar(\"&4&l&nCRITICAL THREAT - WARDEN ATTACKING!\");\n            Chat.log(`&4&l=== CRITICAL WARDEN ALERT ===`);\n            Chat.log(`&cState: ${state}`);\n            Chat.log(`&cAnger: ${anger}`);\n            Chat.log(`&cDistance: ${distance.toFixed(1)}m`);\n            Chat.log(`&cPosition: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n\n            if (state.includes(\"SONIC_BOOM\")) {\n                Chat.log(`&4&lSONIC BOOM - BREAK LINE OF SIGHT NOW!`);\n            }\n\n        } else if (tracking.threatLevel >= 80) {\n            Chat.actionbar(\"&c&lHIGH THREAT - Warden is very dangerous!\");\n\n        } else if (tracking.threatLevel >= 50) {\n            Chat.actionbar(\"&eMODERATE THREAT - Warden is hostile\");\n\n        } else if (tracking.threatLevel >= 25) {\n            Chat.actionbar(\"&7LOW THREAT - Warden is suspicious\");\n        }\n\n        // State-specific alerts\n        if (state.includes(\"SONIC_BOOM\")) {\n            Chat.log(`&4&l⚠️ SONIC BOOM CHARGING - ${distance.toFixed(1)}m away!`);\n        } else if (state.includes(\"EMERGING\")) {\n            Chat.log(`&c⚠️ Warden emerging - prepare for fight!`);\n        }\n    }\n\n    updateDangerLevel() {\n        let maxThreat = 0;\n        for (const tracking of this.activeWardens.values()) {\n            maxThreat = Math.max(maxThreat, tracking.threatLevel);\n        }\n\n        let newLevel;\n        if (maxThreat >= 120) newLevel = \"CRITICAL\";\n        else if (maxThreat >= 80) newLevel = \"HIGH\";\n        else if (maxThreat >= 50) newLevel = \"MODERATE\";\n        else if (maxThreat >= 25) newLevel = \"LOW\";\n        else newLevel = \"SAFE\";\n\n        if (newLevel !== this.dangerLevel) {\n            this.dangerLevel = newLevel;\n            Chat.log(`&6=== WARDEN THREAT LEVEL: ${this.dangerLevel} ===`);\n        }\n    }\n\n    generateStatusReport() {\n        if (this.activeWardens.size === 0) {\n            Chat.log(\"No active wardens in tracking range\");\n            return;\n        }\n\n        Chat.log(`&6=== WARDEN STATUS REPORT (${this.activeWardens.size} wardens) ===`);\n        Chat.log(`&6Overall Threat Level: ${this.dangerLevel}`);\n\n        for (const [uuid, tracking] of this.activeWardens) {\n            const duration = (Client.getTime() - tracking.firstSeen) / 20;\n            Chat.log(`\\n&e${tracking.name}:`);\n            Chat.log(`  State: ${tracking.currentState}`);\n            Chat.log(`  Anger: ${tracking.currentAnger}/${tracking.peakAnger}`);\n            Chat.log(`  Threat: ${tracking.threatLevel}/150`);\n            Chat.log(`  Distance: ${Player.getPlayer().distanceTo(tracking.entity).toFixed(1)}m`);\n            Chat.log(`  Tracking duration: ${duration.toFixed(0)}s`);\n            Chat.log(`  Position: [${tracking.lastPosition.x.toFixed(0)}, ${tracking.lastPosition.y.toFixed(0)}, ${tracking.lastPosition.z.toFixed(0)}]`);\n        }\n    }\n\n    cleanup() {\n        // Remove tracking for dead entities\n        for (const [uuid, tracking] of this.activeWardens) {\n            if (!tracking.entity.isAlive()) {\n                const duration = (Client.getTime() - tracking.firstSeen) / 20;\n                Chat.log(`&7${tracking.name} disappeared after ${duration.toFixed(0)}s (Peak anger: ${tracking.peakAnger})`);\n                this.activeWardens.delete(uuid);\n            }\n        }\n\n        // Clean old alert history\n        const currentTime = Client.getTime();\n        for (const [key, time] of this.alertHistory) {\n            if (currentTime - time > 300) { // 15 second cleanup\n                this.alertHistory.delete(key);\n            }\n        }\n    }\n}\n\nconst wardenTracker = new WardenTracker();\n\n// Main tracking loop\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 96;\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:warden\") && player.distanceTo(entity) <= trackingRange) {\n            wardenTracker.trackWarden(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        wardenTracker.cleanup();\n    }\n}));\n\n// Status command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        wardenTracker.generateStatusReport();\n    }\n}));",
        "// Analyze warden patterns and behaviors\nfunction analyzeWardenBehavior() {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const wardens = entities.filter(entity => entity.is(\"minecraft:warden\"));\n\n    if (wardens.length === 0) {\n        Chat.log(\"No wardens found in the area\");\n        return;\n    }\n\n    Chat.log(`=== Warden Behavior Analysis (${wardens.length} wardens) ===`);\n\n    const stats = {\n        total: wardens.length,\n        emerging: 0,\n        digging: 0,\n        roaring: 0,\n        sniffing: 0,\n        chargingSonicBoom: 0,\n        idle: 0,\n        highAnger: 0,\n        mediumAnger: 0,\n        lowAnger: 0,\n        byDistance: { near: 0, medium: 0, far: 0 }\n    };\n\n    wardens.forEach(warden => {\n        const living = warden.asLiving();\n        const distance = player.distanceTo(warden);\n        const pos = warden.getPos();\n        const anger = living.getAnger();\n\n        // Count behaviors\n        if (living.isEmerging()) stats.emerging++;\n        if (living.isDigging()) stats.digging++;\n        if (living.isRoaring()) stats.roaring++;\n        if (living.isSniffing()) stats.sniffing++;\n        if (living.isChargingSonicBoom()) stats.chargingSonicBoom++;\n\n        // Count idle (no special behavior)\n        if (!living.isEmerging() && !living.isDigging() && !living.isRoaring() &&\n            !living.isSniffing() && !living.isChargingSonicBoom()) {\n            stats.idle++;\n        }\n\n        // Count anger levels\n        if (anger >= 80) stats.highAnger++;\n        else if (anger >= 40) stats.mediumAnger++;\n        else stats.lowAnger++;\n\n        // Distance categories\n        if (distance <= 20) stats.byDistance.near++;\n        else if (distance <= 50) stats.byDistance.medium++;\n        else stats.byDistance.far++;\n\n        // Detailed logging for nearby wardens\n        if (distance <= 64) {\n            const behaviors = [];\n            if (living.isEmerging()) behaviors.push(\"Emerging\");\n            if (living.isDigging()) behaviors.push(\"Digging\");\n            if (living.isRoaring()) behaviors.push(\"Roaring\");\n            if (living.isSniffing()) behaviors.push(\"Sniffing\");\n            if (living.isChargingSonicBoom()) behaviors.push(\"Charging Sonic Boom\");\n\n            Chat.log(`  ${warden.getName().getString()}: ${distance.toFixed(1)}m - Anger: ${anger} - ${behaviors.join(\", \") || \"Idle\"}`);\n        }\n    });\n\n    // Summary statistics\n    Chat.log(\"\\n=== Behavioral Summary ===\");\n    Chat.log(`Total wardens: ${stats.total}`);\n    Chat.log(`Emerging: ${stats.emerging}`);\n    Chat.log(`Digging: ${stats.digging}`);\n    Chat.log(`Roaring: ${stats.roaring}`);\n    Chat.log(`Sniffing: ${stats.sniffing}`);\n    Chat.log(`Charging Sonic Boom: ${stats.chargingSonicBoom}`);\n    Chat.log(`Idle: ${stats.idle}`);\n\n    Chat.log(\"\\n=== Anger Levels ===\");\n    Chat.log(`High anger (80+): ${stats.highAnger}`);\n    Chat.log(`Medium anger (40-79): ${stats.mediumAnger}`);\n    Chat.log(`Low anger (<40): ${stats.lowAnger}`);\n\n    Chat.log(\"\\n=== By Distance ===\");\n    Chat.log(`Near (≤20m): ${stats.byDistance.near}`);\n    Chat.log(`Medium (20-50m): ${stats.byDistance.medium}`);\n    Chat.log(`Far (>50m): ${stats.byDistance.far}`);\n\n    // Warnings for dangerous situations\n    if (stats.chargingSonicBoom > 0) {\n        Chat.log(`\\n&4&l⚠️ CRITICAL: ${stats.chargingSonicBoom} warden(s) charging sonic boom!`);\n    }\n\n    if (stats.byDistance.near > 0 && stats.highAnger > 0) {\n        Chat.log(`\\n&c⚠️ HIGH DANGER: ${stats.byDistance.near} angry warden(s) nearby!`);\n    }\n\n    if (stats.roaring > 0) {\n        Chat.log(`\\n&e⚠️ Area damage: ${stats.roaring} warden(s) roaring!`);\n    }\n}\n\nanalyzeWardenBehavior();"
      ]
    }
  ]
}