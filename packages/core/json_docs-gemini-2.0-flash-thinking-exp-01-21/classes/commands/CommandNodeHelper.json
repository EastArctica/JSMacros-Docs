{
  "name": "CommandNodeHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper",
  "extends": "BaseHelper<CommandNode<?>>",
  "since": "JSMacros 1.6.5",
  "description": "The `CommandNodeHelper` class is a wrapper around Minecraft's Brigadier command system that represents a command node in the command tree. This class is primarily used internally for command registration and management operations, allowing users to temporarily unregister commands and re-register them later.",
  "overview": "Command nodes are the fundamental building blocks of Minecraft's command system, representing individual commands, arguments, and literals in the command tree structure.\n\n## Accessing CommandNodeHelper\n\nCommandNodeHelper instances are typically obtained through command management operations:\n\n- Unregistering commands using `Chat.getCommandManager().unregisterCommand(name)`\n- The deprecated `Chat.unregisterCommand(name)` method\n\n```js\n// Get a command node by unregistering it\nconst commandNode = Chat.getCommandManager().unregisterCommand(\"example\");\nif (commandNode) {\n    Chat.log(`Successfully unregistered command: ${commandNode.fabric.getName()}`);\n}\n```\n\n## Usage Examples\n\n### Temporary Command Disabling\n\n```js\n// Function to temporarily disable a command\nfunction disableCommandTemporarily(commandName, durationMs) {\n    const commandManager = Chat.getCommandManager();\n\n    try {\n        // Unregister the command\n        const commandNode = commandManager.unregisterCommand(commandName);\n\n        if (commandNode) {\n            Chat.logColor(`&aCommand '/${commandName}' has been disabled temporarily`);\n\n            // Schedule re-enabling the command\n            JavaWrapper.methodToJava(() => {\n                try {\n                    Client.waitTick(durationMs / 50); // Convert ms to ticks (1 tick = 50ms)\n                    commandManager.reRegisterCommand(commandNode);\n                    Chat.logColor(`&aCommand '/${commandName}' has been re-enabled`);\n                } catch (e) {\n                    Chat.logColor(`&cError re-enabling command: ${e.message}`);\n                }\n            }).run();\n\n            return commandNode;\n        } else {\n            Chat.logColor(`&cCommand '/${commandName}' not found or could not be disabled`);\n            return null;\n        }\n    } catch (e) {\n        Chat.logColor(`&cError disabling command: ${e.message}`);\n        return null;\n    }\n}\n\n// Disable /gamemode command for 30 seconds\nconst gamemodeNode = disableCommandTemporarily(\"gamemode\", 30000);\n```\n\n### Command Analysis\n\n```js\n// Analyze a command node structure\nfunction analyzeCommand(commandName) {\n    const commandManager = Chat.getCommandManager();\n\n    try {\n        const commandNode = commandManager.unregisterCommand(commandName);\n\n        if (commandNode) {\n            const rawNode = commandNode.getRaw();\n\n            Chat.log(`=== Command Analysis: /${commandName} ===`);\n            Chat.log(`Name: ${rawNode.getName()}`);\n            Chat.log(`Usage: ${rawNode.getUsageText()}`);\n            // TODO: This needs a ClientCommandSource but I'm not sure how to get one\n            // Chat.log(`Can use: ${rawNode.canUse(Player.getPlayer())}`);\n\n            // Check if command has children (subcommands)\n            const children = rawNode.getChildren();\n            Chat.log(`Subcommands: ${children.size()}`);\n\n            for (const child of children) {\n                Chat.log(`  - ${child.getName()}: ${child.getUsageText()}`);\n            }\n\n            // Re-register the command immediately\n            commandManager.reRegisterCommand(commandNode);\n\n        } else {\n            Chat.log(`Command '/${commandName}' not found`);\n        }\n    } catch (e) {\n        Chat.log(`Error analyzing command: ${e.message}`);\n    }\n}\n\n// Analyze the /help command\nanalyzeCommand(\"help\");\n```\n\n### Command Backup and Restore\n\n```js\n// Backup system for commands\nclass CommandBackup {\n    constructor() {\n        this.backedUpCommands = new Map();\n    }\n\n    backupCommand(commandName) {\n        if (this.backedUpCommands.has(commandName)) {\n            Chat.logColor(`&eCommand '/${commandName}' is already backed up`);\n            return false;\n        }\n\n        try {\n            const commandNode = Chat.getCommandManager().unregisterCommand(commandName);\n\n            if (commandNode) {\n                this.backedUpCommands.set(commandName, commandNode);\n                Chat.logColor(`&aBacked up command: /${commandName}`);\n                return true;\n            } else {\n                Chat.logColor(`&cCommand '/${commandName}' not found`);\n                return false;\n            }\n        } catch (e) {\n            Chat.logColor(`&cError backing up command: ${e.message}`);\n            return false;\n        }\n    }\n\n    restoreCommand(commandName) {\n        const commandNode = this.backedUpCommands.get(commandName);\n\n        if (!commandNode) {\n            Chat.logColor(`&cNo backup found for command '/${commandName}'`);\n            return false;\n        }\n\n        try {\n            Chat.getCommandManager().reRegisterCommand(commandNode);\n            this.backedUpCommands.delete(commandName);\n            Chat.logColor(`&aRestored command: /${commandName}`);\n            return true;\n        } catch (e) {\n            Chat.logColor(`&cError restoring command: ${e.message}`);\n            return false;\n        }\n    }\n\n    listBackups() {\n        if (this.backedUpCommands.size === 0) {\n            Chat.log(\"No command backups available\");\n            return;\n        }\n\n        Chat.log(\"=== Command Backups ===\");\n        for (const [commandName] of this.backedUpCommands) {\n            Chat.log(`- /${commandName}`);\n        }\n    }\n\n    restoreAll() {\n        const commands = Array.from(this.backedUpCommands.keys());\n        let restored = 0;\n\n        for (const commandName of commands) {\n            if (this.restoreCommand(commandName)) {\n                restored++;\n            }\n        }\n\n        Chat.logColor(`&aRestored ${restored}/${commands.length} commands`);\n    }\n}\n\n// Usage example\nconst backup = new CommandBackup();\n\n// Backup some commands\nbackup.backupCommand(\"tp\");\nbackup.backupCommand(\"give\");\nbackup.backupCommand(\"time\");\n\n// List backups\nbackup.listBackups();\n\n// Restore specific command\nbackup.restoreCommand(\"tp\");\n\n// Restore all remaining commands\nbackup.restoreAll();\n```\n\n### Command Filtering System\n\n```js\n// Filter commands based on criteria\nfunction filterCommands(criteria) {\n    const commandManager = Chat.getCommandManager();\n    const availableCommands = commandManager.getValidCommands();\n    const matchedCommands = [];\n\n    Chat.log(`Scanning ${availableCommands.length} commands...`);\n\n    for (const commandName of availableCommands) {\n        try {\n            const commandNode = commandManager.unregisterCommand(commandName);\n\n            if (commandNode) {\n                const rawNode = commandNode.getRaw();\n                let matches = true;\n\n                // Apply filtering criteria\n                if (criteria.nameContains && !commandName.includes(criteria.nameContains)) {\n                    matches = false;\n                }\n\n                if (criteria.canUse !== undefined) {\n                    // MinecraftClient.player.getCommandSource(ServerWorld world)\n                    // TODO: We can't realistically get this working for anything except local servers.\n                    const canUse = false; // rawNode.canUse(Client.getMinecraft().field_1724.method_5671(world));\n                    if (criteria.canUse !== canUse) {\n                        matches = false;\n                    }\n                }\n\n                if (criteria.hasChildren !== undefined) {\n                    const hasChildren = rawNode.getChildren().size() > 0;\n                    if (criteria.hasChildren !== hasChildren) {\n                        matches = false;\n                    }\n                }\n\n                if (matches) {\n                    matchedCommands.push({\n                        name: commandName,\n                        node: commandNode,\n                        usage: rawNode.getUsageText(),\n                        children: rawNode.getChildren().size()\n                    });\n                }\n\n                // Always re-register the command\n                commandManager.reRegisterCommand(commandNode);\n            }\n        } catch (e) {\n            Chat.logColor(`&cError processing command '/${commandName}': ${e.message}`);\n        }\n    }\n\n    return matchedCommands;\n}\n\n// Find all commands the player can use that have subcommands\nconst usableCommands = filterCommands({\n    canUse: true,\n    hasChildren: true\n});\n\nChat.log(`Found ${usableCommands.length} usable commands with subcommands:`);\nusableCommands.forEach(cmd => {\n    Chat.log(`- /${cmd.name}: ${cmd.usage} (${cmd.children} subcommands)`);\n});\n```\n\n## Integration with Command Manager\n\nCommandNodeHelper is designed to work with JSMacros' command management system:\n\n```js\nconst commandManager = Chat.getCommandManager();\n\n// Get available commands\nconst commands = commandManager.getValidCommands();\nChat.log(`Available commands: ${commands.toArray().join(\", \")}`);\n\n// Unregister a command temporarily\nconst commandNode = commandManager.unregisterCommand(\"example\");\nif (commandNode) {\n    // Command is now unregistered\n\n    // Re-register it later\n    commandManager.reRegisterCommand(commandNode);\n}\n```\n\n## Notes and Limitations\n\n- **Temporary Operations:** CommandNodeHelper is primarily used for temporary command removal and restoration. Permanent command modifications require different approaches.\n- **Mod Compatibility:** The `fabric` field exists for mod loader-specific compatibility. Most users will not need to access this directly.\n- **Permission Checks:** When re-registering commands, the original permission requirements and command structure are preserved.\n- **Thread Safety:** Command registration/unregistration should be done on the main thread. Use `JsMacros.schedule()` for delayed operations.\n- **Error Handling:** Always wrap command operations in try-catch blocks, as they can throw `IllegalAccessException` or other exceptions.\n\n## Related Classes\n\n- `CommandManager` - Main class for command registration and management\n- `CommandBuilder` - Used to create new commands\n- `FChat` - Legacy command methods (deprecated)\n- `BaseHelper` - Base class providing common helper functionality",
  "constructors": [],
  "methods": [
    {
      "name": "getRaw",
      "signature": "getRaw()",
      "returnType": "CommandNode<?>",
      "description": "Returns the underlying Brigadier `CommandNode` object.",
      "parameters": [],
      "static": false,
      "examples": [
        "const rawNode = commandNode.getRaw();\nChat.log(`Raw command node: ${rawNode.getClass().getName()}`);",
        "// Access the raw command node for advanced operations\nconst commandNode = Chat.getCommandManager().unregisterCommand(\"help\");\nif (commandNode) {\n    const rawNode = commandNode.getRaw();\n    // Use raw Brigadier API methods\n    const name = rawNode.getName();\n    const usage = rawNode.getUsageText();\n    Chat.log(`Command: ${name}, Usage: ${usage}`);\n}"
      ]
    },
    {
      "name": "equals",
      "signature": "equals(obj)",
      "returnType": "boolean",
      "description": "Compares this CommandNodeHelper to another object for equality.",
      "parameters": [
        {
          "name": "obj",
          "type": "Object",
          "description": "Object to compare with"
        }
      ],
      "static": false,
      "examples": [
        "// TODO: These do not reference the same command\nconst node1 = Chat.getCommandManager().unregisterCommand(\"test\");\nconst node2 = Chat.getCommandManager().unregisterCommand(\"test\");\nif (node1 && node2 && node1.equals(node2)) {\n    Chat.log(\"Both command nodes represent the same command\");\n}"
      ]
    },
    {
      "name": "hashCode",
      "signature": "hashCode()",
      "returnType": "int",
      "description": "Returns the hash code of the underlying command node.",
      "parameters": [],
      "static": false,
      "examples": [
        "const commandNode = Chat.getCommandManager().unregisterCommand(\"example\");\nif (commandNode) {\n    const hashCode = commandNode.hashCode();\n    Chat.log(`Command node hash code: ${hashCode}`);\n}"
      ]
    }
  ]
}