{
  "name": "XorFilter",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.filter.logical.XorFilter",
  "extends": "BasicFilter<T>",
  "since": "JSMacros 1.6.5",
  "description": "The `XorFilter` class is a logical filter that combines two filters using boolean XOR (exclusive OR) logic. It's part of the WorldScanner filtering system and allows you to create sophisticated filtering conditions where exactly one of the component filters must return `true` for the XorFilter to return `true`. This class is particularly useful when you need to filter blocks or entities based on mutually exclusive criteria. For example, finding blocks that are either valuable ores OR dangerous blocks, but not both at the same time.",
  "overview": "The XorFilter implements exclusive OR logic for precise filtering control:\n- **Exclusive OR**: Returns `true` only when exactly one of the filters returns `true`\n- **Mutual exclusion**: Perfect for scenarios where you want one condition but not both\n- **Generic type support**: Can work with any type `T` that the component filters can handle\n- **Fluent interface**: Inherits `and()`, `or()`, `xor()`, and `not()` methods from BasicFilter for chaining",
  "constructors": [
    {
      "signature": "new XorFilter(filterOne, filterTwo)",
      "description": "Creates a new XorFilter that combines two filters with XOR logic.",
      "parameters": [
        {
          "name": "filterOne",
          "type": "IFilter<T>",
          "description": "The first filter to evaluate"
        },
        {
          "name": "filterTwo",
          "type": "IFilter<T>",
          "description": "The second filter to evaluate"
        }
      ]
    }
  ],
  "methods": [
    {
      "name": "apply",
      "signature": "apply(obj)",
      "returnType": "Boolean",
      "description": "Applies the XOR filter logic to an object. Returns `true` only when exactly one of the two filters returns `true` for the given object. Note: This method evaluates both filters to determine the XOR result, unlike short-circuit operators.",
      "parameters": [
        {
          "name": "obj",
          "type": "T",
          "description": "The object to test against both filters"
        }
      ],
      "static": false,
      "examples": [
        "const testBlock = World.getBlock(100, 10, 200);\nconst passesFilter = interestingFilter.apply(testBlock);\n\nif (passesFilter) {\n    Chat.log(\"Block is either valuable OR dangerous, but not both!\");\n} else {\n    Chat.log(\"Block is either both valuable and dangerous, or neither\");\n}"
      ]
    },
    {
      "name": "getFilterOne",
      "signature": "getFilterOne()",
      "returnType": "IFilter<T>",
      "description": "Returns the first filter component.",
      "parameters": [],
      "static": false,
      "examples": [
        "const firstFilter = interestingFilter.getFilterOne();\nChat.log(`First filter: ${firstFilter.toString()}`);"
      ]
    },
    {
      "name": "getFilterTwo",
      "signature": "getFilterTwo()",
      "returnType": "IFilter<T>",
      "description": "Returns the second filter component.",
      "parameters": [],
      "static": false,
      "examples": [
        "const secondFilter = interestingFilter.getFilterTwo();\nChat.log(`Second filter: ${secondFilter.toString()}`);"
      ]
    }
  ]
}