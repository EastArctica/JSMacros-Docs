{
  "name": "WitchEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.WitchEntityHelper<T extends WitchEntity>",
  "extends": "MobEntityHelper<T>",
  "since": "JsMacros 1.8.4",
  "description": "Represents a witch entity in the world. WitchEntityHelper provides access to witch-specific properties and behaviors, particularly their potion drinking and throwing mechanics. Witches are hostile mobs that use potions for both offensive and defensive purposes, making them unique among hostile mobs due to their complex combat AI and support capabilities.",
  "overview": "Witch entities are magical hostile mobs that attack players by throwing harmful potions and can drink beneficial potions to heal themselves or gain resistance effects. They have distinct combat patterns involving drinking potions before engaging in combat and using various potion types depending on the situation. This helper provides access to their current drinking state and held potion items, which is crucial for understanding their combat behavior and predicting their next actions.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, AI control, movement, and other mob properties, while adding witch-specific functionality for potion state monitoring and inventory inspection.",
  "constructors": [
    {
      "signature": "N/A (Instances obtained through events/queries)",
      "description": "WitchEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through:\n\n- Entity-related events (e.g., `EntityDeath`, `EntityInteract`, `EntitySpawn`, `ProjectileHit`)\n- World entity queries and type casting\n- Methods that return witch entities\n- Type casting from EntityHelper using `as(\"minecraft:witch\")` or appropriate casting methods",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "isDrinkingPotion",
      "signature": "isDrinkingPotion()",
      "returnType": "boolean",
      "description": "Checks if the witch is currently drinking a potion. This state indicates vulnerability as witches cannot attack while drinking, offering a tactical window for players.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Real-time witch monitoring system for swamp and dark forest combat\nclass WitchCombatMonitor {\n    constructor() {\n        this.activeWitches = new Map();\n        this.alertCooldowns = new Map();\n        this.combatLog = [];\n        this.lastCleanup = 0;\n    }\n\n    updateWitch(witchEntity) {\n        const witch = witchEntity.as(\"minecraft:witch\");\n        if (!witch) return;\n\n        const uuid = witchEntity.getUUID();\n        const player = Player.getPlayer();\n        const isDrinking = witch.isDrinkingPotion();\n        const potion = witch.getPotion();\n        const distance = player.distanceTo(witchEntity);\n        const health = witchEntity.asLiving().getHealth();\n        const maxHealth = witchEntity.asLiving().getMaxHealth();\n        const pos = witchEntity.getPos();\n\n        if (!this.activeWitches.has(uuid)) {\n            // New witch detected\n            this.activeWitches.set(uuid, {\n                entity: witchEntity,\n                name: witchEntity.getName().getString(),\n                firstSeen: Client.getTime(),\n                lastDrinkingState: isDrinking,\n                drinkingPhases: 0,\n                potionHistory: [],\n                combatEngagement: null,\n                threatLevel: this.calculateThreatLevel(witchEntity, distance)\n            });\n\n            Chat.log(`&eüß™ Witch detected: ${witchEntity.getName().getString()}`);\n            Chat.log(`  Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Initial state: ${isDrinking ? \"Drinking\" : \"Ready to attack\"}`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n\n            // Alert player if witch is nearby and ready\n            if (distance <= 16 && !isDrinking) {\n                this.sendAlert(\"WITCH NEARBY - Ready to attack!\", \"danger\");\n            }\n        } else {\n            // Update existing witch tracking\n            const witchData = this.activeWitches.get(uuid);\n\n            // Track drinking state changes\n            if (witchData.lastDrinkingState !== isDrinking) {\n                witchData.drinkingPhases++;\n                witchData.lastDrinkingState = isDrinking;\n\n                const stateText = isDrinking ? \"DRINKING\" : \"READY TO ATTACK\";\n                Chat.log(`&6üîÑ ${witchData.name} state changed to: ${stateText}`);\n\n                // Alert for state changes\n                if (distance <= 12) {\n                    const alertMessage = isDrinking ?\n                        \"Witch drinking - Attack now!\" :\n                        \"Witch ready - Watch for potions!\";\n                    const alertType = isDrinking ? \"success\" : \"danger\";\n                    this.sendAlert(alertMessage, alertType);\n                }\n            }\n\n            // Track potion changes\n            if (potion && !potion.isEmpty()) {\n                const potionName = potion.getName().getString();\n                const lastPotion = witchData.potionHistory[witchData.potionHistory.length - 1];\n\n                if (!lastPotion || lastPotion.potionName !== potionName) {\n                    witchData.potionHistory.push({\n                        potionName: potionName,\n                        timestamp: Client.getTime(),\n                        isDrinking: isDrinking\n                    });\n\n                    if (distance <= 16) {\n                        Chat.log(`&d${witchData.name} now holding: ${potionName}`);\n                        this.analyzePotionThreat(potionName, distance);\n                    }\n                }\n            }\n\n            // Update threat level\n            witchData.threatLevel = this.calculateThreatLevel(witchEntity, distance);\n\n            // Monitor for combat engagement\n            if (distance <= 20) {\n                if (!witchData.combatEngagement) {\n                    witchData.combatEngagement = Client.getTime();\n                    Chat.log(`&c‚öîÔ∏è Combat engagement with ${witchData.name} at ${distance.toFixed(1)} blocks`);\n                }\n            } else {\n                if (witchData.combatEngagement && Client.getTime() - witchData.combatEngagement > 100) {\n                    const combatDuration = (Client.getTime() - witchData.combatEngagement) / 20;\n                    Chat.log(`&a‚úì Combat with ${witchData.name} ended after ${combatDuration.toFixed(1)} seconds`);\n                    witchData.combatEngagement = null;\n                }\n            }\n\n            // Periodic updates for nearby witches\n            if (distance <= 8 && Client.getTime() % 20 === 0) {\n                this.updateCombatStatus(witchData, distance, health, maxHealth);\n            }\n        }\n    }\n\n    calculateThreatLevel(witchEntity, distance) {\n        const health = witchEntity.asLiving().getHealth();\n        const maxHealth = witchEntity.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n        const witch = witchEntity.as(\"minecraft:witch\");\n        const isDrinking = witch && witch.isDrinkingPotion();\n\n        let threat = 0;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 6) threat += 50;\n        else if (distance <= 10) threat += 35;\n        else if (distance <= 16) threat += 20;\n        else threat += 10;\n\n        // Health threat (lower health = more desperate = more dangerous)\n        threat += (100 - healthPercent) * 0.4;\n\n        // Drinking state threat\n        if (!isDrinking) threat += 30; // Ready witches are more dangerous\n\n        return Math.min(threat, 100);\n    }\n\n    analyzePotionThreat(potionName, distance) {\n        const threatLevel = potionName.toLowerCase().includes(\"poison\") ||\n                           potionName.toLowerCase().includes(\"harming\") ? \"HIGH\" :\n                           potionName.toLowerCase().includes(\"healing\") ? \"MEDIUM\" : \"LOW\";\n\n        const recommendation = threatLevel === \"HIGH\" ?\n            \"&cDANGER: Attack potion incoming - dodge now!\" :\n            threatLevel === \"MEDIUM\" ?\n            \"&eWARNING: Witch healing - prevent recovery!\" :\n            \"&a‚úì Support potion - attack opportunity!\";\n\n        Chat.log(recommendation);\n\n        if (distance <= 8 && threatLevel === \"HIGH\") {\n            this.sendAlert(\"POTION ATTACK - Move away!\", \"critical\");\n        }\n    }\n\n    updateCombatStatus(witchData, distance, health, maxHealth) {\n        const witch = witchData.entity.as(\"minecraft:witch\");\n        const isDrinking = witch.isDrinkingPotion();\n        const healthPercent = (health / maxHealth) * 100;\n\n        let statusMessage = `${witchData.name}: `;\n\n        // State indicator\n        statusMessage += isDrinking ? \"üß™ \" : \"‚öîÔ∏è \";\n\n        // Health indicator\n        if (healthPercent > 75) statusMessage += \"üü¢\";\n        else if (healthPercent > 40) statusMessage += \"üü°\";\n        else statusMessage += \"üî¥\";\n\n        // Distance indicator\n        statusMessage += ` ${distance.toFixed(0)}m`;\n\n        // Threat level\n        statusMessage += ` [${witchData.threatLevel.toFixed(0)}%]`;\n\n        Chat.actionbar(statusMessage);\n    }\n\n    sendAlert(message, type = \"info\") {\n        const currentTime = Client.getTime();\n        const alertKey = `${message}_${type}`;\n\n        // Cooldown to prevent spam\n        if (!this.alertCooldowns.has(alertKey) ||\n            currentTime - this.alertCooldowns.get(alertKey) > 60) {\n\n            const prefix = {\n                \"warning\": \"&c‚ö†Ô∏è \",\n                \"danger\": \"&4üß™ \",\n                \"success\": \"&a‚úì \",\n                \"critical\": \"&4üö® \",\n                \"info\": \"&b‚ÑπÔ∏è \"\n            }[type] || \"&b‚ÑπÔ∏è \";\n\n            Chat.actionbar(`${prefix}${message}`);\n            this.alertCooldowns.set(alertKey, currentTime);\n        }\n    }\n\n    generateReport() {\n        if (this.activeWitches.size === 0) {\n            Chat.log(\"No witches currently tracked\");\n            return;\n        }\n\n        Chat.log(`&6=== Witch Combat Report (${this.activeWitches.size} witches) ===`);\n\n        let totalThreat = 0;\n        let drinkingWitches = 0;\n        let readyWitches = 0;\n        let inCombat = 0;\n\n        for (const [uuid, witchData] of this.activeWitches) {\n            const witch = witchData.entity.as(\"minecraft:witch\");\n            const isDrinking = witch.isDrinkingPotion();\n            const distance = Player.getPlayer().distanceTo(witchData.entity);\n            const trackingDuration = (Client.getTime() - witchData.firstSeen) / 20;\n\n            if (isDrinking) drinkingWitches++;\n            else readyWitches++;\n\n            if (witchData.combatEngagement) inCombat++;\n\n            totalThreat += witchData.threatLevel;\n\n            Chat.log(`\\n${witchData.name}:`);\n            Chat.log(`  State: ${isDrinking ? \"üß™ Drinking\" : \"‚öîÔ∏è Ready to attack\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Health: ${witchData.entity.asLiving().getHealth().toFixed(1)}/${witchData.entity.asLiving().getMaxHealth().toFixed(1)}`);\n            Chat.log(`  Threat Level: ${witchData.threatLevel.toFixed(0)}%`);\n            Chat.log(`  Drinking Phases: ${witchData.drinkingPhases}`);\n            Chat.log(`  Tracked for: ${trackingDuration.toFixed(1)}s`);\n            Chat.log(`  Potions Used: ${witchData.potionHistory.length}`);\n\n            if (witchData.potionHistory.length > 0) {\n                const recentPotions = witchData.potionHistory.slice(-3);\n                Chat.log(`  Recent Potions: ${recentPotions.map(p => p.potionName).join(\", \")}`);\n            }\n\n            if (witchData.combatEngagement) {\n                const combatDuration = (Client.getTime() - witchData.combatEngagement) / 20;\n                Chat.log(`  In Combat: ${combatDuration.toFixed(1)}s`);\n            }\n        }\n\n        // Summary\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Drinking Witches: ${drinkingWitches}`);\n        Chat.log(`Ready Witches: ${readyWitches}`);\n        Chat.log(`In Combat: ${inCombat}`);\n        Chat.log(`Average Threat Level: ${(totalThreat / this.activeWitches.size).toFixed(0)}%`);\n\n        // Warnings\n        if (readyWitches >= 2) {\n            Chat.log(`\\n&cüß™ CRITICAL: ${readyWitches} witches ready to attack!`);\n        } else if (readyWitches >= 1) {\n            Chat.log(`\\n&e‚ö†Ô∏è WARNING: ${readyWitches} witch ready to attack!`);\n        }\n\n        if (inCombat >= 2) {\n            Chat.log(`\\n&c‚öîÔ∏è MULTIPLE COMBAT engagements in progress!`);\n        }\n    }\n\n    cleanup() {\n        const currentTime = Client.getTime();\n\n        // Only cleanup every 5 seconds to avoid performance issues\n        if (currentTime - this.lastCleanup < 100) return;\n\n        this.lastCleanup = currentTime;\n\n        for (const [uuid, witchData] of this.activeWitches) {\n            if (!witchData.entity.isAlive()) {\n                const trackingDuration = (currentTime - witchData.firstSeen) / 20;\n                Chat.log(`&7${witchData.name} eliminated after ${trackingDuration.toFixed(1)}s`);\n                this.activeWitches.delete(uuid);\n            } else {\n                const distance = Player.getPlayer().distanceTo(witchData.entity);\n\n                // Remove witches that are too far away (64+ blocks)\n                if (distance > 64) {\n                    Chat.log(`&7${witchData.name} moved out of tracking range`);\n                    this.activeWitches.delete(uuid);\n                }\n            }\n        }\n    }\n}\n\nconst witchMonitor = new WitchCombatMonitor();\n\n// Monitor witches every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 32; // Track witches within 32 blocks\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= trackingRange && entity.is(\"minecraft:witch\")) {\n            witchMonitor.updateWitch(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        witchMonitor.cleanup();\n    }\n}));\n\n// Report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        witchMonitor.generateReport();\n    }\n}));",
        "// Advanced witch potion detection and analysis\nclass WitchPotionAnalyzer {\n    constructor() {\n        this.potionDatabase = new Map();\n        this.witchBehaviors = new Map();\n        this.combatPatterns = [];\n    }\n\n    analyzeWitchPotions(witchEntity) {\n        const witch = witchEntity.as(\"minecraft:witch\");\n        if (!witch) return;\n\n        const uuid = witchEntity.getUUID();\n        const potion = witch.getPotion();\n        const isDrinking = witch.isDrinkingPotion();\n        const currentTime = Client.getTime();\n\n        if (!this.witchBehaviors.has(uuid)) {\n            this.witchBehaviors.set(uuid, {\n                entity: witchEntity,\n                name: witchEntity.getName().getString(),\n                potionTimeline: [],\n                drinkingTimeline: [],\n                behaviorPatterns: [],\n                combatEffectiveness: 0,\n                potionPreference: new Map()\n            });\n        }\n\n        const behavior = this.witchBehaviors.get(uuid);\n\n        // Record potion states\n        if (potion && !potion.isEmpty()) {\n            const potionData = this.analyzePotion(potion);\n\n            behavior.potionTimeline.push({\n                potionData: potionData,\n                timestamp: currentTime,\n                isDrinking: isDrinking,\n                distance: Player.getPlayer().distanceTo(witchEntity),\n                health: witchEntity.asLiving().getHealth()\n            });\n\n            // Update potion preferences\n            const currentCount = behavior.potionPreference.get(potionData.type) || 0;\n            behavior.potionPreference.set(potionData.type, currentCount + 1);\n\n            // Analyze the tactical situation\n            this.analyzeTacticalSituation(behavior, potionData, isDrinking);\n        }\n\n        // Record drinking states\n        behavior.drinkingTimeline.push({\n            isDrinking: isDrinking,\n            timestamp: currentTime,\n            health: witchEntity.asLiving().getHealth()\n        });\n\n        // Keep only recent data (last 2 minutes)\n        const cutoffTime = currentTime - 2400;\n        behavior.potionTimeline = behavior.potionTimeline.filter(p => p.timestamp > cutoffTime);\n        behavior.drinkingTimeline = behavior.drinkingTimeline.filter(d => d.timestamp > cutoffTime);\n\n        // Detect behavior patterns\n        this.detectBehaviorPatterns(behavior);\n    }\n\n    analyzePotion(potion) {\n        const potionId = potion.getItemId();\n        const metadata = potion.getNBT();\n        const name = potion.getName().getString();\n\n        let potionType = \"unknown\";\n        let effect = \"unknown\";\n        let tacticalUse = \"unknown\";\n        let threatLevel = 0;\n\n        // Analyze potion ID to determine type and use\n        if (potionId.includes(\"healing\")) {\n            potionType = \"healing\";\n            effect = \"restore_health\";\n            tacticalUse = \"self_recovery\";\n            threatLevel = 60; // Medium threat - witch can recover\n        } else if (potionId.includes(\"fire_resistance\")) {\n            potionType = \"fire_resistance\";\n            effect = \"fire_immunity\";\n            tacticalUse = \"defensive\";\n            threatLevel = 70; // High threat - becomes immune to fire\n        } else if (potionId.includes(\"swiftness\")) {\n            potionType = \"swiftness\";\n            effect = \"speed_boost\";\n            tacticalUse = \"mobility\";\n            threatLevel = 80; // High threat - faster movement\n        } else if (potionId.includes(\"poison\")) {\n            potionType = \"poison\";\n            effect = \"damage_over_time\";\n            tacticalUse = \"offensive\";\n            threatLevel = 95; // Critical threat - poison attack\n        } else if (potionId.includes(\"harming\")) {\n            potionType = \"harming\";\n            effect = \"instant_damage\";\n            tacticalUse = \"offensive\";\n            threatLevel = 100; // Maximum threat - instant damage\n        } else if (potionId.includes(\"slowness\")) {\n            potionType = \"slowness\";\n            effect = \"movement_reduction\";\n            tacticalUse = \"offensive\";\n            threatLevel = 85; // High threat - mobility attack\n        } else if (potionId.includes(\"weakness\")) {\n            potionType = \"weakness\";\n            effect = \"damage_reduction\";\n            tacticalUse = \"offensive\";\n            threatLevel = 75; // High threat - reduces player damage\n        } else {\n            potionType = \"unknown\";\n            threatLevel = 50; // Unknown threat level\n        }\n\n        return {\n            name,\n            potionId,\n            type: potionType,\n            effect: effect,\n            tacticalUse: tacticalUse,\n            threatLevel: threatLevel,\n            isOffensive: tacticalUse === \"offensive\",\n            isDefensive: tacticalUse === \"defensive\" || tacticalUse === \"self_recovery\",\n            isSupport: tacticalUse === \"mobility\"\n        };\n    }\n\n    analyzeTacticalSituation(behavior, potionData, isDrinking) {\n        const distance = Player.getPlayer().distanceTo(behavior.entity);\n        const health = behavior.entity.asLiving().getHealth();\n        const maxHealth = behavior.entity.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n\n        let tacticalAnalysis = {\n            situation: \"unknown\",\n            urgency: \"normal\",\n            recommendation: \"\",\n            playerAction: \"\",\n            riskLevel: 0\n        };\n\n        if (potionData.isOffensive) {\n            tacticalAnalysis.situation = \"attack_preparation\";\n            tacticalAnalysis.urgency = distance < 12 ? \"critical\" : \"high\";\n            tacticalAnalysis.riskLevel = potionData.threatLevel;\n\n            if (distance < 8) {\n                tacticalAnalysis.recommendation = \"IMMEDIATE EVASION REQUIRED\";\n                tacticalAnalysis.playerAction = \"Dodge sideways and seek cover\";\n            } else if (distance < 16) {\n                tacticalAnalysis.recommendation = \"PREPARE TO DODGE\";\n                tacticalAnalysis.playerAction = \"Keep moving unpredictably\";\n            } else {\n                tacticalAnalysis.recommendation = \"MAINTAIN DISTANCE\";\n                tacticalAnalysis.playerAction = \"Ready shield or ranged weapons\";\n            }\n        } else if (potionData.isDefensive) {\n            tacticalAnalysis.situation = \"defense_preparation\";\n            tacticalAnalysis.urgency = isDrinking ? \"high\" : \"normal\";\n\n            if (potionData.type === \"healing\") {\n                tacticalAnalysis.recommendation = \"PREVENT HEALING\";\n                tacticalAnalysis.playerAction = \"Attack immediately to interrupt healing\";\n                tacticalAnalysis.riskLevel = 60;\n            } else if (potionData.type === \"fire_resistance\") {\n                tacticalAnalysis.recommendation = \"SWITCH TACTICS\";\n                tacticalAnalysis.playerAction = \"Use non-fire damage sources\";\n                tacticalAnalysis.riskLevel = 70;\n            }\n        } else if (potionData.isSupport) {\n            tacticalAnalysis.situation = \"mobility_preparation\";\n            tacticalAnalysis.urgency = distance > 16 ? \"high\" : \"normal\";\n            tacticalAnalysis.recommendation = \"COUNTER MOBILITY\";\n            tacticalAnalysis.playerAction = \"Prepare for faster movement or retreat\";\n            tacticalAnalysis.riskLevel = 80;\n        }\n\n        // Send tactical alerts\n        if (tacticalAnalysis.urgency === \"critical\") {\n            this.sendTacticalAlert(behavior.name, tacticalAnalysis, \"critical\");\n        } else if (tacticalAnalysis.urgency === \"high\") {\n            this.sendTacticalAlert(behavior.name, tacticalAnalysis, \"warning\");\n        }\n\n        // Log analysis\n        Chat.log(`&dTactical Analysis: ${behavior.name} with ${potionData.name}`);\n        Chat.log(`  Situation: ${tacticalAnalysis.situation}`);\n        Chat.log(`  Recommendation: ${tacticalAnalysis.recommendation}`);\n        Chat.log(`  Risk Level: ${tacticalAnalysis.riskLevel}%`);\n\n        return tacticalAnalysis;\n    }\n\n    sendTacticalAlert(witchName, analysis, level) {\n        const prefixes = {\n            \"critical\": \"&4üö® \",\n            \"warning\": \"&e‚ö†Ô∏è \",\n            \"normal\": \"&b‚ÑπÔ∏è \"\n        };\n\n        const prefix = prefixes[level] || prefixes.normal;\n        const message = `${prefix}${witchName}: ${analysis.recommendation}`;\n\n        Chat.actionbar(message);\n        Chat.log(message);\n\n        if (level === \"critical\") {\n            Chat.log(`&6‚Üí ${analysis.playerAction}`);\n        }\n    }\n\n    detectBehaviorPatterns(behavior) {\n        if (behavior.potionTimeline.length < 3) return; // Need more data\n\n        // Analyze potion usage patterns\n        const recentPotions = behavior.potionTimeline.slice(-5);\n        const drinkingStates = behavior.drinkingTimeline.slice(-10);\n\n        // Detect aggressive vs defensive patterns\n        const offensivePotions = recentPotions.filter(p => p.potionData.isOffensive).length;\n        const defensivePotions = recentPotions.filter(p => p.potionData.isDefensive).length;\n\n        if (offensivePotions > defensivePotions * 2) {\n            behavior.behaviorPatterns.push(\"aggressive_combat\");\n        } else if (defensivePotions > offensivePotions * 2) {\n            behavior.behaviorPatterns.push(\"defensive_combat\");\n        } else {\n            behavior.behaviorPatterns.push(\"balanced_combat\");\n        }\n\n        // Detect drinking frequency patterns\n        const drinkingTime = drinkingStates.filter(d => d.isDrinking).length;\n        const drinkingFrequency = drinkingTime / drinkingStates.length;\n\n        if (drinkingFrequency > 0.5) {\n            behavior.behaviorPatterns.push(\"frequent_drinker\");\n        }\n\n        // Keep only recent patterns\n        behavior.behaviorPatterns = behavior.behaviorPatterns.slice(-5);\n    }\n\n    generateBehaviorReport() {\n        if (this.witchBehaviors.size === 0) {\n            Chat.log(\"No witch behavior data available\");\n            return;\n        }\n\n        Chat.log(`&6=== Witch Behavior Analysis Report ===`);\n\n        for (const [uuid, behavior] of this.witchBehaviors) {\n            const distance = Player.getPlayer().distanceTo(behavior.entity);\n            const witch = behavior.entity.as(\"minecraft:witch\");\n            const isDrinking = witch.isDrinkingPotion();\n\n            Chat.log(`\\n${behavior.name}:`);\n            Chat.log(`  Current State: ${isDrinking ? \"üß™ Drinking\" : \"‚öîÔ∏è Ready\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Total Potions Observed: ${behavior.potionTimeline.length}`);\n            Chat.log(`  Drinking Phases: ${behavior.drinkingTimeline.filter(d => d.isDrinking).length}`);\n\n            if (behavior.potionPreference.size > 0) {\n                Chat.log(`  Potion Preferences:`);\n                for (const [type, count] of behavior.potionPreference) {\n                    Chat.log(`    ${type}: ${count} uses`);\n                }\n            }\n\n            if (behavior.behaviorPatterns.length > 0) {\n                Chat.log(`  Detected Patterns: ${behavior.behaviorPatterns.join(\", \")}`);\n            }\n\n            // Provide tactical summary\n            this.generateTacticalSummary(behavior);\n        }\n    }\n\n    generateTacticalSummary(behavior) {\n        const patterns = behavior.behaviorPatterns;\n        const preferences = behavior.potionPreference;\n        const witch = behavior.entity.as(\"minecraft:witch\");\n        const isDrinking = witch.isDrinkingPotion();\n\n        Chat.log(`  Tactical Summary:`);\n\n        if (patterns.includes(\"aggressive_combat\")) {\n            Chat.log(\"    &eThis witch is highly aggressive - expect frequent attacks\");\n            Chat.log(\"    ‚Üí Maintain distance and use cover\");\n        } else if (patterns.includes(\"defensive_combat\")) {\n            Chat.log(\"    &aThis witch is defensive - opportunities for aggressive play\");\n            Chat.log(\"    ‚Üí Attack during drinking phases\");\n        } else {\n            Chat.log(\"    &6This witch uses balanced tactics - adaptable strategy needed\");\n            Chat.log(\"    ‚Üí Watch for both offensive and defensive potions\");\n        }\n\n        if (patterns.includes(\"frequent_drinker\")) {\n            Chat.log(\"    &dWitch drinks potions frequently\");\n            Chat.log(\"    ‚Üí Many attack opportunities during drinking phases\");\n        }\n\n        // Current tactical recommendation\n        if (isDrinking) {\n            Chat.log(\"    &aCURRENT: Perfect time to attack!\");\n        } else {\n            const currentPotion = witch.getPotion();\n            if (currentPotion && !currentPotion.isEmpty()) {\n                const potionData = this.analyzePotion(currentPotion);\n                if (potionData.isOffensive) {\n                    Chat.log(\"    &cCURRENT: Witch preparing to attack - dodge!\");\n                } else if (potionData.isDefensive) {\n                    Chat.log(\"    &eCURRENT: Witch preparing defense - act fast!\");\n                }\n            }\n        }\n    }\n}\n\nconst potionAnalyzer = new WitchPotionAnalyzer();\n\n// Analyze witch potions every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 24;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:witch\")) {\n            potionAnalyzer.analyzeWitchPotions(entity);\n        }\n    });\n}));\n\n// Behavior analysis command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.p\" && e.action === 1) { // P key\n        potionAnalyzer.generateBehaviorReport();\n    }\n}));"
      ]
    },
    {
      "name": "getPotion",
      "signature": "getPotion()",
      "returnType": "ItemStackHelper",
      "description": "Retrieves the `ItemStackHelper` representing the potion item the witch is currently holding or consuming. This method is crucial for identifying the witch's immediate offensive or defensive intentions.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Real-time witch monitoring system for swamp and dark forest combat\nclass WitchCombatMonitor {\n    constructor() {\n        this.activeWitches = new Map();\n        this.alertCooldowns = new Map();\n        this.combatLog = [];\n        this.lastCleanup = 0;\n    }\n\n    updateWitch(witchEntity) {\n        const witch = witchEntity.as(\"minecraft:witch\");\n        if (!witch) return;\n\n        const uuid = witchEntity.getUUID();\n        const player = Player.getPlayer();\n        const isDrinking = witch.isDrinkingPotion();\n        const potion = witch.getPotion();\n        const distance = player.distanceTo(witchEntity);\n        const health = witchEntity.asLiving().getHealth();\n        const maxHealth = witchEntity.asLiving().getMaxHealth();\n        const pos = witchEntity.getPos();\n\n        if (!this.activeWitches.has(uuid)) {\n            // New witch detected\n            this.activeWitches.set(uuid, {\n                entity: witchEntity,\n                name: witchEntity.getName().getString(),\n                firstSeen: Client.getTime(),\n                lastDrinkingState: isDrinking,\n                drinkingPhases: 0,\n                potionHistory: [],\n                combatEngagement: null,\n                threatLevel: this.calculateThreatLevel(witchEntity, distance)\n            });\n\n            Chat.log(`&eüß™ Witch detected: ${witchEntity.getName().getString()}`);\n            Chat.log(`  Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Initial state: ${isDrinking ? \"Drinking\" : \"Ready to attack\"}`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n\n            // Alert player if witch is nearby and ready\n            if (distance <= 16 && !isDrinking) {\n                this.sendAlert(\"WITCH NEARBY - Ready to attack!\", \"danger\");\n            }\n        } else {\n            // Update existing witch tracking\n            const witchData = this.activeWitches.get(uuid);\n\n            // Track drinking state changes\n            if (witchData.lastDrinkingState !== isDrinking) {\n                witchData.drinkingPhases++;\n                witchData.lastDrinkingState = isDrinking;\n\n                const stateText = isDrinking ? \"DRINKING\" : \"READY TO ATTACK\";\n                Chat.log(`&6üîÑ ${witchData.name} state changed to: ${stateText}`);\n\n                // Alert for state changes\n                if (distance <= 12) {\n                    const alertMessage = isDrinking ?\n                        \"Witch drinking - Attack now!\" :\n                        \"Witch ready - Watch for potions!\";\n                    const alertType = isDrinking ? \"success\" : \"danger\";\n                    this.sendAlert(alertMessage, alertType);\n                }\n            }\n\n            // Track potion changes\n            if (potion && !potion.isEmpty()) {\n                const potionName = potion.getName().getString();\n                const lastPotion = witchData.potionHistory[witchData.potionHistory.length - 1];\n\n                if (!lastPotion || lastPotion.potionName !== potionName) {\n                    witchData.potionHistory.push({\n                        potionName: potionName,\n                        timestamp: Client.getTime(),\n                        isDrinking: isDrinking\n                    });\n\n                    if (distance <= 16) {\n                        Chat.log(`&d${witchData.name} now holding: ${potionName}`);\n                        this.analyzePotionThreat(potionName, distance);\n                    }\n                }\n            }\n\n            // Update threat level\n            witchData.threatLevel = this.calculateThreatLevel(witchEntity, distance);\n\n            // Monitor for combat engagement\n            if (distance <= 20) {\n                if (!witchData.combatEngagement) {\n                    witchData.combatEngagement = Client.getTime();\n                    Chat.log(`&c‚öîÔ∏è Combat engagement with ${witchData.name} at ${distance.toFixed(1)} blocks`);\n                }\n            } else {\n                if (witchData.combatEngagement && Client.getTime() - witchData.combatEngagement > 100) {\n                    const combatDuration = (Client.getTime() - witchData.combatEngagement) / 20;\n                    Chat.log(`&a‚úì Combat with ${witchData.name} ended after ${combatDuration.toFixed(1)} seconds`);\n                    witchData.combatEngagement = null;\n                }\n            }\n\n            // Periodic updates for nearby witches\n            if (distance <= 8 && Client.getTime() % 20 === 0) {\n                this.updateCombatStatus(witchData, distance, health, maxHealth);\n            }\n        }\n    }\n\n    calculateThreatLevel(witchEntity, distance) {\n        const health = witchEntity.asLiving().getHealth();\n        const maxHealth = witchEntity.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n        const witch = witchEntity.as(\"minecraft:witch\");\n        const isDrinking = witch && witch.isDrinkingPotion();\n\n        let threat = 0;\n\n        // Distance threat (closer is more dangerous)\n        if (distance <= 6) threat += 50;\n        else if (distance <= 10) threat += 35;\n        else if (distance <= 16) threat += 20;\n        else threat += 10;\n\n        // Health threat (lower health = more desperate = more dangerous)\n        threat += (100 - healthPercent) * 0.4;\n\n        // Drinking state threat\n        if (!isDrinking) threat += 30; // Ready witches are more dangerous\n\n        return Math.min(threat, 100);\n    }\n\n    analyzePotionThreat(potionName, distance) {\n        const threatLevel = potionName.toLowerCase().includes(\"poison\") ||\n                           potionName.toLowerCase().includes(\"harming\") ? \"HIGH\" :\n                           potionName.toLowerCase().includes(\"healing\") ? \"MEDIUM\" : \"LOW\";\n\n        const recommendation = threatLevel === \"HIGH\" ?\n            \"&cDANGER: Attack potion incoming - dodge now!\" :\n            threatLevel === \"MEDIUM\" ?\n            \"&eWARNING: Witch healing - prevent recovery!\" :\n            \"&a‚úì Support potion - attack opportunity!\";\n\n        Chat.log(recommendation);\n\n        if (distance <= 8 && threatLevel === \"HIGH\") {\n            this.sendAlert(\"POTION ATTACK - Move away!\", \"critical\");\n        }\n    }\n\n    updateCombatStatus(witchData, distance, health, maxHealth) {\n        const witch = witchData.entity.as(\"minecraft:witch\");\n        const isDrinking = witch.isDrinkingPotion();\n        const healthPercent = (health / maxHealth) * 100;\n\n        let statusMessage = `${witchData.name}: `;\n\n        // State indicator\n        statusMessage += isDrinking ? \"üß™ \" : \"‚öîÔ∏è \";\n\n        // Health indicator\n        if (healthPercent > 75) statusMessage += \"üü¢\";\n        else if (healthPercent > 40) statusMessage += \"üü°\";\n        else statusMessage += \"üî¥\";\n\n        // Distance indicator\n        statusMessage += ` ${distance.toFixed(0)}m`;\n\n        // Threat level\n        statusMessage += ` [${witchData.threatLevel.toFixed(0)}%]`;\n\n        Chat.actionbar(statusMessage);\n    }\n\n    sendAlert(message, type = \"info\") {\n        const currentTime = Client.getTime();\n        const alertKey = `${message}_${type}`;\n\n        // Cooldown to prevent spam\n        if (!this.alertCooldowns.has(alertKey) ||\n            currentTime - this.alertCooldowns.get(alertKey) > 60) {\n\n            const prefix = {\n                \"warning\": \"&c‚ö†Ô∏è \",\n                \"danger\": \"&4üß™ \",\n                \"success\": \"&a‚úì \",\n                \"critical\": \"&4üö® \",\n                \"info\": \"&b‚ÑπÔ∏è \"\n            }[type] || \"&b‚ÑπÔ∏è \";\n\n            Chat.actionbar(`${prefix}${message}`);\n            this.alertCooldowns.set(alertKey, currentTime);\n        }\n    }\n\n    generateReport() {\n        if (this.activeWitches.size === 0) {\n            Chat.log(\"No witches currently tracked\");\n            return;\n        }\n\n        Chat.log(`&6=== Witch Combat Report (${this.activeWitches.size} witches) ===`);\n\n        let totalThreat = 0;\n        let drinkingWitches = 0;\n        let readyWitches = 0;\n        let inCombat = 0;\n\n        for (const [uuid, witchData] of this.activeWitches) {\n            const witch = witchData.entity.as(\"minecraft:witch\");\n            const isDrinking = witch.isDrinkingPotion();\n            const distance = Player.getPlayer().distanceTo(witchData.entity);\n            const trackingDuration = (Client.getTime() - witchData.firstSeen) / 20;\n\n            if (isDrinking) drinkingWitches++;\n            else readyWitches++;\n\n            if (witchData.combatEngagement) inCombat++;\n\n            totalThreat += witchData.threatLevel;\n\n            Chat.log(`\\n${witchData.name}:`);\n            Chat.log(`  State: ${isDrinking ? \"üß™ Drinking\" : \"‚öîÔ∏è Ready to attack\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Health: ${witchData.entity.asLiving().getHealth().toFixed(1)}/${witchData.entity.asLiving().getMaxHealth().toFixed(1)}`);\n            Chat.log(`  Threat Level: ${witchData.threatLevel.toFixed(0)}%`);\n            Chat.log(`  Drinking Phases: ${witchData.drinkingPhases}`);\n            Chat.log(`  Tracked for: ${trackingDuration.toFixed(1)}s`);\n            Chat.log(`  Potions Used: ${witchData.potionHistory.length}`);\n\n            if (witchData.potionHistory.length > 0) {\n                const recentPotions = witchData.potionHistory.slice(-3);\n                Chat.log(`  Recent Potions: ${recentPotions.map(p => p.potionName).join(\", \")}`);\n            }\n\n            if (witchData.combatEngagement) {\n                const combatDuration = (Client.getTime() - witchData.combatEngagement) / 20;\n                Chat.log(`  In Combat: ${combatDuration.toFixed(1)}s`);\n            }\n        }\n\n        // Summary\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Drinking Witches: ${drinkingWitches}`);\n        Chat.log(`Ready Witches: ${readyWitches}`);\n        Chat.log(`In Combat: ${inCombat}`);\n        Chat.log(`Average Threat Level: ${(totalThreat / this.activeWitches.size).toFixed(0)}%`);\n\n        // Warnings\n        if (readyWitches >= 2) {\n            Chat.log(`\\n&cüß™ CRITICAL: ${readyWitches} witches ready to attack!`);\n        } else if (readyWitches >= 1) {\n            Chat.log(`\\n&e‚ö†Ô∏è WARNING: ${readyWitches} witch ready to attack!`);\n        }\n\n        if (inCombat >= 2) {\n            Chat.log(`\\n&c‚öîÔ∏è MULTIPLE COMBAT engagements in progress!`);\n        }\n    }\n\n    cleanup() {\n        const currentTime = Client.getTime();\n\n        // Only cleanup every 5 seconds to avoid performance issues\n        if (currentTime - this.lastCleanup < 100) return;\n\n        this.lastCleanup = currentTime;\n\n        for (const [uuid, witchData] of this.activeWitches) {\n            if (!witchData.entity.isAlive()) {\n                const trackingDuration = (currentTime - witchData.firstSeen) / 20;\n                Chat.log(`&7${witchData.name} eliminated after ${trackingDuration.toFixed(1)}s`);\n                this.activeWitches.delete(uuid);\n            } else {\n                const distance = Player.getPlayer().distanceTo(witchData.entity);\n\n                // Remove witches that are too far away (64+ blocks)\n                if (distance > 64) {\n                    Chat.log(`&7${witchData.name} moved out of tracking range`);\n                    this.activeWitches.delete(uuid);\n                }\n            }\n        }\n    }\n}\n\nconst witchMonitor = new WitchCombatMonitor();\n\n// Monitor witches every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const trackingRange = 32; // Track witches within 32 blocks\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= trackingRange && entity.is(\"minecraft:witch\")) {\n            witchMonitor.updateWitch(entity);\n        }\n    });\n\n    // Cleanup every 5 seconds\n    if (Client.getTime() % 100 === 0) {\n        witchMonitor.cleanup();\n    }\n}));\n\n// Report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.w\" && e.action === 1) { // W key\n        witchMonitor.generateReport();\n    }\n}));",
        "// Advanced witch potion detection and analysis\nclass WitchPotionAnalyzer {\n    constructor() {\n        this.potionDatabase = new Map();\n        this.witchBehaviors = new Map();\n        this.combatPatterns = [];\n    }\n\n    analyzeWitchPotions(witchEntity) {\n        const witch = witchEntity.as(\"minecraft:witch\");\n        if (!witch) return;\n\n        const uuid = witchEntity.getUUID();\n        const potion = witch.getPotion();\n        const isDrinking = witch.isDrinkingPotion();\n        const currentTime = Client.getTime();\n\n        if (!this.witchBehaviors.has(uuid)) {\n            this.witchBehaviors.set(uuid, {\n                entity: witchEntity,\n                name: witchEntity.getName().getString(),\n                potionTimeline: [],\n                drinkingTimeline: [],\n                behaviorPatterns: [],\n                combatEffectiveness: 0,\n                potionPreference: new Map()\n            });\n        }\n\n        const behavior = this.witchBehaviors.get(uuid);\n\n        // Record potion states\n        if (potion && !potion.isEmpty()) {\n            const potionData = this.analyzePotion(potion);\n\n            behavior.potionTimeline.push({\n                potionData: potionData,\n                timestamp: currentTime,\n                isDrinking: isDrinking,\n                distance: Player.getPlayer().distanceTo(witchEntity),\n                health: witchEntity.asLiving().getHealth()\n            });\n\n            // Update potion preferences\n            const currentCount = behavior.potionPreference.get(potionData.type) || 0;\n            behavior.potionPreference.set(potionData.type, currentCount + 1);\n\n            // Analyze the tactical situation\n            this.analyzeTacticalSituation(behavior, potionData, isDrinking);\n        }\n\n        // Record drinking states\n        behavior.drinkingTimeline.push({\n            isDrinking: isDrinking,\n            timestamp: currentTime,\n            health: witchEntity.asLiving().getHealth()\n        });\n\n        // Keep only recent data (last 2 minutes)\n        const cutoffTime = currentTime - 2400;\n        behavior.potionTimeline = behavior.potionTimeline.filter(p => p.timestamp > cutoffTime);\n        behavior.drinkingTimeline = behavior.drinkingTimeline.filter(d => d.timestamp > cutoffTime);\n\n        // Detect behavior patterns\n        this.detectBehaviorPatterns(behavior);\n    }\n\n    analyzePotion(potion) {\n        const potionId = potion.getItemId();\n        const metadata = potion.getNBT();\n        const name = potion.getName().getString();\n\n        let potionType = \"unknown\";\n        let effect = \"unknown\";\n        let tacticalUse = \"unknown\";\n        let threatLevel = 0;\n\n        // Analyze potion ID to determine type and use\n        if (potionId.includes(\"healing\")) {\n            potionType = \"healing\";\n            effect = \"restore_health\";\n            tacticalUse = \"self_recovery\";\n            threatLevel = 60; // Medium threat - witch can recover\n        } else if (potionId.includes(\"fire_resistance\")) {\n            potionType = \"fire_resistance\";\n            effect = \"fire_immunity\";\n            tacticalUse = \"defensive\";\n            threatLevel = 70; // High threat - becomes immune to fire\n        } else if (potionId.includes(\"swiftness\")) {\n            potionType = \"swiftness\";\n            effect = \"speed_boost\";\n            tacticalUse = \"mobility\";\n            threatLevel = 80; // High threat - faster movement\n        } else if (potionId.includes(\"poison\")) {\n            potionType = \"poison\";\n            effect = \"damage_over_time\";\n            tacticalUse = \"offensive\";\n            threatLevel = 95; // Critical threat - poison attack\n        } else if (potionId.includes(\"harming\")) {\n            potionType = \"harming\";\n            effect = \"instant_damage\";\n            tacticalUse = \"offensive\";\n            threatLevel = 100; // Maximum threat - instant damage\n        } else if (potionId.includes(\"slowness\")) {\n            potionType = \"slowness\";\n            effect = \"movement_reduction\";\n            tacticalUse = \"offensive\";\n            threatLevel = 85; // High threat - mobility attack\n        } else if (potionId.includes(\"weakness\")) {\n            potionType = \"weakness\";\n            effect = \"damage_reduction\";\n            tacticalUse = \"offensive\";\n            threatLevel = 75; // High threat - reduces player damage\n        } else {\n            potionType = \"unknown\";\n            threatLevel = 50; // Unknown threat level\n        }\n\n        return {\n            name,\n            potionId,\n            type: potionType,\n            effect: effect,\n            tacticalUse: tacticalUse,\n            threatLevel: threatLevel,\n            isOffensive: tacticalUse === \"offensive\",\n            isDefensive: tacticalUse === \"defensive\" || tacticalUse === \"self_recovery\",\n            isSupport: tacticalUse === \"mobility\"\n        };\n    }\n\n    analyzeTacticalSituation(behavior, potionData, isDrinking) {\n        const distance = Player.getPlayer().distanceTo(behavior.entity);\n        const health = behavior.entity.asLiving().getHealth();\n        const maxHealth = behavior.entity.asLiving().getMaxHealth();\n        const healthPercent = (health / maxHealth) * 100;\n\n        let tacticalAnalysis = {\n            situation: \"unknown\",\n            urgency: \"normal\",\n            recommendation: \"\",\n            playerAction: \"\",\n            riskLevel: 0\n        };\n\n        if (potionData.isOffensive) {\n            tacticalAnalysis.situation = \"attack_preparation\";\n            tacticalAnalysis.urgency = distance < 12 ? \"critical\" : \"high\";\n            tacticalAnalysis.riskLevel = potionData.threatLevel;\n\n            if (distance < 8) {\n                tacticalAnalysis.recommendation = \"IMMEDIATE EVASION REQUIRED\";\n                tacticalAnalysis.playerAction = \"Dodge sideways and seek cover\";\n            } else if (distance < 16) {\n                tacticalAnalysis.recommendation = \"PREPARE TO DODGE\";\n                tacticalAnalysis.playerAction = \"Keep moving unpredictably\";\n            } else {\n                tacticalAnalysis.recommendation = \"MAINTAIN DISTANCE\";\n                tacticalAnalysis.playerAction = \"Ready shield or ranged weapons\";\n            }\n        } else if (potionData.isDefensive) {\n            tacticalAnalysis.situation = \"defense_preparation\";\n            tacticalAnalysis.urgency = isDrinking ? \"high\" : \"normal\";\n\n            if (potionData.type === \"healing\") {\n                tacticalAnalysis.recommendation = \"PREVENT HEALING\";\n                tacticalAnalysis.playerAction = \"Attack immediately to interrupt healing\";\n                tacticalAnalysis.riskLevel = 60;\n            } else if (potionData.type === \"fire_resistance\") {\n                tacticalAnalysis.recommendation = \"SWITCH TACTICS\";\n                tacticalAnalysis.playerAction = \"Use non-fire damage sources\";\n                tacticalAnalysis.riskLevel = 70;\n            }\n        } else if (potionData.isSupport) {\n            tacticalAnalysis.situation = \"mobility_preparation\";\n            tacticalAnalysis.urgency = distance > 16 ? \"high\" : \"normal\";\n            tacticalAnalysis.recommendation = \"COUNTER MOBILITY\";\n            tacticalAnalysis.playerAction = \"Prepare for faster movement or retreat\";\n            tacticalAnalysis.riskLevel = 80;\n        }\n\n        // Send tactical alerts\n        if (tacticalAnalysis.urgency === \"critical\") {\n            this.sendTacticalAlert(behavior.name, tacticalAnalysis, \"critical\");\n        } else if (tacticalAnalysis.urgency === \"high\") {\n            this.sendTacticalAlert(behavior.name, tacticalAnalysis, \"warning\");\n        }\n\n        // Log analysis\n        Chat.log(`&dTactical Analysis: ${behavior.name} with ${potionData.name}`);\n        Chat.log(`  Situation: ${tacticalAnalysis.situation}`);\n        Chat.log(`  Recommendation: ${tacticalAnalysis.recommendation}`);\n        Chat.log(`  Risk Level: ${tacticalAnalysis.riskLevel}%`);\n\n        return tacticalAnalysis;\n    }\n\n    sendTacticalAlert(witchName, analysis, level) {\n        const prefixes = {\n            \"critical\": \"&4üö® \",\n            \"warning\": \"&e‚ö†Ô∏è \",\n            \"normal\": \"&b‚ÑπÔ∏è \"\n        };\n\n        const prefix = prefixes[level] || prefixes.normal;\n        const message = `${prefix}${witchName}: ${analysis.recommendation}`;\n\n        Chat.actionbar(message);\n        Chat.log(message);\n\n        if (level === \"critical\") {\n            Chat.log(`&6‚Üí ${analysis.playerAction}`);\n        }\n    }\n\n    detectBehaviorPatterns(behavior) {\n        if (behavior.potionTimeline.length < 3) return; // Need more data\n\n        // Analyze potion usage patterns\n        const recentPotions = behavior.potionTimeline.slice(-5);\n        const drinkingStates = behavior.drinkingTimeline.slice(-10);\n\n        // Detect aggressive vs defensive patterns\n        const offensivePotions = recentPotions.filter(p => p.potionData.isOffensive).length;\n        const defensivePotions = recentPotions.filter(p => p.potionData.isDefensive).length;\n\n        if (offensivePotions > defensivePotions * 2) {\n            behavior.behaviorPatterns.push(\"aggressive_combat\");\n        } else if (defensivePotions > offensivePotions * 2) {\n            behavior.behaviorPatterns.push(\"defensive_combat\");\n        } else {\n            behavior.behaviorPatterns.push(\"balanced_combat\");\n        }\n\n        // Detect drinking frequency patterns\n        const drinkingTime = drinkingStates.filter(d => d.isDrinking).length;\n        const drinkingFrequency = drinkingTime / drinkingStates.length;\n\n        if (drinkingFrequency > 0.5) {\n            behavior.behaviorPatterns.push(\"frequent_drinker\");\n        }\n\n        // Keep only recent patterns\n        behavior.behaviorPatterns = behavior.behaviorPatterns.slice(-5);\n    }\n\n    generateBehaviorReport() {\n        if (this.witchBehaviors.size === 0) {\n            Chat.log(\"No witch behavior data available\");\n            return;\n        }\n\n        Chat.log(`&6=== Witch Behavior Analysis Report ===`);\n\n        for (const [uuid, behavior] of this.witchBehaviors) {\n            const distance = Player.getPlayer().distanceTo(behavior.entity);\n            const witch = behavior.entity.as(\"minecraft:witch\");\n            const isDrinking = witch.isDrinkingPotion();\n\n            Chat.log(`\\n${behavior.name}:`);\n            Chat.log(`  Current State: ${isDrinking ? \"üß™ Drinking\" : \"‚öîÔ∏è Ready\"}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Total Potions Observed: ${behavior.potionTimeline.length}`);\n            Chat.log(`  Drinking Phases: ${behavior.drinkingTimeline.filter(d => d.isDrinking).length}`);\n\n            if (behavior.potionPreference.size > 0) {\n                Chat.log(`  Potion Preferences:`);\n                for (const [type, count] of behavior.potionPreference) {\n                    Chat.log(`    ${type}: ${count} uses`);\n                }\n            }\n\n            if (behavior.behaviorPatterns.length > 0) {\n                Chat.log(`  Detected Patterns: ${behavior.behaviorPatterns.join(\", \")}`);\n            }\n\n            // Provide tactical summary\n            this.generateTacticalSummary(behavior);\n        }\n    }\n\n    generateTacticalSummary(behavior) {\n        const patterns = behavior.behaviorPatterns;\n        const preferences = behavior.potionPreference;\n        const witch = behavior.entity.as(\"minecraft:witch\");\n        const isDrinking = witch.isDrinkingPotion();\n\n        Chat.log(`  Tactical Summary:`);\n\n        if (patterns.includes(\"aggressive_combat\")) {\n            Chat.log(\"    &eThis witch is highly aggressive - expect frequent attacks\");\n            Chat.log(\"    ‚Üí Maintain distance and use cover\");\n        } else if (patterns.includes(\"defensive_combat\")) {\n            Chat.log(\"    &aThis witch is defensive - opportunities for aggressive play\");\n            Chat.log(\"    ‚Üí Attack during drinking phases\");\n        } else {\n            Chat.log(\"    &6This witch uses balanced tactics - adaptable strategy needed\");\n            Chat.log(\"    ‚Üí Watch for both offensive and defensive potions\");\n        }\n\n        if (patterns.includes(\"frequent_drinker\")) {\n            Chat.log(\"    &dWitch drinks potions frequently\");\n            Chat.log(\"    ‚Üí Many attack opportunities during drinking phases\");\n        }\n\n        // Current tactical recommendation\n        if (isDrinking) {\n            Chat.log(\"    &aCURRENT: Perfect time to attack!\");\n        } else {\n            const currentPotion = witch.getPotion();\n            if (currentPotion && !currentPotion.isEmpty()) {\n                const potionData = this.analyzePotion(currentPotion);\n                if (potionData.isOffensive) {\n                    Chat.log(\"    &cCURRENT: Witch preparing to attack - dodge!\");\n                } else if (potionData.isDefensive) {\n                    Chat.log(\"    &eCURRENT: Witch preparing defense - act fast!\");\n                }\n            }\n        }\n    }\n}\n\nconst potionAnalyzer = new WitchPotionAnalyzer();\n\n// Analyze witch potions every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 24;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:witch\")) {\n            potionAnalyzer.analyzeWitchPotions(entity);\n        }\n    });\n}));\n\n// Behavior analysis command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.p\" && e.action === 1) { // P key\n        potionAnalyzer.generateBehaviorReport();\n    }\n}));"
      ]
    }
  ]
}