{
  "name": "DolphinEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.DolphinEntityHelper",
  "extends": "MobEntityHelper<DolphinEntity>",
  "since": "1.8.4",
  "description": "The `DolphinEntityHelper` class provides specialized access to dolphin entities in Minecraft, offering methods to monitor and interact with dolphin-specific behaviors such as fish carrying, treasure hunting, and moisture levels. This class extends `MobEntityHelper` and inherits all functionality for mob entities including AI states, pathfinding, and combat behaviors.",
  "overview": "Dolphins are aquatic passive mobs that spawn in ocean biomes and are known for their playful behavior, ability to lead players to treasure, and unique moisture mechanic that requires them to remain in water to survive.",
  "constructors": [],
  "methods": [
    {
      "name": "hasFish",
      "signature": "const hasFish = dolphin.hasFish();",
      "returnType": "boolean",
      "description": "Returns whether the dolphin is currently carrying a fish in its mouth. Dolphins can pick up fish items and will hold them until they eat them or drop them.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive dolphin monitoring and behavior analysis system\nclass DolphinMonitor {\n    constructor() {\n        this.trackedDolphins = new Map();\n        this.alertLevels = {\n            lowMoisture: 600,    // 30 seconds - get back in water!\n            criticalMoisture: 300, // 15 seconds - critical damage imminent\n            treasureNear: 50      // 50 blocks - treasure is nearby\n        };\n    }\n\n    updateDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const uuid = dolphin.getUUID();\n        const pos = dolphin.getPos();\n\n        const dolphinData = {\n            dolphin: dolphin,\n            hasFish: dolphin.hasFish(),\n            treasurePos: dolphin.getTreasurePos(),\n            moistness: dolphin.getMoistness(),\n            position: pos,\n            lastUpdate: Client.getTime()\n        };\n\n        // Check if this is a new dolphin\n        if (!this.trackedDolphins.has(uuid)) {\n            Chat.log(`&aDiscovered dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            dolphin.setGlowing(true);\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for water creatures\n        }\n\n        // Analyze dolphin state\n        this.analyzeDolphinState(dolphinData);\n\n        // Update tracking data\n        this.trackedDolphins.set(uuid, dolphinData);\n    }\n\n    analyzeDolphinState(dolphinData) {\n        const { dolphin, hasFish, treasurePos, moistness, position } = dolphinData;\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // Moisture warnings\n        if (moistness <= this.alertLevels.criticalMoistness) {\n            Chat.actionbar(`&c⚠ Dolphin needs water! ${moistness} moisture remaining`);\n            dolphin.setGlowingColor(0xFF0000); // Red for critical\n        } else if (moistness <= this.alertLevels.lowMoisture) {\n            Chat.actionbar(`&e⚠ Dolphin getting dry: ${moistness} moisture`);\n            dolphin.setGlowingColor(0xFFAA00); // Orange for warning\n        } else {\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for healthy\n        }\n\n        // Fish status\n        if (hasFish) {\n            Chat.log(`&bDolphin is carrying a fish!`);\n        }\n\n        // Treasure detection\n        if (treasurePos && (treasurePos.x !== 0 || treasurePos.y !== 0 || treasurePos.z !== 0)) {\n            const treasureDistance = Math.sqrt(\n                Math.pow(position.x - treasurePos.x, 2) +\n                Math.pow(position.y - treasurePos.y, 2) +\n                Math.pow(position.z - treasurePos.z, 2)\n            );\n\n            if (treasureDistance <= this.alertLevels.treasureNear) {\n                Chat.log(`&6✨ Dolphin knows about treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}] (${treasureDistance.toFixed(1)}m away)`);\n\n                // Highlight treasure area\n                const treasureBox = new Box(\n                    treasurePos.x - 2, treasurePos.y - 2, treasurePos.z - 2,\n                    treasurePos.x + 2, treasurePos.y + 2, treasurePos.z + 2,\n                    0xFFD700, 0x80FFD700, true, false\n                );\n                Hud.createDraw3D().addBox(treasureBox);\n            }\n        }\n    }\n\n    scanForDolphins() {\n        const entities = World.getEntities(100); // 100 block radius\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.updateDolphin(entity);\n            }\n        });\n\n        // Remove dolphins that are no longer in range\n        this.cleanupOutOfRangeDolphins(entities);\n    }\n\n    cleanupOutOfRangeDolphins(currentEntities) {\n        const currentDolphinUUIDs = new Set();\n\n        currentEntities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                currentDolphinUUIDs.add(entity.getUUID());\n            }\n        });\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            if (!currentDolphinUUIDs.has(uuid)) {\n                Chat.log(`&7Dolphin left tracking range`);\n                this.trackedDolphins.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        Chat.log(\"=== Dolphin Activity Report ===\");\n        Chat.log(`Currently tracking: ${this.trackedDolphins.size} dolphins`);\n\n        let lowMoistureCount = 0;\n        let fishCarriers = 0;\n        let treasureHunters = 0;\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            const { hasFish, treasurePos, moistness, position } = dolphinData;\n\n            if (moistness <= this.alertLevels.lowMoisture) lowMoistureCount++;\n            if (hasFish) fishCarriers++;\n            if (treasurePos && treasurePos.x !== 0) treasureHunters++;\n\n            const player = Player.getPlayer();\n            const distance = player ? player.distanceTo(position) : 0;\n\n            Chat.log(`\\nDolphin at [${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}]:`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${treasurePos && treasurePos.x !== 0 ? `Yes [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]` : \"No\"}`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n        }\n\n        Chat.log(`\\n&6Summary:`);\n        Chat.log(`  - Low moisture: ${lowMoistureCount}`);\n        Chat.log(`  - Fish carriers: ${fishCarriers}`);\n        Chat.log(`  - Treasure hunters: ${treasureHunters}`);\n    }\n}\n\n// Initialize dolphin monitor\nconst dolphinMonitor = new DolphinMonitor();\n\n// Update every 2 seconds for performance\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinMonitor.scanForDolphins();\n    }\n}));\n\n// Generate report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        dolphinMonitor.generateReport();\n    }\n}));\n\nChat.log(\"&aDolphin Monitor activated! Tracking aquatic behavior and treasure locations.\");",
        "// Assist with finding underwater treasure using dolphin behavior\nclass DolphinTreasureHunter {\n    constructor() {\n        this.treasureLocations = new Map();\n        this.visitedLocations = new Set();\n        this.huntRadius = 100;\n        this.feedItems = [\"minecraft:cod\", \"minecraft:salmon\", \"minecraft:tropical_fish\", \"minecraft:pufferfish\"];\n    }\n\n    feedAndTrackDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        // Check if player has fish to feed\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        let hasFish = false;\n        let fishItem = null;\n\n        if (mainHand && this.feedItems.includes(mainHand.getId())) {\n            hasFish = true;\n            fishItem = mainHand;\n        } else if (offHand && this.feedItems.includes(offHand.getId())) {\n            hasFish = true;\n            fishItem = offHand;\n        }\n\n        if (!hasFish) {\n            Chat.log(\"&eYou need fish to feed dolphins for treasure hunting!\");\n            Chat.log(\"&eRequired: cod, salmon, tropical fish, or pufferfish\");\n            return;\n        }\n\n        // Feed the dolphin (this would normally be done through interaction)\n        const distance = player.distanceTo(dolphinEntity);\n        if (distance <= 5) {\n            Chat.log(`&aFeeding dolphin with ${fishItem.getName().getString()}...`);\n\n            // Monitor for treasure location change\n            this.monitorDolphinForTreasure(dolphin);\n        } else {\n            Chat.log(`&eDolphin is too far away (${distance.toFixed(1)}m). Get closer than 5m.`);\n        }\n    }\n\n    monitorDolphinForTreasure(dolphin) {\n        const uuid = dolphin.getUUID();\n        const initialTreasurePos = dolphin.getTreasurePos();\n\n        Chat.log(\"&bMonitoring dolphin for treasure discovery...\");\n\n        // Set up monitoring for the next 30 seconds\n        const monitor =JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n            const currentDolphin = World.getEntityByUUID(uuid);\n            if (!currentDolphin || !currentDolphin.is(\"minecraft:dolphin\")) {\n                monitor.unregister();\n                return;\n            }\n\n            const dolphinHelper = currentDolphin.asDolphin();\n            const currentTreasurePos = dolphinHelper.getTreasurePos();\n\n            // Check if treasure position changed\n            if (currentTreasurePos &&\n                (currentTreasurePos.x !== initialTreasurePos.x ||\n                 currentTreasurePos.z !== initialTreasurePos.z)) {\n\n                this.recordTreasureLocation(currentTreasurePos, dolphinHelper);\n                monitor.unregister();\n            }\n\n            // Timeout after 30 seconds\n            if (Client.getTime() % (20 * 30) === 0) {\n                Chat.log(\"&7Dolphin didn't find treasure within 30 seconds\");\n                monitor.unregister();\n            }\n        }));\n    }\n\n    recordTreasureLocation(treasurePos, dolphin) {\n        const posKey = `${treasurePos.x},${treasurePos.y},${treasurePos.z}`;\n\n        if (this.visitedLocations.has(posKey)) {\n            Chat.log(\"&7Dolphin found a treasure location you already know about.\");\n            return;\n        }\n\n        this.treasureLocations.set(posKey, {\n            position: treasurePos,\n            discoveredBy: dolphin.getUUID(),\n            discoveredAt: Client.getTime()\n        });\n        this.visitedLocations.add(posKey);\n\n        Chat.log(`&6✨ Dolphin found treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]!`);\n        Chat.log(\"&aMarking location on your map...\");\n\n        // Create visual marker\n        const marker = new Box(\n            treasurePos.x - 1, treasurePos.y - 1, treasurePos.z - 1,\n            treasurePos.x + 1, treasurePos.y + 1, treasurePos.z + 1,\n            0xFFD700, 0x80FFD700, true, false\n        );\n        Hud.createDraw3D().addBox(marker);\n\n        // Draw path to treasure\n        this.drawPathToTreasure(treasurePos);\n    }\n\n    drawPathToTreasure(treasurePos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const playerPos = player.getPos();\n        const steps = 20;\n        const pathPoints = [];\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = playerPos.x + (treasurePos.x - playerPos.x) * t;\n            const y = playerPos.y + (treasurePos.y - playerPos.y) * t;\n            const z = playerPos.z + (treasurePos.z - playerPos.z) * t;\n            pathPoints.push(new Pos3D(x, y, z));\n        }\n\n        // Draw path line\n        const pathLine = new Line3D(\n            pathPoints,\n            0x00FFFF, 0xFF000000, true, false\n        );\n        Hud.createDraw3D().addLine(pathLine);\n\n        Chat.log(\"&aPath to treasure highlighted for 30 seconds\");\n\n        // Remove path after 30 seconds\n        setTimeout(() => {\n            Hud.createDraw3D().removeLine(pathLine);\n        }, 30000);\n    }\n\n    scanForOpportunities() {\n        const entities = World.getEntities(this.huntRadius);\n        const dolphins = [];\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const distance = player.distanceTo(entity);\n\n                dolphins.push({\n                    entity: entity,\n                    dolphin: dolphin,\n                    distance: distance,\n                    hasFish: dolphin.hasFish(),\n                    moistness: dolphin.getMoistness(),\n                    knowsTreasure: this.knowsTreasure(dolphin)\n                });\n            }\n        });\n\n        if (dolphins.length === 0) {\n            Chat.log(\"&eNo dolphins found within \" + this.huntRadius + \" blocks.\");\n            return;\n        }\n\n        Chat.log(`&a=== Dolphin Treasure Hunting Opportunities ===`);\n        Chat.log(`Found ${dolphins.length} dolphins nearby:`);\n\n        dolphins.forEach(dolphinData => {\n            const { entity, dolphin, distance, hasFish, moistness, knowsTreasure } = dolphinData;\n\n            Chat.log(`\\n&bDolphin ${distance.toFixed(1)}m away:`);\n            Chat.log(`  - Health: ${entity.asLiving().getHealth().toFixed(1)}/20`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${knowsTreasure ? \"Yes\" : \"No\"}`);\n\n            if (moistness < 1200) {\n                Chat.log(`  &c⚠ Low moisture - may need to return to water soon`);\n            }\n\n            if (knowsTreasure) {\n                const treasurePos = dolphin.getTreasurePos();\n                Chat.log(`  &6✨ Treasure location: [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]`);\n            }\n        });\n\n        // Check if player has fish\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        const hasFish = (mainHand && this.feedItems.includes(mainHand.getId())) ||\n                        (offHand && this.feedItems.includes(offHand.getId()));\n\n        if (hasFish) {\n            Chat.log(`\\n&a✓ You have fish for feeding dolphins!`);\n        } else {\n            Chat.log(`\\n&eTip: Hold fish to feed dolphins for treasure hunting`);\n        }\n    }\n\n    knowsTreasure(dolphin) {\n        const pos = dolphin.getTreasurePos();\n        return pos && (pos.x !== 0 || pos.y !== 0 || pos.z !== 0);\n    }\n\n    generateTreasureReport() {\n        Chat.log(\"=== Treasure Discovery Report ===\");\n        Chat.log(`Total treasure locations found: ${this.treasureLocations.size}`);\n\n        if (this.treasureLocations.size === 0) {\n            Chat.log(\"No treasure locations discovered yet. Feed dolphins to find treasure!\");\n            return;\n        }\n\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        for (const [posKey, treasureData] of this.treasureLocations) {\n            const { position, discoveredAt } = treasureData;\n            const distance = player.distanceTo(position);\n            const age = Client.getTime() - discoveredAt;\n            const ageMinutes = Math.floor(age / (20 * 60));\n\n            Chat.log(`\\n&6Treasure at [${position.x}, ${position.y}, ${position.z}]:`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`  - Discovered: ${ageMinutes} minute${ageMinutes !== 1 ? 's' : ''} ago`);\n            Chat.log(`  - Status: ${distance <= 10 ? \"&aVery close!\" : distance <= 50 ? \"&eNearby\" : \"&7Far away\"}`);\n        }\n    }\n}\n\n// Initialize treasure hunter\nconst treasureHunter = new DolphinTreasureHunter();\n\n// Command aliases\nJsMacros.on(\"Key\", JavaWrapper.methodToJavaAsync((event) => {\n    if (event.key === \"F1\") {\n        treasureHunter.scanForOpportunities();\n    } else if (event.key === \"F2\") {\n        treasureHunter.generateTreasureReport();\n    }\n}));\n\nChat.log(\"&aDolphin Treasure Hunter initialized!\");\nChat.log(\"&ePress F1 to scan for hunting opportunities\");\nChat.log(\"&ePress F2 to view discovered treasure locations\");",
        "// Monitor and manage dolphin health and moisture levels\nclass DolphinCareManager {\n    constructor() {\n        this.underConstruction = new Set();\n        this.safeZones = [];\n        this.moistnessThresholds = {\n            critical: 300,    // 15 seconds\n            warning: 600,     // 30 seconds\n            safe: 1200        // 1 minute\n        };\n    }\n\n    createSafeZone(centerPos, radius = 20) {\n        const safeZone = {\n            center: centerPos,\n            radius: radius,\n            created: Client.getTime()\n        };\n\n        this.safeZones.push(safeZone);\n\n        // Create visual marker for safe zone\n        const zoneBox = new Box(\n            centerPos.x - radius, centerPos.y - radius, centerPos.z - radius,\n            centerPos.x + radius, centerPos.y + radius, centerPos.z + radius,\n            0x0000FF, 0x400000FF, true, false\n        );\n        Hud.createDraw3D().addBox(zoneBox);\n\n        Chat.log(`&aCreated dolphin safe zone at [${centerPos.x}, ${centerPos.y}, ${centerPos.z}] (${radius}m radius)`);\n    }\n\n    checkDolphinSafety(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const pos = dolphin.getPos();\n        const moistness = dolphin.getMoistness();\n        const isAlive = dolphin.asLiving().isAlive();\n\n        if (!isAlive) return;\n\n        // Check moisture levels\n        if (moistness <= this.moistnessThresholds.critical) {\n            this.handleCriticalMoisture(dolphin, pos, moistness);\n        } else if (moistness <= this.moistnessThresholds.warning) {\n            this.handleLowMoisture(dolphin, pos, moistness);\n        }\n\n        // Check if dolphin is in water\n        const block = World.getBlock(pos.x, pos.y, pos.z);\n        const isInWater = block && block.is(\"minecraft:water\");\n\n        if (!isInWater && moistness < this.moistnessThresholds.safe) {\n            this.guideDolphinToWater(dolphin, pos);\n        }\n    }\n\n    handleCriticalMoisture(dolphin, pos, moistness) {\n        const uuid = dolphin.getUUID();\n\n        if (this.underConstruction.has(uuid)) return;\n\n        Chat.log(`&c⚠ CRITICAL: Dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] has only ${moistness} moisture!`);\n        Chat.log(\"&cImmediate water access required!\");\n\n        // Flash red warning\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFF0000);\n\n        // Guide to nearest water\n        this.guideDolphinToWater(dolphin, pos);\n        this.underConstruction.add(uuid);\n    }\n\n    handleLowMoisture(dolphin, pos, moistness) {\n        Chat.actionbar(`&eDolphin moisture low: ${moistness}/2400`);\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFFAA00);\n    }\n\n    guideDolphinToWater(dolphin, pos) {\n        // Find nearest water source\n        const searchRadius = 30;\n        let nearestWater = null;\n        let nearestDistance = searchRadius;\n\n        for (let x = pos.x - searchRadius; x <= pos.x + searchRadius; x += 2) {\n            for (let z = pos.z - searchRadius; z <= pos.z + searchRadius; z += 2) {\n                for (let y = Math.max(0, pos.y - 10); y <= pos.y + 10; y++) {\n                    const block = World.getBlock(x, y, z);\n                    if (block && block.is(\"minecraft:water\")) {\n                        const waterPos = new Pos3D(x, y, z);\n                        const distance = Math.sqrt(\n                            Math.pow(pos.x - x, 2) +\n                            Math.pow(pos.y - y, 2) +\n                            Math.pow(pos.z - z, 2)\n                        );\n\n                        if (distance < nearestDistance) {\n                            nearestDistance = distance;\n                            nearestWater = waterPos;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (nearestWater) {\n            Chat.log(`&bGuiding dolphin to water at [${nearestWater.x}, ${nearestWater.y}, ${nearestWater.z}] (${nearestDistance.toFixed(1)}m away)`);\n\n            // Draw path to water\n            const pathLine = new Line3D(\n                [pos, nearestWater],\n                0x00FFFF, 0xFF000000, true, false\n            );\n            Hud.createDraw3D().addLine(pathLine);\n\n            // Remove path after 10 seconds\n            setTimeout(() => {\n                Hud.createDraw3D().removeLine(pathLine);\n            }, 10000);\n        } else {\n            Chat.log(`&cNo water found within ${searchRadius}m blocks! Dolphin may not survive.`);\n        }\n    }\n\n    scanForDolphinsInNeed() {\n        const entities = World.getEntities(100);\n        const dolphinsInNeed = [];\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const moistness = dolphin.getMoistness();\n\n                if (moistness <= this.moistnessThresholds.warning) {\n                    dolphinsInNeed.push({\n                        entity: entity,\n                        dolphin: dolphin,\n                        moistness: moistness,\n                        pos: entity.getPos()\n                    });\n                }\n            }\n        });\n\n        if (dolphinsInNeed.length === 0) {\n            Chat.log(\"&aAll dolphins in the area have healthy moisture levels!\");\n            return;\n        }\n\n        Chat.log(`&e=== Dolphin Moisture Alert ===`);\n        Chat.log(`Found ${dolphinsInNeed.length} dolphin${dolphinsInNeed.length > 1 ? 's' : ''} in need of water:`);\n\n        dolphinsInNeed.forEach(({ dolphin, moistness, pos }) => {\n            const status = moistness <= this.moistnessThresholds.critical ? \"&cCRITICAL\" : \"&eWARNING\";\n            Chat.log(`${status}: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] - ${moistness}/2400 moisture`);\n        });\n    }\n\n    createWaterSource(pos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // This would typically be done by placing water blocks or using commands\n        Chat.log(`&eCreating emergency water source at [${pos.x}, ${pos.y}, ${pos.z}]`);\n\n        // Mark water source location\n        const waterMarker = new Box(\n            pos.x - 1, pos.y, pos.z - 1,\n            pos.x + 1, pos.y + 1, pos.z + 1,\n            0x0000FF, 0x800000FF, true, false\n        );\n        Hud.createDraw3D().addBox(waterMarker);\n    }\n\n    update() {\n        const entities = World.getEntities(100);\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.checkDolphinSafety(entity);\n            }\n        });\n\n        // Clean up construction flags\n        this.underConstruction.clear();\n    }\n}\n\n// Initialize dolphin care manager\nconst dolphinCare = new DolphinCareManager();\n\n// Monitor every 2 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinCare.update();\n    }\n}));\n\n// Check for dolphins in need every 10 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 200 === 0) {\n        dolphinCare.scanForDolphinsInNeed();\n    }\n}));\n\nChat.log(\"&aDolphin Care Manager activated! Monitoring moisture and health.\");"
      ]
    },
    {
      "name": "getTreasurePos",
      "signature": "const treasurePos = dolphin.getTreasurePos();",
      "returnType": "BlockPosHelper",
      "description": "Returns the position of the treasure that the dolphin is currently leading players toward. When dolphins are fed, they will swim to nearby underwater ruins or shipwrecks and remember the location, potentially leading players to treasure.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive dolphin monitoring and behavior analysis system\nclass DolphinMonitor {\n    constructor() {\n        this.trackedDolphins = new Map();\n        this.alertLevels = {\n            lowMoisture: 600,    // 30 seconds - get back in water!\n            criticalMoisture: 300, // 15 seconds - critical damage imminent\n            treasureNear: 50      // 50 blocks - treasure is nearby\n        };\n    }\n\n    updateDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const uuid = dolphin.getUUID();\n        const pos = dolphin.getPos();\n\n        const dolphinData = {\n            dolphin: dolphin,\n            hasFish: dolphin.hasFish(),\n            treasurePos: dolphin.getTreasurePos(),\n            moistness: dolphin.getMoistness(),\n            position: pos,\n            lastUpdate: Client.getTime()\n        };\n\n        // Check if this is a new dolphin\n        if (!this.trackedDolphins.has(uuid)) {\n            Chat.log(`&aDiscovered dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            dolphin.setGlowing(true);\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for water creatures\n        }\n\n        // Analyze dolphin state\n        this.analyzeDolphinState(dolphinData);\n\n        // Update tracking data\n        this.trackedDolphins.set(uuid, dolphinData);\n    }\n\n    analyzeDolphinState(dolphinData) {\n        const { dolphin, hasFish, treasurePos, moistness, position } = dolphinData;\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // Moisture warnings\n        if (moistness <= this.alertLevels.criticalMoistness) {\n            Chat.actionbar(`&c⚠ Dolphin needs water! ${moistness} moisture remaining`);\n            dolphin.setGlowingColor(0xFF0000); // Red for critical\n        } else if (moistness <= this.alertLevels.lowMoisture) {\n            Chat.actionbar(`&e⚠ Dolphin getting dry: ${moistness} moisture`);\n            dolphin.setGlowingColor(0xFFAA00); // Orange for warning\n        } else {\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for healthy\n        }\n\n        // Fish status\n        if (hasFish) {\n            Chat.log(`&bDolphin is carrying a fish!`);\n        }\n\n        // Treasure detection\n        if (treasurePos && (treasurePos.x !== 0 || treasurePos.y !== 0 || treasurePos.z !== 0)) {\n            const treasureDistance = Math.sqrt(\n                Math.pow(position.x - treasurePos.x, 2) +\n                Math.pow(position.y - treasurePos.y, 2) +\n                Math.pow(position.z - treasurePos.z, 2)\n            );\n\n            if (treasureDistance <= this.alertLevels.treasureNear) {\n                Chat.log(`&6✨ Dolphin knows about treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}] (${treasureDistance.toFixed(1)}m away)`);\n\n                // Highlight treasure area\n                const treasureBox = new Box(\n                    treasurePos.x - 2, treasurePos.y - 2, treasurePos.z - 2,\n                    treasurePos.x + 2, treasurePos.y + 2, treasurePos.z + 2,\n                    0xFFD700, 0x80FFD700, true, false\n                );\n                Hud.createDraw3D().addBox(treasureBox);\n            }\n        }\n    }\n\n    scanForDolphins() {\n        const entities = World.getEntities(100); // 100 block radius\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.updateDolphin(entity);\n            }\n        });\n\n        // Remove dolphins that are no longer in range\n        this.cleanupOutOfRangeDolphins(entities);\n    }\n\n    cleanupOutOfRangeDolphins(currentEntities) {\n        const currentDolphinUUIDs = new Set();\n\n        currentEntities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                currentDolphinUUIDs.add(entity.getUUID());\n            }\n        });\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            if (!currentDolphinUUIDs.has(uuid)) {\n                Chat.log(`&7Dolphin left tracking range`);\n                this.trackedDolphins.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        Chat.log(\"=== Dolphin Activity Report ===\");\n        Chat.log(`Currently tracking: ${this.trackedDolphins.size} dolphins`);\n\n        let lowMoistureCount = 0;\n        let fishCarriers = 0;\n        let treasureHunters = 0;\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            const { hasFish, treasurePos, moistness, position } = dolphinData;\n\n            if (moistness <= this.alertLevels.lowMoisture) lowMoistureCount++;\n            if (hasFish) fishCarriers++;\n            if (treasurePos && treasurePos.x !== 0) treasureHunters++;\n\n            const player = Player.getPlayer();\n            const distance = player ? player.distanceTo(position) : 0;\n\n            Chat.log(`\\nDolphin at [${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}]:`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${treasurePos && treasurePos.x !== 0 ? `Yes [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]` : \"No\"}`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n        }\n\n        Chat.log(`\\n&6Summary:`);\n        Chat.log(`  - Low moisture: ${lowMoistureCount}`);\n        Chat.log(`  - Fish carriers: ${fishCarriers}`);\n        Chat.log(`  - Treasure hunters: ${treasureHunters}`);\n    }\n}\n\n// Initialize dolphin monitor\nconst dolphinMonitor = new DolphinMonitor();\n\n// Update every 2 seconds for performance\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinMonitor.scanForDolphins();\n    }\n}));\n\n// Generate report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        dolphinMonitor.generateReport();\n    }\n}));\n\nChat.log(\"&aDolphin Monitor activated! Tracking aquatic behavior and treasure locations.\");",
        "// Assist with finding underwater treasure using dolphin behavior\nclass DolphinTreasureHunter {\n    constructor() {\n        this.treasureLocations = new Map();\n        this.visitedLocations = new Set();\n        this.huntRadius = 100;\n        this.feedItems = [\"minecraft:cod\", \"minecraft:salmon\", \"minecraft:tropical_fish\", \"minecraft:pufferfish\"];\n    }\n\n    feedAndTrackDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        // Check if player has fish to feed\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        let hasFish = false;\n        let fishItem = null;\n\n        if (mainHand && this.feedItems.includes(mainHand.getId())) {\n            hasFish = true;\n            fishItem = mainHand;\n        } else if (offHand && this.feedItems.includes(offHand.getId())) {\n            hasFish = true;\n            fishItem = offHand;\n        }\n\n        if (!hasFish) {\n            Chat.log(\"&eYou need fish to feed dolphins for treasure hunting!\");\n            Chat.log(\"&eRequired: cod, salmon, tropical fish, or pufferfish\");\n            return;\n        }\n\n        // Feed the dolphin (this would normally be done through interaction)\n        const distance = player.distanceTo(dolphinEntity);\n        if (distance <= 5) {\n            Chat.log(`&aFeeding dolphin with ${fishItem.getName().getString()}...`);\n\n            // Monitor for treasure location change\n            this.monitorDolphinForTreasure(dolphin);\n        } else {\n            Chat.log(`&eDolphin is too far away (${distance.toFixed(1)}m). Get closer than 5m.`);\n        }\n    }\n\n    monitorDolphinForTreasure(dolphin) {\n        const uuid = dolphin.getUUID();\n        const initialTreasurePos = dolphin.getTreasurePos();\n\n        Chat.log(\"&bMonitoring dolphin for treasure discovery...\");\n\n        // Set up monitoring for the next 30 seconds\n        const monitor =JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n            const currentDolphin = World.getEntityByUUID(uuid);\n            if (!currentDolphin || !currentDolphin.is(\"minecraft:dolphin\")) {\n                monitor.unregister();\n                return;\n            }\n\n            const dolphinHelper = currentDolphin.asDolphin();\n            const currentTreasurePos = dolphinHelper.getTreasurePos();\n\n            // Check if treasure position changed\n            if (currentTreasurePos &&\n                (currentTreasurePos.x !== initialTreasurePos.x ||\n                 currentTreasurePos.z !== initialTreasurePos.z)) {\n\n                this.recordTreasureLocation(currentTreasurePos, dolphinHelper);\n                monitor.unregister();\n            }\n\n            // Timeout after 30 seconds\n            if (Client.getTime() % (20 * 30) === 0) {\n                Chat.log(\"&7Dolphin didn't find treasure within 30 seconds\");\n                monitor.unregister();\n            }\n        }));\n    }\n\n    recordTreasureLocation(treasurePos, dolphin) {\n        const posKey = `${treasurePos.x},${treasurePos.y},${treasurePos.z}`;\n\n        if (this.visitedLocations.has(posKey)) {\n            Chat.log(\"&7Dolphin found a treasure location you already know about.\");\n            return;\n        }\n\n        this.treasureLocations.set(posKey, {\n            position: treasurePos,\n            discoveredBy: dolphin.getUUID(),\n            discoveredAt: Client.getTime()\n        });\n        this.visitedLocations.add(posKey);\n\n        Chat.log(`&6✨ Dolphin found treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]!`);\n        Chat.log(\"&aMarking location on your map...\");\n\n        // Create visual marker\n        const marker = new Box(\n            treasurePos.x - 1, treasurePos.y - 1, treasurePos.z - 1,\n            treasurePos.x + 1, treasurePos.y + 1, treasurePos.z + 1,\n            0xFFD700, 0x80FFD700, true, false\n        );\n        Hud.createDraw3D().addBox(marker);\n\n        // Draw path to treasure\n        this.drawPathToTreasure(treasurePos);\n    }\n\n    drawPathToTreasure(treasurePos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const playerPos = player.getPos();\n        const steps = 20;\n        const pathPoints = [];\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = playerPos.x + (treasurePos.x - playerPos.x) * t;\n            const y = playerPos.y + (treasurePos.y - playerPos.y) * t;\n            const z = playerPos.z + (treasurePos.z - playerPos.z) * t;\n            pathPoints.push(new Pos3D(x, y, z));\n        }\n\n        // Draw path line\n        const pathLine = new Line3D(\n            pathPoints,\n            0x00FFFF, 0xFF000000, true, false\n        );\n        Hud.createDraw3D().addLine(pathLine);\n\n        Chat.log(\"&aPath to treasure highlighted for 30 seconds\");\n\n        // Remove path after 30 seconds\n        setTimeout(() => {\n            Hud.createDraw3D().removeLine(pathLine);\n        }, 30000);\n    }\n\n    scanForOpportunities() {\n        const entities = World.getEntities(this.huntRadius);\n        const dolphins = [];\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const distance = player.distanceTo(entity);\n\n                dolphins.push({\n                    entity: entity,\n                    dolphin: dolphin,\n                    distance: distance,\n                    hasFish: dolphin.hasFish(),\n                    moistness: dolphin.getMoistness(),\n                    knowsTreasure: this.knowsTreasure(dolphin)\n                });\n            }\n        });\n\n        if (dolphins.length === 0) {\n            Chat.log(\"&eNo dolphins found within \" + this.huntRadius + \" blocks.\");\n            return;\n        }\n\n        Chat.log(`&a=== Dolphin Treasure Hunting Opportunities ===`);\n        Chat.log(`Found ${dolphins.length} dolphins nearby:`);\n\n        dolphins.forEach(dolphinData => {\n            const { entity, dolphin, distance, hasFish, moistness, knowsTreasure } = dolphinData;\n\n            Chat.log(`\\n&bDolphin ${distance.toFixed(1)}m away:`);\n            Chat.log(`  - Health: ${entity.asLiving().getHealth().toFixed(1)}/20`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${knowsTreasure ? \"Yes\" : \"No\"}`);\n\n            if (moistness < 1200) {\n                Chat.log(`  &c⚠ Low moisture - may need to return to water soon`);\n            }\n\n            if (knowsTreasure) {\n                const treasurePos = dolphin.getTreasurePos();\n                Chat.log(`  &6✨ Treasure location: [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]`);\n            }\n        });\n\n        // Check if player has fish\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        const hasFish = (mainHand && this.feedItems.includes(mainHand.getId())) ||\n                        (offHand && this.feedItems.includes(offHand.getId()));\n\n        if (hasFish) {\n            Chat.log(`\\n&a✓ You have fish for feeding dolphins!`);\n        } else {\n            Chat.log(`\\n&eTip: Hold fish to feed dolphins for treasure hunting`);\n        }\n    }\n\n    knowsTreasure(dolphin) {\n        const pos = dolphin.getTreasurePos();\n        return pos && (pos.x !== 0 || pos.y !== 0 || pos.z !== 0);\n    }\n\n    generateTreasureReport() {\n        Chat.log(\"=== Treasure Discovery Report ===\");\n        Chat.log(`Total treasure locations found: ${this.treasureLocations.size}`);\n\n        if (this.treasureLocations.size === 0) {\n            Chat.log(\"No treasure locations discovered yet. Feed dolphins to find treasure!\");\n            return;\n        }\n\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        for (const [posKey, treasureData] of this.treasureLocations) {\n            const { position, discoveredAt } = treasureData;\n            const distance = player.distanceTo(position);\n            const age = Client.getTime() - discoveredAt;\n            const ageMinutes = Math.floor(age / (20 * 60));\n\n            Chat.log(`\\n&6Treasure at [${position.x}, ${position.y}, ${position.z}]:`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`  - Discovered: ${ageMinutes} minute${ageMinutes !== 1 ? 's' : ''} ago`);\n            Chat.log(`  - Status: ${distance <= 10 ? \"&aVery close!\" : distance <= 50 ? \"&eNearby\" : \"&7Far away\"}`);\n        }\n    }\n}\n\n// Initialize treasure hunter\nconst treasureHunter = new DolphinTreasureHunter();\n\n// Command aliases\nJsMacros.on(\"Key\", JavaWrapper.methodToJavaAsync((event) => {\n    if (event.key === \"F1\") {\n        treasureHunter.scanForOpportunities();\n    } else if (event.key === \"F2\") {\n        treasureHunter.generateTreasureReport();\n    }\n}));\n\nChat.log(\"&aDolphin Treasure Hunter initialized!\");\nChat.log(\"&ePress F1 to scan for hunting opportunities\");\nChat.log(\"&ePress F2 to view discovered treasure locations\");",
        "// Monitor and manage dolphin health and moisture levels\nclass DolphinCareManager {\n    constructor() {\n        this.underConstruction = new Set();\n        this.safeZones = [];\n        this.moistnessThresholds = {\n            critical: 300,    // 15 seconds\n            warning: 600,     // 30 seconds\n            safe: 1200        // 1 minute\n        };\n    }\n\n    createSafeZone(centerPos, radius = 20) {\n        const safeZone = {\n            center: centerPos,\n            radius: radius,\n            created: Client.getTime()\n        };\n\n        this.safeZones.push(safeZone);\n\n        // Create visual marker for safe zone\n        const zoneBox = new Box(\n            centerPos.x - radius, centerPos.y - radius, centerPos.z - radius,\n            centerPos.x + radius, centerPos.y + radius, centerPos.z + radius,\n            0x0000FF, 0x400000FF, true, false\n        );\n        Hud.createDraw3D().addBox(zoneBox);\n\n        Chat.log(`&aCreated dolphin safe zone at [${centerPos.x}, ${centerPos.y}, ${centerPos.z}] (${radius}m radius)`);\n    }\n\n    checkDolphinSafety(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const pos = dolphin.getPos();\n        const moistness = dolphin.getMoistness();\n        const isAlive = dolphin.asLiving().isAlive();\n\n        if (!isAlive) return;\n\n        // Check moisture levels\n        if (moistness <= this.moistnessThresholds.critical) {\n            this.handleCriticalMoisture(dolphin, pos, moistness);\n        } else if (moistness <= this.moistnessThresholds.warning) {\n            this.handleLowMoisture(dolphin, pos, moistness);\n        }\n\n        // Check if dolphin is in water\n        const block = World.getBlock(pos.x, pos.y, pos.z);\n        const isInWater = block && block.is(\"minecraft:water\");\n\n        if (!isInWater && moistness < this.moistnessThresholds.safe) {\n            this.guideDolphinToWater(dolphin, pos);\n        }\n    }\n\n    handleCriticalMoisture(dolphin, pos, moistness) {\n        const uuid = dolphin.getUUID();\n\n        if (this.underConstruction.has(uuid)) return;\n\n        Chat.log(`&c⚠ CRITICAL: Dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] has only ${moistness} moisture!`);\n        Chat.log(\"&cImmediate water access required!\");\n\n        // Flash red warning\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFF0000);\n\n        // Guide to nearest water\n        this.guideDolphinToWater(dolphin, pos);\n        this.underConstruction.add(uuid);\n    }\n\n    handleLowMoisture(dolphin, pos, moistness) {\n        Chat.actionbar(`&eDolphin moisture low: ${moistness}/2400`);\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFFAA00);\n    }\n\n    guideDolphinToWater(dolphin, pos) {\n        // Find nearest water source\n        const searchRadius = 30;\n        let nearestWater = null;\n        let nearestDistance = searchRadius;\n\n        for (let x = pos.x - searchRadius; x <= pos.x + searchRadius; x += 2) {\n            for (let z = pos.z - searchRadius; z <= pos.z + searchRadius; z += 2) {\n                for (let y = Math.max(0, pos.y - 10); y <= pos.y + 10; y++) {\n                    const block = World.getBlock(x, y, z);\n                    if (block && block.is(\"minecraft:water\")) {\n                        const waterPos = new Pos3D(x, y, z);\n                        const distance = Math.sqrt(\n                            Math.pow(pos.x - x, 2) +\n                            Math.pow(pos.y - y, 2) +\n                            Math.pow(pos.z - z, 2)\n                        );\n\n                        if (distance < nearestDistance) {\n                            nearestDistance = distance;\n                            nearestWater = waterPos;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (nearestWater) {\n            Chat.log(`&bGuiding dolphin to water at [${nearestWater.x}, ${nearestWater.y}, ${nearestWater.z}] (${nearestDistance.toFixed(1)}m away)`);\n\n            // Draw path to water\n            const pathLine = new Line3D(\n                [pos, nearestWater],\n                0x00FFFF, 0xFF000000, true, false\n            );\n            Hud.createDraw3D().addLine(pathLine);\n\n            // Remove path after 10 seconds\n            setTimeout(() => {\n                Hud.createDraw3D().removeLine(pathLine);\n            }, 10000);\n        } else {\n            Chat.log(`&cNo water found within ${searchRadius}m blocks! Dolphin may not survive.`);\n        }\n    }\n\n    scanForDolphinsInNeed() {\n        const entities = World.getEntities(100);\n        const dolphinsInNeed = [];\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const moistness = dolphin.getMoistness();\n\n                if (moistness <= this.moistnessThresholds.warning) {\n                    dolphinsInNeed.push({\n                        entity: entity,\n                        dolphin: dolphin,\n                        moistness: moistness,\n                        pos: entity.getPos()\n                    });\n                }\n            }\n        });\n\n        if (dolphinsInNeed.length === 0) {\n            Chat.log(\"&aAll dolphins in the area have healthy moisture levels!\");\n            return;\n        }\n\n        Chat.log(`&e=== Dolphin Moisture Alert ===`);\n        Chat.log(`Found ${dolphinsInNeed.length} dolphin${dolphinsInNeed.length > 1 ? 's' : ''} in need of water:`);\n\n        dolphinsInNeed.forEach(({ dolphin, moistness, pos }) => {\n            const status = moistness <= this.moistnessThresholds.critical ? \"&cCRITICAL\" : \"&eWARNING\";\n            Chat.log(`${status}: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] - ${moistness}/2400 moisture`);\n        });\n    }\n\n    createWaterSource(pos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // This would typically be done by placing water blocks or using commands\n        Chat.log(`&eCreating emergency water source at [${pos.x}, ${pos.y}, ${pos.z}]`);\n\n        // Mark water source location\n        const waterMarker = new Box(\n            pos.x - 1, pos.y, pos.z - 1,\n            pos.x + 1, pos.y + 1, pos.z + 1,\n            0x0000FF, 0x800000FF, true, false\n        );\n        Hud.createDraw3D().addBox(waterMarker);\n    }\n\n    update() {\n        const entities = World.getEntities(100);\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.checkDolphinSafety(entity);\n            }\n        });\n\n        // Clean up construction flags\n        this.underConstruction.clear();\n    }\n}\n\n// Initialize dolphin care manager\nconst dolphinCare = new DolphinCareManager();\n\n// Monitor every 2 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinCare.update();\n    }\n}));\n\n// Check for dolphins in need every 10 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 200 === 0) {\n        dolphinCare.scanForDolphinsInNeed();\n    }\n}));\n\nChat.log(\"&aDolphin Care Manager activated! Monitoring moisture and health.\");"
      ]
    },
    {
      "name": "getMoistness",
      "signature": "const moistness = dolphin.getMoistness();",
      "returnType": "int",
      "description": "Returns the current moisture level of the dolphin. Dolphins must maintain moisture by staying in water - their moisture decreases over time when on land and they will take damage if it reaches zero. The maximum moisture is typically 2400 (2 minutes of air time).",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive dolphin monitoring and behavior analysis system\nclass DolphinMonitor {\n    constructor() {\n        this.trackedDolphins = new Map();\n        this.alertLevels = {\n            lowMoisture: 600,    // 30 seconds - get back in water!\n            criticalMoisture: 300, // 15 seconds - critical damage imminent\n            treasureNear: 50      // 50 blocks - treasure is nearby\n        };\n    }\n\n    updateDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const uuid = dolphin.getUUID();\n        const pos = dolphin.getPos();\n\n        const dolphinData = {\n            dolphin: dolphin,\n            hasFish: dolphin.hasFish(),\n            treasurePos: dolphin.getTreasurePos(),\n            moistness: dolphin.getMoistness(),\n            position: pos,\n            lastUpdate: Client.getTime()\n        };\n\n        // Check if this is a new dolphin\n        if (!this.trackedDolphins.has(uuid)) {\n            Chat.log(`&aDiscovered dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            dolphin.setGlowing(true);\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for water creatures\n        }\n\n        // Analyze dolphin state\n        this.analyzeDolphinState(dolphinData);\n\n        // Update tracking data\n        this.trackedDolphins.set(uuid, dolphinData);\n    }\n\n    analyzeDolphinState(dolphinData) {\n        const { dolphin, hasFish, treasurePos, moistness, position } = dolphinData;\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // Moisture warnings\n        if (moistness <= this.alertLevels.criticalMoistness) {\n            Chat.actionbar(`&c⚠ Dolphin needs water! ${moistness} moisture remaining`);\n            dolphin.setGlowingColor(0xFF0000); // Red for critical\n        } else if (moistness <= this.alertLevels.lowMoisture) {\n            Chat.actionbar(`&e⚠ Dolphin getting dry: ${moistness} moisture`);\n            dolphin.setGlowingColor(0xFFAA00); // Orange for warning\n        } else {\n            dolphin.setGlowingColor(0x00FFFF); // Cyan for healthy\n        }\n\n        // Fish status\n        if (hasFish) {\n            Chat.log(`&bDolphin is carrying a fish!`);\n        }\n\n        // Treasure detection\n        if (treasurePos && (treasurePos.x !== 0 || treasurePos.y !== 0 || treasurePos.z !== 0)) {\n            const treasureDistance = Math.sqrt(\n                Math.pow(position.x - treasurePos.x, 2) +\n                Math.pow(position.y - treasurePos.y, 2) +\n                Math.pow(position.z - treasurePos.z, 2)\n            );\n\n            if (treasureDistance <= this.alertLevels.treasureNear) {\n                Chat.log(`&6✨ Dolphin knows about treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}] (${treasureDistance.toFixed(1)}m away)`);\n\n                // Highlight treasure area\n                const treasureBox = new Box(\n                    treasurePos.x - 2, treasurePos.y - 2, treasurePos.z - 2,\n                    treasurePos.x + 2, treasurePos.y + 2, treasurePos.z + 2,\n                    0xFFD700, 0x80FFD700, true, false\n                );\n                Hud.createDraw3D().addBox(treasureBox);\n            }\n        }\n    }\n\n    scanForDolphins() {\n        const entities = World.getEntities(100); // 100 block radius\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.updateDolphin(entity);\n            }\n        });\n\n        // Remove dolphins that are no longer in range\n        this.cleanupOutOfRangeDolphins(entities);\n    }\n\n    cleanupOutOfRangeDolphins(currentEntities) {\n        const currentDolphinUUIDs = new Set();\n\n        currentEntities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                currentDolphinUUIDs.add(entity.getUUID());\n            }\n        });\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            if (!currentDolphinUUIDs.has(uuid)) {\n                Chat.log(`&7Dolphin left tracking range`);\n                this.trackedDolphins.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        Chat.log(\"=== Dolphin Activity Report ===\");\n        Chat.log(`Currently tracking: ${this.trackedDolphins.size} dolphins`);\n\n        let lowMoistureCount = 0;\n        let fishCarriers = 0;\n        let treasureHunters = 0;\n\n        for (const [uuid, dolphinData] of this.trackedDolphins) {\n            const { hasFish, treasurePos, moistness, position } = dolphinData;\n\n            if (moistness <= this.alertLevels.lowMoisture) lowMoistureCount++;\n            if (hasFish) fishCarriers++;\n            if (treasurePos && treasurePos.x !== 0) treasureHunters++;\n\n            const player = Player.getPlayer();\n            const distance = player ? player.distanceTo(position) : 0;\n\n            Chat.log(`\\nDolphin at [${position.x.toFixed(0)}, ${position.y.toFixed(0)}, ${position.z.toFixed(0)}]:`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${treasurePos && treasurePos.x !== 0 ? `Yes [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]` : \"No\"}`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n        }\n\n        Chat.log(`\\n&6Summary:`);\n        Chat.log(`  - Low moisture: ${lowMoistureCount}`);\n        Chat.log(`  - Fish carriers: ${fishCarriers}`);\n        Chat.log(`  - Treasure hunters: ${treasureHunters}`);\n    }\n}\n\n// Initialize dolphin monitor\nconst dolphinMonitor = new DolphinMonitor();\n\n// Update every 2 seconds for performance\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinMonitor.scanForDolphins();\n    }\n}));\n\n// Generate report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        dolphinMonitor.generateReport();\n    }\n}));\n\nChat.log(\"&aDolphin Monitor activated! Tracking aquatic behavior and treasure locations.\");",
        "// Assist with finding underwater treasure using dolphin behavior\nclass DolphinTreasureHunter {\n    constructor() {\n        this.treasureLocations = new Map();\n        this.visitedLocations = new Set();\n        this.huntRadius = 100;\n        this.feedItems = [\"minecraft:cod\", \"minecraft:salmon\", \"minecraft:tropical_fish\", \"minecraft:pufferfish\"];\n    }\n\n    feedAndTrackDolphin(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        // Check if player has fish to feed\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        let hasFish = false;\n        let fishItem = null;\n\n        if (mainHand && this.feedItems.includes(mainHand.getId())) {\n            hasFish = true;\n            fishItem = mainHand;\n        } else if (offHand && this.feedItems.includes(offHand.getId())) {\n            hasFish = true;\n            fishItem = offHand;\n        }\n\n        if (!hasFish) {\n            Chat.log(\"&eYou need fish to feed dolphins for treasure hunting!\");\n            Chat.log(\"&eRequired: cod, salmon, tropical fish, or pufferfish\");\n            return;\n        }\n\n        // Feed the dolphin (this would normally be done through interaction)\n        const distance = player.distanceTo(dolphinEntity);\n        if (distance <= 5) {\n            Chat.log(`&aFeeding dolphin with ${fishItem.getName().getString()}...`);\n\n            // Monitor for treasure location change\n            this.monitorDolphinForTreasure(dolphin);\n        } else {\n            Chat.log(`&eDolphin is too far away (${distance.toFixed(1)}m). Get closer than 5m.`);\n        }\n    }\n\n    monitorDolphinForTreasure(dolphin) {\n        const uuid = dolphin.getUUID();\n        const initialTreasurePos = dolphin.getTreasurePos();\n\n        Chat.log(\"&bMonitoring dolphin for treasure discovery...\");\n\n        // Set up monitoring for the next 30 seconds\n        const monitor =JsMacros.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n            const currentDolphin = World.getEntityByUUID(uuid);\n            if (!currentDolphin || !currentDolphin.is(\"minecraft:dolphin\")) {\n                monitor.unregister();\n                return;\n            }\n\n            const dolphinHelper = currentDolphin.asDolphin();\n            const currentTreasurePos = dolphinHelper.getTreasurePos();\n\n            // Check if treasure position changed\n            if (currentTreasurePos &&\n                (currentTreasurePos.x !== initialTreasurePos.x ||\n                 currentTreasurePos.z !== initialTreasurePos.z)) {\n\n                this.recordTreasureLocation(currentTreasurePos, dolphinHelper);\n                monitor.unregister();\n            }\n\n            // Timeout after 30 seconds\n            if (Client.getTime() % (20 * 30) === 0) {\n                Chat.log(\"&7Dolphin didn't find treasure within 30 seconds\");\n                monitor.unregister();\n            }\n        }));\n    }\n\n    recordTreasureLocation(treasurePos, dolphin) {\n        const posKey = `${treasurePos.x},${treasurePos.y},${treasurePos.z}`;\n\n        if (this.visitedLocations.has(posKey)) {\n            Chat.log(\"&7Dolphin found a treasure location you already know about.\");\n            return;\n        }\n\n        this.treasureLocations.set(posKey, {\n            position: treasurePos,\n            discoveredBy: dolphin.getUUID(),\n            discoveredAt: Client.getTime()\n        });\n        this.visitedLocations.add(posKey);\n\n        Chat.log(`&6✨ Dolphin found treasure at [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]!`);\n        Chat.log(\"&aMarking location on your map...\");\n\n        // Create visual marker\n        const marker = new Box(\n            treasurePos.x - 1, treasurePos.y - 1, treasurePos.z - 1,\n            treasurePos.x + 1, treasurePos.y + 1, treasurePos.z + 1,\n            0xFFD700, 0x80FFD700, true, false\n        );\n        Hud.createDraw3D().addBox(marker);\n\n        // Draw path to treasure\n        this.drawPathToTreasure(treasurePos);\n    }\n\n    drawPathToTreasure(treasurePos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const playerPos = player.getPos();\n        const steps = 20;\n        const pathPoints = [];\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = playerPos.x + (treasurePos.x - playerPos.x) * t;\n            const y = playerPos.y + (treasurePos.y - playerPos.y) * t;\n            const z = playerPos.z + (treasurePos.z - playerPos.z) * t;\n            pathPoints.push(new Pos3D(x, y, z));\n        }\n\n        // Draw path line\n        const pathLine = new Line3D(\n            pathPoints,\n            0x00FFFF, 0xFF000000, true, false\n        );\n        Hud.createDraw3D().addLine(pathLine);\n\n        Chat.log(\"&aPath to treasure highlighted for 30 seconds\");\n\n        // Remove path after 30 seconds\n        setTimeout(() => {\n            Hud.createDraw3D().removeLine(pathLine);\n        }, 30000);\n    }\n\n    scanForOpportunities() {\n        const entities = World.getEntities(this.huntRadius);\n        const dolphins = [];\n        const player = Player.getPlayer();\n\n        if (!player) return;\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const distance = player.distanceTo(entity);\n\n                dolphins.push({\n                    entity: entity,\n                    dolphin: dolphin,\n                    distance: distance,\n                    hasFish: dolphin.hasFish(),\n                    moistness: dolphin.getMoistness(),\n                    knowsTreasure: this.knowsTreasure(dolphin)\n                });\n            }\n        });\n\n        if (dolphins.length === 0) {\n            Chat.log(\"&eNo dolphins found within \" + this.huntRadius + \" blocks.\");\n            return;\n        }\n\n        Chat.log(`&a=== Dolphin Treasure Hunting Opportunities ===`);\n        Chat.log(`Found ${dolphins.length} dolphins nearby:`);\n\n        dolphins.forEach(dolphinData => {\n            const { entity, dolphin, distance, hasFish, moistness, knowsTreasure } = dolphinData;\n\n            Chat.log(`\\n&bDolphin ${distance.toFixed(1)}m away:`);\n            Chat.log(`  - Health: ${entity.asLiving().getHealth().toFixed(1)}/20`);\n            Chat.log(`  - Moisture: ${moistness}/2400 (${((moistness/2400)*100).toFixed(1)}%)`);\n            Chat.log(`  - Carrying fish: ${hasFish ? \"Yes\" : \"No\"}`);\n            Chat.log(`  - Knows treasure: ${knowsTreasure ? \"Yes\" : \"No\"}`);\n\n            if (moistness < 1200) {\n                Chat.log(`  &c⚠ Low moisture - may need to return to water soon`);\n            }\n\n            if (knowsTreasure) {\n                const treasurePos = dolphin.getTreasurePos();\n                Chat.log(`  &6✨ Treasure location: [${treasurePos.x}, ${treasurePos.y}, ${treasurePos.z}]`);\n            }\n        });\n\n        // Check if player has fish\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n        const hasFish = (mainHand && this.feedItems.includes(mainHand.getId())) ||\n                        (offHand && this.feedItems.includes(offHand.getId()));\n\n        if (hasFish) {\n            Chat.log(`\\n&a✓ You have fish for feeding dolphins!`);\n        } else {\n            Chat.log(`\\n&eTip: Hold fish to feed dolphins for treasure hunting`);\n        }\n    }\n\n    knowsTreasure(dolphin) {\n        const pos = dolphin.getTreasurePos();\n        return pos && (pos.x !== 0 || pos.y !== 0 || pos.z !== 0);\n    }\n\n    generateTreasureReport() {\n        Chat.log(\"=== Treasure Discovery Report ===\");\n        Chat.log(`Total treasure locations found: ${this.treasureLocations.size}`);\n\n        if (this.treasureLocations.size === 0) {\n            Chat.log(\"No treasure locations discovered yet. Feed dolphins to find treasure!\");\n            return;\n        }\n\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        for (const [posKey, treasureData] of this.treasureLocations) {\n            const { position, discoveredAt } = treasureData;\n            const distance = player.distanceTo(position);\n            const age = Client.getTime() - discoveredAt;\n            const ageMinutes = Math.floor(age / (20 * 60));\n\n            Chat.log(`\\n&6Treasure at [${position.x}, ${position.y}, ${position.z}]:`);\n            Chat.log(`  - Distance: ${distance.toFixed(1)}m`);\n            Chat.log(`  - Discovered: ${ageMinutes} minute${ageMinutes !== 1 ? 's' : ''} ago`);\n            Chat.log(`  - Status: ${distance <= 10 ? \"&aVery close!\" : distance <= 50 ? \"&eNearby\" : \"&7Far away\"}`);\n        }\n    }\n}\n\n// Initialize treasure hunter\nconst treasureHunter = new DolphinTreasureHunter();\n\n// Command aliases\nJsMacros.on(\"Key\", JavaWrapper.methodToJavaAsync((event) => {\n    if (event.key === \"F1\") {\n        treasureHunter.scanForOpportunities();\n    } else if (event.key === \"F2\") {\n        treasureHunter.generateTreasureReport();\n    }\n}));\n\nChat.log(\"&aDolphin Treasure Hunter initialized!\");\nChat.log(\"&ePress F1 to scan for hunting opportunities\");\nChat.log(\"&ePress F2 to view discovered treasure locations\");",
        "// Monitor and manage dolphin health and moisture levels\nclass DolphinCareManager {\n    constructor() {\n        this.underConstruction = new Set();\n        this.safeZones = [];\n        this.moistnessThresholds = {\n            critical: 300,    // 15 seconds\n            warning: 600,     // 30 seconds\n            safe: 1200        // 1 minute\n        };\n    }\n\n    createSafeZone(centerPos, radius = 20) {\n        const safeZone = {\n            center: centerPos,\n            radius: radius,\n            created: Client.getTime()\n        };\n\n        this.safeZones.push(safeZone);\n\n        // Create visual marker for safe zone\n        const zoneBox = new Box(\n            centerPos.x - radius, centerPos.y - radius, centerPos.z - radius,\n            centerPos.x + radius, centerPos.y + radius, centerPos.z + radius,\n            0x0000FF, 0x400000FF, true, false\n        );\n        Hud.createDraw3D().addBox(zoneBox);\n\n        Chat.log(`&aCreated dolphin safe zone at [${centerPos.x}, ${centerPos.y}, ${centerPos.z}] (${radius}m radius)`);\n    }\n\n    checkDolphinSafety(dolphinEntity) {\n        const dolphin = dolphinEntity.asDolphin();\n        const pos = dolphin.getPos();\n        const moistness = dolphin.getMoistness();\n        const isAlive = dolphin.asLiving().isAlive();\n\n        if (!isAlive) return;\n\n        // Check moisture levels\n        if (moistness <= this.moistnessThresholds.critical) {\n            this.handleCriticalMoisture(dolphin, pos, moistness);\n        } else if (moistness <= this.moistnessThresholds.warning) {\n            this.handleLowMoisture(dolphin, pos, moistness);\n        }\n\n        // Check if dolphin is in water\n        const block = World.getBlock(pos.x, pos.y, pos.z);\n        const isInWater = block && block.is(\"minecraft:water\");\n\n        if (!isInWater && moistness < this.moistnessThresholds.safe) {\n            this.guideDolphinToWater(dolphin, pos);\n        }\n    }\n\n    handleCriticalMoisture(dolphin, pos, moistness) {\n        const uuid = dolphin.getUUID();\n\n        if (this.underConstruction.has(uuid)) return;\n\n        Chat.log(`&c⚠ CRITICAL: Dolphin at [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] has only ${moistness} moisture!`);\n        Chat.log(\"&cImmediate water access required!\");\n\n        // Flash red warning\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFF0000);\n\n        // Guide to nearest water\n        this.guideDolphinToWater(dolphin, pos);\n        this.underConstruction.add(uuid);\n    }\n\n    handleLowMoisture(dolphin, pos, moistness) {\n        Chat.actionbar(`&eDolphin moisture low: ${moistness}/2400`);\n        dolphin.setGlowing(true);\n        dolphin.setGlowingColor(0xFFAA00);\n    }\n\n    guideDolphinToWater(dolphin, pos) {\n        // Find nearest water source\n        const searchRadius = 30;\n        let nearestWater = null;\n        let nearestDistance = searchRadius;\n\n        for (let x = pos.x - searchRadius; x <= pos.x + searchRadius; x += 2) {\n            for (let z = pos.z - searchRadius; z <= pos.z + searchRadius; z += 2) {\n                for (let y = Math.max(0, pos.y - 10); y <= pos.y + 10; y++) {\n                    const block = World.getBlock(x, y, z);\n                    if (block && block.is(\"minecraft:water\")) {\n                        const waterPos = new Pos3D(x, y, z);\n                        const distance = Math.sqrt(\n                            Math.pow(pos.x - x, 2) +\n                            Math.pow(pos.y - y, 2) +\n                            Math.pow(pos.z - z, 2)\n                        );\n\n                        if (distance < nearestDistance) {\n                            nearestDistance = distance;\n                            nearestWater = waterPos;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (nearestWater) {\n            Chat.log(`&bGuiding dolphin to water at [${nearestWater.x}, ${nearestWater.y}, ${nearestWater.z}] (${nearestDistance.toFixed(1)}m away)`);\n\n            // Draw path to water\n            const pathLine = new Line3D(\n                [pos, nearestWater],\n                0x00FFFF, 0xFF000000, true, false\n            );\n            Hud.createDraw3D().addLine(pathLine);\n\n            // Remove path after 10 seconds\n            setTimeout(() => {\n                Hud.createDraw3D().removeLine(pathLine);\n            }, 10000);\n        } else {\n            Chat.log(`&cNo water found within ${searchRadius}m blocks! Dolphin may not survive.`);\n        }\n    }\n\n    scanForDolphinsInNeed() {\n        const entities = World.getEntities(100);\n        const dolphinsInNeed = [];\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                const dolphin = entity.asDolphin();\n                const moistness = dolphin.getMoistness();\n\n                if (moistness <= this.moistnessThresholds.warning) {\n                    dolphinsInNeed.push({\n                        entity: entity,\n                        dolphin: dolphin,\n                        moistness: moistness,\n                        pos: entity.getPos()\n                    });\n                }\n            }\n        });\n\n        if (dolphinsInNeed.length === 0) {\n            Chat.log(\"&aAll dolphins in the area have healthy moisture levels!\");\n            return;\n        }\n\n        Chat.log(`&e=== Dolphin Moisture Alert ===`);\n        Chat.log(`Found ${dolphinsInNeed.length} dolphin${dolphinsInNeed.length > 1 ? 's' : ''} in need of water:`);\n\n        dolphinsInNeed.forEach(({ dolphin, moistness, pos }) => {\n            const status = moistness <= this.moistnessThresholds.critical ? \"&cCRITICAL\" : \"&eWARNING\";\n            Chat.log(`${status}: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}] - ${moistness}/2400 moisture`);\n        });\n    }\n\n    createWaterSource(pos) {\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        // This would typically be done by placing water blocks or using commands\n        Chat.log(`&eCreating emergency water source at [${pos.x}, ${pos.y}, ${pos.z}]`);\n\n        // Mark water source location\n        const waterMarker = new Box(\n            pos.x - 1, pos.y, pos.z - 1,\n            pos.x + 1, pos.y + 1, pos.z + 1,\n            0x0000FF, 0x800000FF, true, false\n        );\n        Hud.createDraw3D().addBox(waterMarker);\n    }\n\n    update() {\n        const entities = World.getEntities(100);\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:dolphin\")) {\n                this.checkDolphinSafety(entity);\n            }\n        });\n\n        // Clean up construction flags\n        this.underConstruction.clear();\n    }\n}\n\n// Initialize dolphin care manager\nconst dolphinCare = new DolphinCareManager();\n\n// Monitor every 2 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 40 === 0) {\n        dolphinCare.update();\n    }\n}));\n\n// Check for dolphins in need every 10 seconds\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 200 === 0) {\n        dolphinCare.scanForDolphinsInNeed();\n    }\n}));\n\nChat.log(\"&aDolphin Care Manager activated! Monitoring moisture and health.\");"
      ]
    }
  ]
}