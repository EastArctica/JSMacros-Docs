{
  "name": "TridentEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.TridentEntityHelper",
  "extends": "EntityHelper<TridentEntity>",
  "since": "JSMacros 1.8.4",
  "description": "The `TridentEntityHelper` class provides specialized access to trident entities in Minecraft, offering methods to monitor and interact with trident-specific behaviors such as loyalty enchantment status and enchantment detection. This class extends `EntityHelper` and inherits all functionality for entities including position tracking, movement monitoring, and world interaction.",
  "overview": "This helper is particularly useful for creating scripts that detect trident projectiles, monitor their behavior patterns, track loyalty effects, or analyze combat scenarios involving tridents.",
  "constructors": [
    {
      "signature": "No direct constructor call",
      "description": "TridentEntityHelper instances are not typically created directly by scripters. Instead, they are obtained through:\n- Entity-related events (e.g., `EntitySpawn`, `EntityDeath`, `ProjectileHit`)\n- World entity queries using type filtering for \"minecraft:trident\"\n- Casting from generic EntityHelper instances when dealing with trident entities",
      "parameters": []
    }
  ],
  "methods": [
    {
      "name": "hasLoyalty",
      "signature": "hasLoyalty()",
      "returnType": "boolean",
      "description": "Checks if the trident entity has the Loyalty enchantment (level > 0).",
      "parameters": [],
      "static": false,
      "examples": [
        "// Detect and classify tridents in the world\nfunction detectAndClassifyTridents() {\n    const entities = World.getEntities();\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const tridents = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:trident\")) {\n            const trident = entity;\n            const distance = player.distanceTo(trident);\n            const hasLoyalty = trident.hasLoyalty();\n            const isEnchanted = trident.isEnchanted();\n            const pos = trident.getPos();\n            const velocity = trident.getVelocity();\n            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);\n\n            tridents.push({\n                trident: trident,\n                distance: distance,\n                position: pos,\n                hasLoyalty: hasLoyalty,\n                isEnchanted: isEnchanted,\n                speed: speed,\n                moving: speed > 0.1\n            });\n        }\n    });\n\n    if (tridents.length > 0) {\n        Chat.log(`Found ${tridents.length} trident(s):`);\n\n        tridents.forEach((tridentData, index) => {\n            const type = tridentData.hasLoyalty ? \"Loyal\" : \"Regular\";\n            const enchanted = tridentData.isEnchanted ? \" (Enchanted)\" : \"\";\n            const movement = tridentData.moving ? ` (Moving: ${tridentData.speed.toFixed(1)} b/s)` : \" (Stationary)\";\n\n            Chat.log(`${index + 1}. ${type} Trident${enchanted}${movement} - ${tridentData.distance.toFixed(1)}m away`);\n\n            // Color-code based on properties\n            if (tridentData.hasLoyalty) {\n                tridentData.trident.setGlowing(true);\n                tridentData.trident.setGlowingColor(0x0099FF); // Blue for loyalty\n            } else if (tridentData.isEnchanted) {\n                tridentData.trident.setGlowing(true);\n                tridentData.trident.setGlowingColor(0xFFAA00); // Orange for enchanted\n            }\n        });\n    }\n}\n\n// Run detection every second\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 20 === 0) {\n        detectAndClassifyTridents();\n    }\n}));",
        "// Track trident loyalty behavior and return patterns\nclass LoyaltyTracker {\n    constructor() {\n        this.tridentLifetimes = new Map();\n        this.loyaltyStatistics = {\n            totalTridents: 0,\n            loyalTridents: 0,\n            averageReturnTime: 0,\n            returnTimes: []\n        };\n    }\n\n    onTridentSpawn(trident) {\n        const uuid = trident.getUUID();\n        const hasLoyalty = trident.hasLoyalty();\n\n        this.loyaltyStatistics.totalTridents++;\n        if (hasLoyalty) {\n            this.loyaltyStatistics.loyalTridents++;\n        }\n\n        this.tridentLifetimes.set(uuid, {\n            trident: trident,\n            hasLoyalty: hasLoyalty,\n            spawnTime: Client.getTime(),\n            returnStartTime: null,\n            peakDistance: 0,\n            owner: null\n        });\n\n        const type = hasLoyalty ? \"Loyal\" : \"Regular\";\n        Chat.log(`&9${type} trident spawned and tracked`);\n    }\n\n    onTridentUpdate(trident) {\n        const uuid = trident.getUUID();\n        const tracker = this.tridentLifetimes.get(uuid);\n\n        if (!tracker) {\n            this.onTridentSpawn(trident);\n            return;\n        }\n\n        const pos = trident.getPos();\n        const velocity = trident.getVelocity();\n        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.z * velocity.z);\n        const player = Player.getPlayer();\n\n        if (player) {\n            const distance = player.distanceTo(trident);\n            tracker.peakDistance = Math.max(tracker.peakDistance, distance);\n\n            // Detect when a loyal trident starts returning\n            if (tracker.hasLoyalty && tracker.returnStartTime === null && speed > 5 && distance < 20) {\n                tracker.returnStartTime = Client.getTime();\n                Chat.log(`&9Loyal trident starting return journey (max distance: ${tracker.peakDistance.toFixed(1)}m)`);\n            }\n\n            // Check if trident is returning to player\n            if (tracker.hasLoyalty && tracker.returnStartTime !== null) {\n                const returnDuration = (Client.getTime() - tracker.returnStartTime) / 20;\n\n                if (distance < 2 && speed < 1) {\n                    // Trident has returned to player\n                    this.onTridentReturned(tracker);\n                } else {\n                    // Still returning\n                    Chat.actionbar(`&9Trident returning: ${distance.toFixed(1)}m away (${returnDuration.toFixed(1)}s)`);\n                }\n            }\n        }\n    }\n\n    onTridentReturned(tracker) {\n        const returnTime = (Client.getTime() - tracker.returnStartTime) / 20;\n        this.loyaltyStatistics.returnTimes.push(returnTime);\n        this.updateAverageReturnTime();\n\n        Chat.log(`&aLoyal trident returned to player in ${returnTime.toFixed(2)} seconds (max distance: ${tracker.peakDistance.toFixed(1)}m)`);\n        this.tridentLifetimes.delete(tracker.trident.getUUID());\n    }\n\n    updateAverageReturnTime() {\n        if (this.loyaltyStatistics.returnTimes.length > 0) {\n            const sum = this.loyaltyStatistics.returnTimes.reduce((a, b) => a + b, 0);\n            this.loyaltyStatistics.averageReturnTime = sum / this.loyaltyStatistics.returnTimes.length;\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:trident\")) {\n                const uuid = entity.getUUID();\n                currentUUIDs.add(uuid);\n                this.onTridentUpdate(entity);\n            }\n        });\n\n        // Clean up despawned tridents\n        for (const [uuid, tracker] of this.tridentLifetimes) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - tracker.spawnTime) / 20;\n                const type = tracker.hasLoyalty ? \"Loyal\" : \"Regular\";\n                Chat.log(`&7${type} trident despawned (lived ${lifetime.toFixed(1)}s)`);\n                this.tridentLifetimes.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        const loyaltyPercentage = this.loyaltyStatistics.totalTridents > 0 ?\n            (this.loyaltyStatistics.loyalTridents / this.loyaltyStatistics.totalTridents * 100).toFixed(1) : 0;\n\n        Chat.log(\"=== Loyalty Tracking Report ===\");\n        Chat.log(`Total tridents tracked: ${this.loyaltyStatistics.totalTridents}`);\n        Chat.log(`Loyalty tridents: ${this.loyaltyStatistics.loyalTridents} (${loyaltyPercentage}%)`);\n        Chat.log(`Currently tracking: ${this.tridentLifetimes.size}`);\n\n        if (this.loyaltyStatistics.averageReturnTime > 0) {\n            Chat.log(`Average return time: ${this.loyaltyStatistics.averageReturnTime.toFixed(2)} seconds`);\n            Chat.log(`Successful returns recorded: ${this.loyaltyStatistics.returnTimes.length}`);\n        }\n    }\n}\n\n// Initialize loyalty tracker\nconst loyaltyTracker = new LoyaltyTracker();\n\n// Update every 5 ticks (4 times per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 5 === 0) {\n        loyaltyTracker.update();\n    }\n}));\n\n// Generate report every 2 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 2) === 0) {\n        loyaltyTracker.generateReport();\n    }\n}));\n\nChat.log(\"&aTrident Loyalty Tracker activated\");",
        "// Analyze the effectiveness of tridents in combat scenarios\nclass TridentCombatAnalyzer {\n    constructor() {\n        this.combatEvents = [];\n        this.tridentStats = new Map();\n        this.effectivenessMetrics = {\n            totalTridents: 0,\n            hitsLanded: 0,\n            missedShots: 0,\n            enchantmentEffectiveness: new Map()\n        };\n    }\n\n    recordTridentLaunch(trident, sourcePlayer) {\n        const uuid = trident.getUUID();\n        const hasLoyalty = trident.hasLoyalty();\n        const isEnchanted = trident.isEnchanted();\n\n        let enchantments = [];\n        if (isEnchanted) {\n            const nbt = trident.getNBT();\n            if (nbt.contains(\"Loyalty\")) enchantments.push(`Loyalty ${nbt.getInt(\"Loyalty\")}`);\n            if (nbt.contains(\"Impaling\")) enchantments.push(`Impaling ${nbt.getInt(\"Impaling\")}`);\n            if (nbt.contains(\"Riptide\")) enchantments.push(`Riptide ${nbt.getInt(\"Riptide\")}`);\n            if (nbt.contains(\"Channeling\")) enchantments.push(\"Channeling\");\n        }\n\n        this.tridentStats.set(uuid, {\n            trident: trident,\n            sourcePlayer: sourcePlayer,\n            launchTime: Client.getTime(),\n            hasLoyalty: hasLoyalty,\n            enchantments: enchantments,\n            hits: 0,\n            hitTargets: new Set(),\n            maxDistance: 0\n        });\n\n        const type = hasLoyalty ? \"Loyal\" : \"Regular\";\n        const enchants = enchantments.length > 0 ? ` (${enchantments.join(\", \")})` : \"\";\n        Chat.log(`&9${type} trident launched${enchants}`);\n    }\n\n    recordProjectileHit(event) {\n        // This would be triggered by projectile hit events\n        const projectile = event.getProjectile();\n        if (projectile && projectile.is(\"minecraft:trident\")) {\n            const uuid = projectile.getUUID();\n            const stats = this.tridentStats.get(uuid);\n\n            if (stats) {\n                stats.hits++;\n                stats.hitTargets.add(event.getEntity().getUUID());\n\n                const target = event.getEntity();\n                const targetName = target.getName().getString();\n                const distance = projectile.distanceTo(target);\n                stats.maxDistance = Math.max(stats.maxDistance, distance);\n\n                Chat.log(`&cTrident hit ${targetName} at ${distance.toFixed(1)}m distance`);\n                this.effectivenessMetrics.hitsLanded++;\n\n                // Analyze enchantment effectiveness\n                stats.enchantments.forEach(enchantment => {\n                    const [name, level] = enchantment.split(\" \");\n                    const key = level ? `${name}_${level}` : name;\n                    this.effectivenessMetrics.enchantmentEffectiveness.set(\n                        key,\n                        (this.effectivenessMetrics.enchantmentEffectiveness.get(key) || 0) + 1\n                    );\n                });\n            }\n        }\n    }\n\n    updateTracking() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:trident\")) {\n                currentUUIDs.add(entity.getUUID());\n            }\n        });\n\n        // Check for tridents that disappeared without hitting\n        for (const [uuid, stats] of this.tridentStats) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - stats.launchTime) / 20;\n\n                if (stats.hits === 0) {\n                    this.effectivenessMetrics.missedShots++;\n                    Chat.log(`&7Trident missed (lived ${lifetime.toFixed(1)}s)`);\n                } else {\n                    const targetsHit = stats.hitTargets.size;\n                    const efficiency = targetsHit > 0 ? (stats.hits / targetsHit).toFixed(2) : \"0\";\n                    Chat.log(`&aTrident analysis complete: ${stats.hits} hits on ${targetsHit} targets, max distance ${stats.maxDistance.toFixed(1)}m, efficiency ${efficiency}`);\n                }\n\n                this.tridentStats.delete(uuid);\n            }\n        }\n    }\n\n    generateCombatReport() {\n        const accuracy = this.effectivenessMetrics.totalTridents > 0 ?\n            (this.effectivenessMetrics.hitsLanded / this.effectivenessMetrics.totalTridents * 100).toFixed(1) : 0;\n\n        Chat.log(\"=== Trident Combat Report ===\");\n        Chat.log(`Total tridents analyzed: ${this.effectivenessMetrics.totalTridents}`);\n        Chat.log(`Successful hits: ${this.effectivenessMetrics.hitsLanded}`);\n        Chat.log(`Missed shots: ${this.effectivenessMetrics.missedShots}`);\n        Chat.log(`Accuracy rate: ${accuracy}%`);\n        Chat.log(`Currently tracking: ${this.tridentStats.size}`);\n\n        if (this.effectivenessMetrics.enchantmentEffectiveness.size > 0) {\n            Chat.log(\"\\nEnchantment effectiveness:\");\n            const sortedEffects = Array.from(this.effectivenessMetrics.enchantmentEffectiveness.entries())\n                .sort((a, b) => b[1] - a[1]);\n\n            sortedEffects.forEach(([enchantment, hits]) => {\n                Chat.log(`  ${enchantment}: ${hits} successful hits`);\n            });\n        }\n    }\n}\n\n// Initialize combat analyzer\nconst combatAnalyzer = new TridentCombatAnalyzer();\n\n// Track trident launches (would need player interaction events)\nevents.on(\"EntitySpawn\", JavaWrapper.methodToJavaAsync((event) => {\n    const entity = event.getEntity();\n    if (entity.is(\"minecraft:trident\")) {\n        combatAnalyzer.effectivenessMetrics.totalTridents++;\n        // In a real implementation, you'd determine the source player here\n        combatAnalyzer.recordTridentLaunch(entity, null);\n    }\n}));\n\n// Update tracking every 20 ticks (once per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 20 === 0) {\n        combatAnalyzer.updateTracking();\n    }\n}));\n\n// Generate combat report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        combatAnalyzer.generateCombatReport();\n    }\n}));\n\nChat.log(\"&aTrident Combat Analyzer activated\");"
      ]
    },
    {
      "name": "isEnchanted",
      "signature": "isEnchanted()",
      "returnType": "boolean",
      "description": "Checks if the trident entity has any enchantments.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Detect and classify tridents in the world\nfunction detectAndClassifyTridents() {\n    const entities = World.getEntities();\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const tridents = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:trident\")) {\n            const trident = entity;\n            const distance = player.distanceTo(trident);\n            const hasLoyalty = trident.hasLoyalty();\n            const isEnchanted = trident.isEnchanted();\n            const pos = trident.getPos();\n            const velocity = trident.getVelocity();\n            const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);\n\n            tridents.push({\n                trident: trident,\n                distance: distance,\n                position: pos,\n                hasLoyalty: hasLoyalty,\n                isEnchanted: isEnchanted,\n                speed: speed,\n                moving: speed > 0.1\n            });\n        }\n    });\n\n    if (tridents.length > 0) {\n        Chat.log(`Found ${tridents.length} trident(s):`);\n\n        tridents.forEach((tridentData, index) => {\n            const type = tridentData.hasLoyalty ? \"Loyal\" : \"Regular\";\n            const enchanted = tridentData.isEnchanted ? \" (Enchanted)\" : \"\";\n            const movement = tridentData.moving ? ` (Moving: ${tridentData.speed.toFixed(1)} b/s)` : \" (Stationary)\";\n\n            Chat.log(`${index + 1}. ${type} Trident${enchanted}${movement} - ${tridentData.distance.toFixed(1)}m away`);\n\n            // Color-code based on properties\n            if (tridentData.hasLoyalty) {\n                tridentData.trident.setGlowing(true);\n                tridentData.trident.setGlowingColor(0x0099FF); // Blue for loyalty\n            } else if (tridentData.isEnchanted) {\n                tridentData.trident.setGlowing(true);\n                tridentData.trident.setGlowingColor(0xFFAA00); // Orange for enchanted\n            }\n        });\n    }\n}\n\n// Run detection every second\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 20 === 0) {\n        detectAndClassifyTridents();\n    }\n}));",
        "// Track trident loyalty behavior and return patterns\nclass LoyaltyTracker {\n    constructor() {\n        this.tridentLifetimes = new Map();\n        this.loyaltyStatistics = {\n            totalTridents: 0,\n            loyalTridents: 0,\n            averageReturnTime: 0,\n            returnTimes: []\n        };\n    }\n\n    onTridentSpawn(trident) {\n        const uuid = trident.getUUID();\n        const hasLoyalty = trident.hasLoyalty();\n\n        this.loyaltyStatistics.totalTridents++;\n        if (hasLoyalty) {\n            this.loyaltyStatistics.loyalTridents++;\n        }\n\n        this.tridentLifetimes.set(uuid, {\n            trident: trident,\n            hasLoyalty: hasLoyalty,\n            spawnTime: Client.getTime(),\n            returnStartTime: null,\n            peakDistance: 0,\n            owner: null\n        });\n\n        const type = hasLoyalty ? \"Loyal\" : \"Regular\";\n        Chat.log(`&9${type} trident spawned and tracked`);\n    }\n\n    onTridentUpdate(trident) {\n        const uuid = trident.getUUID();\n        const tracker = this.tridentLifetimes.get(uuid);\n\n        if (!tracker) {\n            this.onTridentSpawn(trident);\n            return;\n        }\n\n        const pos = trident.getPos();\n        const velocity = trident.getVelocity();\n        const speed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.z * velocity.z);\n        const player = Player.getPlayer();\n\n        if (player) {\n            const distance = player.distanceTo(trident);\n            tracker.peakDistance = Math.max(tracker.peakDistance, distance);\n\n            // Detect when a loyal trident starts returning\n            if (tracker.hasLoyalty && tracker.returnStartTime === null && speed > 5 && distance < 20) {\n                tracker.returnStartTime = Client.getTime();\n                Chat.log(`&9Loyal trident starting return journey (max distance: ${tracker.peakDistance.toFixed(1)}m)`);\n            }\n\n            // Check if trident is returning to player\n            if (tracker.hasLoyalty && tracker.returnStartTime !== null) {\n                const returnDuration = (Client.getTime() - tracker.returnStartTime) / 20;\n\n                if (distance < 2 && speed < 1) {\n                    // Trident has returned to player\n                    this.onTridentReturned(tracker);\n                } else {\n                    // Still returning\n                    Chat.actionbar(`&9Trident returning: ${distance.toFixed(1)}m away (${returnDuration.toFixed(1)}s)`);\n                }\n            }\n        }\n    }\n\n    onTridentReturned(tracker) {\n        const returnTime = (Client.getTime() - tracker.returnStartTime) / 20;\n        this.loyaltyStatistics.returnTimes.push(returnTime);\n        this.updateAverageReturnTime();\n\n        Chat.log(`&aLoyal trident returned to player in ${returnTime.toFixed(2)} seconds (max distance: ${tracker.peakDistance.toFixed(1)}m)`);\n        this.tridentLifetimes.delete(tracker.trident.getUUID());\n    }\n\n    updateAverageReturnTime() {\n        if (this.loyaltyStatistics.returnTimes.length > 0) {\n            const sum = this.loyaltyStatistics.returnTimes.reduce((a, b) => a + b, 0);\n            this.loyaltyStatistics.averageReturnTime = sum / this.loyaltyStatistics.returnTimes.length;\n        }\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:trident\")) {\n                const uuid = entity.getUUID();\n                currentUUIDs.add(uuid);\n                this.onTridentUpdate(entity);\n            }\n        });\n\n        // Clean up despawned tridents\n        for (const [uuid, tracker] of this.tridentLifetimes) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - tracker.spawnTime) / 20;\n                const type = tracker.hasLoyalty ? \"Loyal\" : \"Regular\";\n                Chat.log(`&7${type} trident despawned (lived ${lifetime.toFixed(1)}s)`);\n                this.tridentLifetimes.delete(uuid);\n            }\n        }\n    }\n\n    generateReport() {\n        const loyaltyPercentage = this.loyaltyStatistics.totalTridents > 0 ?\n            (this.loyaltyStatistics.loyalTridents / this.loyaltyStatistics.totalTridents * 100).toFixed(1) : 0;\n\n        Chat.log(\"=== Loyalty Tracking Report ===\");\n        Chat.log(`Total tridents tracked: ${this.loyaltyStatistics.totalTridents}`);\n        Chat.log(`Loyalty tridents: ${this.loyaltyStatistics.loyalTridents} (${loyaltyPercentage}%)`);\n        Chat.log(`Currently tracking: ${this.tridentLifetimes.size}`);\n\n        if (this.loyaltyStatistics.averageReturnTime > 0) {\n            Chat.log(`Average return time: ${this.loyaltyStatistics.averageReturnTime.toFixed(2)} seconds`);\n            Chat.log(`Successful returns recorded: ${this.loyaltyStatistics.returnTimes.length}`);\n        }\n    }\n}\n\n// Initialize loyalty tracker\nconst loyaltyTracker = new LoyaltyTracker();\n\n// Update every 5 ticks (4 times per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 5 === 0) {\n        loyaltyTracker.update();\n    }\n}));\n\n// Generate report every 2 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 2) === 0) {\n        loyaltyTracker.generateReport();\n    }\n}));\n\nChat.log(\"&aTrident Loyalty Tracker activated\");",
        "// Analyze the effectiveness of tridents in combat scenarios\nclass TridentCombatAnalyzer {\n    constructor() {\n        this.combatEvents = [];\n        this.tridentStats = new Map();\n        this.effectivenessMetrics = {\n            totalTridents: 0,\n            hitsLanded: 0,\n            missedShots: 0,\n            enchantmentEffectiveness: new Map()\n        };\n    }\n\n    recordTridentLaunch(trident, sourcePlayer) {\n        const uuid = trident.getUUID();\n        const hasLoyalty = trident.hasLoyalty();\n        const isEnchanted = trident.isEnchanted();\n\n        let enchantments = [];\n        if (isEnchanted) {\n            const nbt = trident.getNBT();\n            if (nbt.contains(\"Loyalty\")) enchantments.push(`Loyalty ${nbt.getInt(\"Loyalty\")}`);\n            if (nbt.contains(\"Impaling\")) enchantments.push(`Impaling ${nbt.getInt(\"Impaling\")}`);\n            if (nbt.contains(\"Riptide\")) enchantments.push(`Riptide ${nbt.getInt(\"Riptide\")}`);\n            if (nbt.contains(\"Channeling\")) enchantments.push(\"Channeling\");\n        }\n\n        this.tridentStats.set(uuid, {\n            trident: trident,\n            sourcePlayer: sourcePlayer,\n            launchTime: Client.getTime(),\n            hasLoyalty: hasLoyalty,\n            enchantments: enchantments,\n            hits: 0,\n            hitTargets: new Set(),\n            maxDistance: 0\n        });\n\n        const type = hasLoyalty ? \"Loyal\" : \"Regular\";\n        const enchants = enchantments.length > 0 ? ` (${enchantments.join(\", \")})` : \"\";\n        Chat.log(`&9${type} trident launched${enchants}`);\n    }\n\n    recordProjectileHit(event) {\n        // This would be triggered by projectile hit events\n        const projectile = event.getProjectile();\n        if (projectile && projectile.is(\"minecraft:trident\")) {\n            const uuid = projectile.getUUID();\n            const stats = this.tridentStats.get(uuid);\n\n            if (stats) {\n                stats.hits++;\n                stats.hitTargets.add(event.getEntity().getUUID());\n\n                const target = event.getEntity();\n                const targetName = target.getName().getString();\n                const distance = projectile.distanceTo(target);\n                stats.maxDistance = Math.max(stats.maxDistance, distance);\n\n                Chat.log(`&cTrident hit ${targetName} at ${distance.toFixed(1)}m distance`);\n                this.effectivenessMetrics.hitsLanded++;\n\n                // Analyze enchantment effectiveness\n                stats.enchantments.forEach(enchantment => {\n                    const [name, level] = enchantment.split(\" \");\n                    const key = level ? `${name}_${level}` : name;\n                    this.effectivenessMetrics.enchantmentEffectiveness.set(\n                        key,\n                        (this.effectivenessMetrics.enchantmentEffectiveness.get(key) || 0) + 1\n                    );\n                });\n            }\n        }\n    }\n\n    updateTracking() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:trident\")) {\n                currentUUIDs.add(entity.getUUID());\n            }\n        });\n\n        // Check for tridents that disappeared without hitting\n        for (const [uuid, stats] of this.tridentStats) {\n            if (!currentUUIDs.has(uuid)) {\n                const lifetime = (Client.getTime() - stats.launchTime) / 20;\n\n                if (stats.hits === 0) {\n                    this.effectivenessMetrics.missedShots++;\n                    Chat.log(`&7Trident missed (lived ${lifetime.toFixed(1)}s)`);\n                } else {\n                    const targetsHit = stats.hitTargets.size;\n                    const efficiency = targetsHit > 0 ? (stats.hits / targetsHit).toFixed(2) : \"0\";\n                    Chat.log(`&aTrident analysis complete: ${stats.hits} hits on ${targetsHit} targets, max distance ${stats.maxDistance.toFixed(1)}m, efficiency ${efficiency}`);\n                }\n\n                this.tridentStats.delete(uuid);\n            }\n        }\n    }\n\n    generateCombatReport() {\n        const accuracy = this.effectivenessMetrics.totalTridents > 0 ?\n            (this.effectivenessMetrics.hitsLanded / this.effectivenessMetrics.totalTridents * 100).toFixed(1) : 0;\n\n        Chat.log(\"=== Trident Combat Report ===\");\n        Chat.log(`Total tridents analyzed: ${this.effectivenessMetrics.totalTridents}`);\n        Chat.log(`Successful hits: ${this.effectivenessMetrics.hitsLanded}`);\n        Chat.log(`Missed shots: ${this.effectivenessMetrics.missedShots}`);\n        Chat.log(`Accuracy rate: ${accuracy}%`);\n        Chat.log(`Currently tracking: ${this.tridentStats.size}`);\n\n        if (this.effectivenessMetrics.enchantmentEffectiveness.size > 0) {\n            Chat.log(\"\\nEnchantment effectiveness:\");\n            const sortedEffects = Array.from(this.effectivenessMetrics.enchantmentEffectiveness.entries())\n                .sort((a, b) => b[1] - a[1]);\n\n            sortedEffects.forEach(([enchantment, hits]) => {\n                Chat.log(`  ${enchantment}: ${hits} successful hits`);\n            });\n        }\n    }\n}\n\n// Initialize combat analyzer\nconst combatAnalyzer = new TridentCombatAnalyzer();\n\n// Track trident launches (would need player interaction events)\nevents.on(\"EntitySpawn\", JavaWrapper.methodToJavaAsync((event) => {\n    const entity = event.getEntity();\n    if (entity.is(\"minecraft:trident\")) {\n        combatAnalyzer.effectivenessMetrics.totalTridents++;\n        // In a real implementation, you'd determine the source player here\n        combatAnalyzer.recordTridentLaunch(entity, null);\n    }\n}));\n\n// Update tracking every 20 ticks (once per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 20 === 0) {\n        combatAnalyzer.updateTracking();\n    }\n}));\n\n// Generate combat report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        combatAnalyzer.generateCombatReport();\n    }\n}));\n\nChat.log(\"&aTrident Combat Analyzer activated\");"
      ]
    }
  ]
}