{
  "name": "ChatHudLineHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper",
  "extends": "BaseHelper<ChatHudLine>",
  "since": "JsMacros 1.6.0",
  "description": "The `ChatHudLineHelper` class provides a wrapper for individual chat HUD lines, allowing script writers to interact with and manipulate chat messages that have been displayed in the client's chat interface. This class is primarily used with the `ChatHistoryManager` to access, read, and manage the chat history.",
  "overview": "The `ChatHudLineHelper` class represents a single line in the chat HUD, providing access to:\n- The text content of the chat line\n- The tick when the message was created\n- Methods to delete specific messages\n- Access to the underlying Minecraft ChatHudLine object through the BaseHelper interface\n\nChatHudLineHelper objects are typically obtained through the `ChatHistoryManager` methods like `getRecvLine()`, `getRecvLines()`, or from chat-related events.",
  "constructors": [],
  "methods": [
    {
      "name": "getText",
      "signature": "getText()",
      "returnType": "TextHelper",
      "description": "Retrieves the text content of the chat line, returned as a `TextHelper` object for further manipulation.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Get the most recent chat message\nconst chatHistory = Chat.getHistory();\nconst recentLine = chatHistory.getRecvLine(0);\n\nif (recentLine) {\n    const text = recentLine.getText();\n    const content = text.getString();\n    const creationTick = recentLine.getCreationTick();\n    const age = World.getTime() - creationTick;\n\n    Chat.log(`Recent message: \"${content}\"`);\n    Chat.log(`Message age: ${age} ticks (${Math.floor(age/20)} seconds)`);\n\n    // Get formatted version\n    const jsonText = text.getJson();\n    Chat.log(`JSON format: ${jsonText}`);\n}",
        "function cleanUpChat() {\n    const chatHistory = Chat.getHistory();\n    const messageCount = chatHistory.getRecvCount();\n    let deletedCount = 0;\n\n    // Iterate through all chat messages\n    for (let i = 0; i < messageCount; i++) {\n        try {\n            const chatLine = chatHistory.getRecvLine(i);\n            if (chatLine) {\n                const content = chatLine.getText().getString();\n\n                // Delete messages containing specific patterns\n                if (content.includes(\"[ADVERT]\") ||\n                    content.includes(\"Join our server!\") ||\n                    content.toLowerCase().includes(\"spam\")) {\n\n                    Chat.log(`Deleting spam message: ${content}`);\n                    chatLine.deleteById();\n                    deletedCount++;\n                }\n            }\n        } catch (e) {\n            Chat.log(`Error processing message ${i}: ${e}`);\n        }\n    }\n\n    Chat.log(`Cleanup complete. Deleted ${deletedCount} spam messages.`);\n}\n\n// Run cleanup every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (World.getTime() % 6000 === 0) { // Every 5 minutes (6000 ticks)\n        cleanUpChat();\n    }\n}));",
        "function analyzeChatMessages() {\n    const chatHistory = Chat.getHistory();\n    const messages = chatHistory.getRecvLines();\n\n    let totalMessages = 0;\n    let oldestMessage = Infinity;\n    let newestMessage = -Infinity;\n    const wordFrequency = {};\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            totalMessages++;\n            const tick = chatLine.getCreationTick();\n            const content = chatLine.getText().getString().toLowerCase();\n\n            // Track age statistics\n            if (tick < oldestMessage) oldestMessage = tick;\n            if (tick > newestMessage) newestMessage = tick;\n\n            // Count word frequency\n            const words = content.split(/\\s+/);\n            words.forEach(word => {\n                if (word.length > 3) { // Only count words longer than 3 characters\n                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;\n                }\n            });\n        }\n    });\n\n    const timeSpan = newestMessage - oldestMessage;\n    const messagesPerMinute = totalMessages / (timeSpan / 1200); // 1200 ticks = 1 minute\n\n    Chat.log(`Chat Analysis Results:`);\n    Chat.log(`- Total messages: ${totalMessages}`);\n    Chat.log(`- Time span: ${Math.floor(timeSpan/1200)} minutes`);\n    Chat.log(`- Messages per minute: ${messagesPerMinute.toFixed(2)}`);\n\n    // Find most common words\n    const sortedWords = Object.entries(wordFrequency)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5);\n\n    Chat.log(`- Top 5 most common words:`);\n    sortedWords.forEach(([word, count]) => {\n        Chat.log(`  ${word}: ${count} times`);\n    });\n}\n\n// Analyze chat every 10 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (World.getTime() % 12000 === 0) { // Every 10 minutes\n        analyzeChatMessages();\n    }\n}));",
        "function filterOldMessages(maxAgeMinutes) {\n    const chatHistory = Chat.getHistory();\n    const maxAgeTicks = maxAgeMinutes * 1200; // Convert minutes to ticks\n    const currentTick = World.getTime();\n    const messages = chatHistory.getRecvLines();\n    let oldMessages = [];\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            const age = currentTick - chatLine.getCreationTick();\n            if (age > maxAgeTicks) {\n                const content = chatLine.getText().getString();\n                oldMessages.push({\n                    content: content,\n                    age: Math.floor(age / 1200),\n                    chatLine: chatLine\n                });\n            }\n        }\n    });\n\n    Chat.log(`Found ${oldMessages.length} messages older than ${maxAgeMinutes} minutes:`);\n    oldMessages.forEach(msg => {\n        Chat.log(`- ${msg.content} (${msg.age} minutes old)`);\n    });\n\n    return oldMessages;\n}\n\n// Example: Find messages older than 30 minutes\nconst oldMessages = filterOldMessages(30);",
        "class ChatProcessor {\n    constructor() {\n        this.filters = [];\n        this.actions = [];\n    }\n\n    addFilter(filterFn) {\n        this.filters.push(filterFn);\n        return this;\n    }\n\n    addAction(actionFn) {\n        this.actions.push(actionFn);\n        return this;\n    }\n\n    processMessage(chatLine) {\n        const content = chatLine.getText().getString();\n\n        // Apply all filters\n        for (const filter of this.filters) {\n            if (!filter(content, chatLine)) {\n                return; // Skip processing if any filter fails\n            }\n        }\n\n        // Apply all actions\n        for (const action of this.actions) {\n            action(content, chatLine);\n        }\n    }\n}\n\n// Usage example\nconst processor = new ChatProcessor()\n    .addFilter((content) => content.length > 5) // Only long messages\n    .addFilter((content) => !content.startsWith(\"[\")) // No system messages\n    .addAction((content, chatLine) => {\n        Chat.log(`Processing: ${content}`);\n    })\n    .addAction((content, chatLine) => {\n        // Save to external file or database\n    });\n\n// Apply to existing messages\nconst chatHistory = Chat.getHistory();\nconst messages = chatHistory.getRecvLines();\nmessages.forEach(processor.processMessage.bind(processor));",
        "class TemporaryChatStorage {\n    constructor(maxAge = 60000) { // Default 1 minute\n        this.messages = [];\n        this.maxAge = maxAge;\n    }\n\n    addMessage(chatLine) {\n        const message = {\n            content: chatLine.getText().getString(),\n            creationTick: chatLine.getCreationTick(),\n            addedAt: Date.now(),\n            chatLine: chatLine\n        };\n\n        this.messages.push(message);\n        this.cleanup();\n    }\n\n    cleanup() {\n        const now = Date.now();\n        this.messages = this.messages.filter(msg =>\n            now - msg.addedAt < this.maxAge\n        );\n    }\n\n    getRecentMessages(limit = 10) {\n        this.cleanup();\n        return this.messages.slice(-limit);\n    }\n\n    search(keyword) {\n        this.cleanup();\n        return this.messages.filter(msg =>\n            msg.content.toLowerCase().includes(keyword.toLowerCase())\n        );\n    }\n}\n\nconst storage = new TemporaryChatStorage(120000); // 2 minutes storage\n\n// Store new messages\nevents.on(\"RecvMessage\", JavaWrapper.methodToJavaAsync((event) => {\n    const chatHistory = Chat.getHistory();\n    const recentLine = chatHistory.getRecvLine(0);\n    if (recentLine) {\n        storage.addMessage(recentLine);\n    }\n}));",
        "function backupChatMessages() {\n    const chatHistory = Chat.getHistory();\n    const messages = chatHistory.getRecvLines();\n    const backup = [];\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            backup.push({\n                content: chatLine.getText().getString(),\n                json: chatLine.getText().getJson(),\n                creationTick: chatLine.getCreationTick(),\n                timestamp: new Date().toISOString()\n            });\n        }\n    });\n\n    // Save backup to file\n    const fileName = `chat_backup_${Date.now()}.json`;\n    const file = File.open(`${fileName}.json`, \"w\");\n    file.write(JSON.stringify(backup, null, 2));\n    file.close();\n\n    Chat.log(`Chat backup saved to ${fileName}`);\n    Chat.log(`Backed up ${backup.length} messages`);\n}\n\n// Create backup command\nChat.createCommandBuilder(\"backupchat\")\n    .executes(JavaWrapper.methodToJava((ctx) => {\n        backupChatMessages();\n        return 1;\n    }))\n    .register();"
      ]
    },
    {
      "name": "getCreationTick",
      "signature": "getCreationTick()",
      "returnType": "number",
      "description": "Returns the game tick when this chat message was created and added to the HUD.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Get the most recent chat message\nconst chatHistory = Chat.getHistory();\nconst recentLine = chatHistory.getRecvLine(0);\n\nif (recentLine) {\n    const text = recentLine.getText();\n    const content = text.getString();\n    const creationTick = recentLine.getCreationTick();\n    const age = World.getTime() - creationTick;\n\n    Chat.log(`Recent message: \"${content}\"`);\n    Chat.log(`Message age: ${age} ticks (${Math.floor(age/20)} seconds)`);\n\n    // Get formatted version\n    const jsonText = text.getJson();\n    Chat.log(`JSON format: ${jsonText}`);\n}",
        "function analyzeChatMessages() {\n    const chatHistory = Chat.getHistory();\n    const messages = chatHistory.getRecvLines();\n\n    let totalMessages = 0;\n    let oldestMessage = Infinity;\n    let newestMessage = -Infinity;\n    const wordFrequency = {};\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            totalMessages++;\n            const tick = chatLine.getCreationTick();\n            const content = chatLine.getText().getString().toLowerCase();\n\n            // Track age statistics\n            if (tick < oldestMessage) oldestMessage = tick;\n            if (tick > newestMessage) newestMessage = tick;\n\n            // Count word frequency\n            const words = content.split(/\\s+/);\n            words.forEach(word => {\n                if (word.length > 3) { // Only count words longer than 3 characters\n                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;\n                }\n            });\n        }\n    });\n\n    const timeSpan = newestMessage - oldestMessage;\n    const messagesPerMinute = totalMessages / (timeSpan / 1200); // 1200 ticks = 1 minute\n\n    Chat.log(`Chat Analysis Results:`);\n    Chat.log(`- Total messages: ${totalMessages}`);\n    Chat.log(`- Time span: ${Math.floor(timeSpan/1200)} minutes`);\n    Chat.log(`- Messages per minute: ${messagesPerMinute.toFixed(2)}`);\n\n    // Find most common words\n    const sortedWords = Object.entries(wordFrequency)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5);\n\n    Chat.log(`- Top 5 most common words:`);\n    sortedWords.forEach(([word, count]) => {\n        Chat.log(`  ${word}: ${count} times`);\n    });\n}\n\n// Analyze chat every 10 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (World.getTime() % 12000 === 0) { // Every 10 minutes\n        analyzeChatMessages();\n    }\n}));",
        "function filterOldMessages(maxAgeMinutes) {\n    const chatHistory = Chat.getHistory();\n    const maxAgeTicks = maxAgeMinutes * 1200; // Convert minutes to ticks\n    const currentTick = World.getTime();\n    const messages = chatHistory.getRecvLines();\n    let oldMessages = [];\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            const age = currentTick - chatLine.getCreationTick();\n            if (age > maxAgeTicks) {\n                const content = chatLine.getText().getString();\n                oldMessages.push({\n                    content: content,\n                    age: Math.floor(age / 1200),\n                    chatLine: chatLine\n                });\n            }\n        }\n    });\n\n    Chat.log(`Found ${oldMessages.length} messages older than ${maxAgeMinutes} minutes:`);\n    oldMessages.forEach(msg => {\n        Chat.log(`- ${msg.content} (${msg.age} minutes old)`);\n    });\n\n    return oldMessages;\n}\n\n// Example: Find messages older than 30 minutes\nconst oldMessages = filterOldMessages(30);",
        "class TemporaryChatStorage {\n    constructor(maxAge = 60000) { // Default 1 minute\n        this.messages = [];\n        this.maxAge = maxAge;\n    }\n\n    addMessage(chatLine) {\n        const message = {\n            content: chatLine.getText().getString(),\n            creationTick: chatLine.getCreationTick(),\n            addedAt: Date.now(),\n            chatLine: chatLine\n        };\n\n        this.messages.push(message);\n        this.cleanup();\n    }\n\n    cleanup() {\n        const now = Date.now();\n        this.messages = this.messages.filter(msg =>\n            now - msg.addedAt < this.maxAge\n        );\n    }\n\n    getRecentMessages(limit = 10) {\n        this.cleanup();\n        return this.messages.slice(-limit);\n    }\n\n    search(keyword) {\n        this.cleanup();\n        return this.messages.filter(msg =>\n            msg.content.toLowerCase().includes(keyword.toLowerCase())\n        );\n    }\n}\n\nconst storage = new TemporaryChatStorage(120000); // 2 minutes storage\n\n// Store new messages\nevents.on(\"RecvMessage\", JavaWrapper.methodToJavaAsync((event) => {\n    const chatHistory = Chat.getHistory();\n    const recentLine = chatHistory.getRecvLine(0);\n    if (recentLine) {\n        storage.addMessage(recentLine);\n    }\n}));",
        "function backupChatMessages() {\n    const chatHistory = Chat.getHistory();\n    const messages = chatHistory.getRecvLines();\n    const backup = [];\n\n    messages.forEach(chatLine => {\n        if (chatLine) {\n            backup.push({\n                content: chatLine.getText().getString(),\n                json: chatLine.getText().getJson(),\n                creationTick: chatLine.getCreationTick(),\n                timestamp: new Date().toISOString()\n            });\n        }\n    });\n\n    // Save backup to file\n    const fileName = `chat_backup_${Date.now()}.json`;\n    const file = File.open(`${fileName}.json`, \"w\");\n    file.write(JSON.stringify(backup, null, 2));\n    file.close();\n\n    Chat.log(`Chat backup saved to ${fileName}`);\n    Chat.log(`Backed up ${backup.length} messages`);\n}\n\n// Create backup command\nChat.createCommandBuilder(\"backupchat\")\n    .executes(JavaWrapper.methodToJava((ctx) => {\n        backupChatMessages();\n        return 1;\n    }))\n    .register();"
      ]
    },
    {
      "name": "deleteById",
      "signature": "deleteById()",
      "returnType": "void",
      "description": "Removes the chat message associated with this helper from the client's chat HUD.",
      "parameters": [],
      "static": false,
      "examples": [
        "function cleanUpChat() {\n    const chatHistory = Chat.getHistory();\n    const messageCount = chatHistory.getRecvCount();\n    let deletedCount = 0;\n\n    // Iterate through all chat messages\n    for (let i = 0; i < messageCount; i++) {\n        try {\n            const chatLine = chatHistory.getRecvLine(i);\n            if (chatLine) {\n                const content = chatLine.getText().getString();\n\n                // Delete messages containing specific patterns\n                if (content.includes(\"[ADVERT]\") ||\n                    content.includes(\"Join our server!\") ||\n                    content.toLowerCase().includes(\"spam\")) {\n\n                    Chat.log(`Deleting spam message: ${content}`);\n                    chatLine.deleteById();\n                    deletedCount++;\n                }\n            }\n        } catch (e) {\n            Chat.log(`Error processing message ${i}: ${e}`);\n        }\n    }\n\n    Chat.log(`Cleanup complete. Deleted ${deletedCount} spam messages.`);\n}\n\n// Run cleanup every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (World.getTime() % 6000 === 0) { // Every 5 minutes (6000 ticks)\n        cleanUpChat();\n    }\n}));"
      ]
    }
  ]
}