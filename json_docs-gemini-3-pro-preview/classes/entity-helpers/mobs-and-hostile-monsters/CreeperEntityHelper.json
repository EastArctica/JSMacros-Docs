{
  "name": "CreeperEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.CreeperEntityHelper",
  "extends": "MobEntityHelper<CreeperEntity>",
  "since": "1.8.4",
  "description": "The CreeperEntityHelper class provides specialized access to creeper entities in Minecraft, offering methods to monitor and interact with creeper-specific behaviors such as charging state, ignition status, and explosion timing.",
  "overview": "This class extends MobEntityHelper and inherits all functionality for living entities including health monitoring, status effects, and AI states. This helper is particularly useful for creating scripts that detect dangerous creeper situations, warn players of impending explosions, or analyze creeper behavior patterns.",
  "constructors": [],
  "methods": [
    {
      "name": "isCharged",
      "signature": "isCharged()",
      "returnType": "boolean",
      "description": "Returns true if the creeper is a lightning-powered creeper, which has a significantly larger explosion radius (6 blocks vs 3 blocks normal).",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isIgnited",
      "signature": "isIgnited()",
      "returnType": "boolean",
      "description": "Detects when a creeper has been ignited by flint and steel or other means, indicating it will explode unless defused.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getFuseChange",
      "signature": "getFuseChange()",
      "returnType": "int",
      "description": "Gets the rate at which the fuse is changing (positive if swelling/igniting, negative if cooling down).",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getFuseTime",
      "signature": "getFuseTime()",
      "returnType": "int",
      "description": "Gets the current fuse time progress in ticks.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getMaxFuseTime",
      "signature": "getMaxFuseTime()",
      "returnType": "int",
      "description": "Gets the maximum fuse time required for the creeper to explode.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getRemainingFuseTime",
      "signature": "getRemainingFuseTime()",
      "returnType": "int",
      "description": "Returns the remaining time in ticks until the creeper explodes. Returns -1 when the creeper is not actively counting down to explosion.",
      "parameters": [],
      "static": false,
      "examples": []
    }
  ],
  "examples": [
    "// Comprehensive creeper monitoring and warning system\nclass CreeperWarningSystem {\n    constructor() {\n        this.trackedCreepers = new Map();\n        this.warningLevels = {\n            safe: { distance: 16, color: 0x00FF00, message: \"Safe distance\" },\n            caution: { distance: 12, color: 0xFFFF00, message: \"Caution advised\" },\n            danger: { distance: 8, color: 0xFF8800, message: \"Danger zone\" },\n            critical: { distance: 5, color: 0xFF0000, message: \"Critical danger!\" }\n        };\n    }\n\n    analyzeCreeper(creeper) {\n        const uuid = creeper.getUUID();\n        const pos = creeper.getPos();\n        const player = Player.getPlayer();\n        if (!player) return;\n\n        const distance = player.distanceTo(creeper);\n        const isCharged = creeper.isCharged();\n        const isIgnited = creeper.isIgnited();\n        const remainingFuse = creeper.getRemainingFuseTime();\n        const fuseChange = creeper.getFuseChange();\n\n        // Determine threat level\n        let threatLevel = \"low\";\n        if (isCharged && isIgnited && remainingFuse <= 10) {\n            threatLevel = \"extreme\";\n        } else if (isCharged && isIgnited) {\n            threatLevel = \"high\";\n        } else if (isIgnited && remainingFuse <= 15) {\n            threatLevel = \"medium\";\n        } else if (distance <= 6) {\n            threatLevel = \"elevated\";\n        }\n\n        // Update tracking data\n        this.trackedCreepers.set(uuid, {\n            creeper: creeper,\n            position: pos,\n            distance: distance,\n            isCharged: isCharged,\n            isIgnited: isIgnited,\n            remainingFuse: remainingFuse,\n            fuseChange: fuseChange,\n            threatLevel: threatLevel,\n            lastUpdate: Client.getTime()\n        });\n\n        return { threatLevel, distance, isCharged, isIgnited, remainingFuse };\n    }\n\n    getWarningColor(threatLevel, distance) {\n        // Determine appropriate warning color based on threat level\n        switch (threatLevel) {\n            case \"extreme\": return 0xFF0000; // Red\n            case \"high\": return 0xFF4444; // Light red\n            case \"medium\": return 0xFF8800; // Orange\n            case \"elevated\": return 0xFFFF00; // Yellow\n            default: return 0x00FF00; // Green\n        }\n    }\n\n    generateWarningMessage(creeperData) {\n        const { threatLevel, distance, isCharged, isIgnited, remainingFuse } = creeperData;\n        let message = \"\";\n\n        if (threatLevel === \"extreme\") {\n            message = `&c&&l⚠ EXTREME DANGER! &&l⚠`;\n            if (isCharged) message += \" &6&&lCHARGED\";\n            if (isIgnited) message += \" &e&&lIGNITED\";\n            if (remainingFuse > 0) message += ` &c&&l${(remainingFuse/20).toFixed(1)}s`;\n        } else if (threatLevel === \"high\") {\n            message = `&c&&lDANGER! Charged & ignited creeper! ${(remainingFuse/20).toFixed(1)}s`;\n        } else if (threatLevel === \"medium\") {\n            message = `&eIgnited creeper: ${(remainingFuse/20).toFixed(1)}s`;\n        } else if (threatLevel === \"elevated\") {\n            message = `&6Close creeper: ${distance.toFixed(1)}m`;\n        }\n\n        if (isCharged) {\n            message += \" &6⚡\";\n        }\n\n        return message;\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentCreeperUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:creeper\")) {\n                const creeper = entity.asCreeper();\n                const uuid = creeper.getUUID();\n                currentCreeperUUIDs.add(uuid);\n\n                const creeperData = this.analyzeCreeper(creeper);\n                const warningColor = this.getWarningColor(creeperData.threatLevel, creeperData.distance);\n                const warningMessage = this.generateWarningMessage(creeperData);\n\n                // Apply visual warnings\n                if (creeperData.threatLevel !== \"low\") {\n                    creeper.setGlowing(true);\n                    creeper.setGlowingColor(warningColor);\n\n                    if (creeperData.threatLevel === \"extreme\" || creeperData.threatLevel === \"high\") {\n                        Chat.actionbar(warningMessage);\n                    }\n                } else {\n                    // Remove glow from safe creepers\n                    creeper.resetGlowing();\n                }\n            }\n        });\n\n        // Clean up removed creeper data\n        for (const [uuid, data] of this.trackedCreepers) {\n            if (!currentCreeperUUIDs.has(uuid)) {\n                Chat.log(`&7Creeper removed from tracking: ${data.threatLevel} threat level`);\n                this.trackedCreepers.delete(uuid);\n            }\n        }\n    }\n}\n\n// Initialize and run the warning system\nconst creeperWarning = new CreeperWarningSystem();\n\n// Update every tick for real-time monitoring\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    creeperWarning.update();\n}));\n\n// Log startup message\nChat.log(\"&aCreeper Warning System activated - Monitoring for dangerous creepers\");",
    "// Predict and warn about creeper explosions before they happen\nfunction predictCreeperExplosions() {\n    const entities = World.getEntities();\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const predictions = [];\n\n    entities.forEach(entity => {\n        if (entity.is(\"minecraft:creeper\")) {\n            const creeper = entity.asCreeper();\n            const pos = entity.getPos();\n            const distance = player.distanceTo(entity);\n            const isCharged = creeper.isCharged();\n            const isIgnited = creeper.isIgnited();\n            const remainingFuse = creeper.getRemainingFuseTime();\n\n            // Calculate potential explosion damage radius\n            const explosionRadius = isCharged ? 6 : 3; // Charged creepers have larger radius\n            const playerInBlastRange = distance <= explosionRadius;\n\n            if (remainingFuse > 0 && playerInBlastRange) {\n                predictions.push({\n                    creeper: creeper,\n                    position: pos,\n                    distance: distance,\n                    timeToExplosion: remainingFuse / 20,\n                    explosionRadius: explosionRadius,\n                    isCharged: isCharged,\n                    playerInBlastRange: true,\n                    threatScore: calculateThreatScore(distance, remainingFuse, isCharged)\n                });\n            }\n        }\n    });\n\n    // Sort by threat score (highest first)\n    predictions.sort((a, b) => b.threatScore - a.threatScore);\n\n    // Display top 3 most dangerous predictions\n    predictions.slice(0, 3).forEach((prediction, index) => {\n        const urgency = prediction.timeToExplosion <= 0.5 ? \"&&lIMMEDIATE\" :\n                       prediction.timeToExplosion <= 1.0 ? \"&&lURGENT\" : \"WARNING\";\n\n        Chat.log(`${index + 1}. &c${urgency}&r&c: Explosion in ${prediction.timeToExplosion.toFixed(1)}s, ` +\n                 `distance ${prediction.distance.toFixed(1)}m, ` +\n                 `radius ${prediction.explosionRadius}m${prediction.isCharged ? \" &6(CHARGED)\" : \"\"}`);\n    });\n\n    if (predictions.length > 0) {\n        Chat.actionbar(`&c${predictions.length} imminent explosion${predictions.length > 1 ? 's' : ''} detected!`);\n    }\n}\n\nfunction calculateThreatScore(distance, timeToExplosion, isCharged) {\n    let score = 0;\n\n    // Distance component (closer = more dangerous)\n    score += Math.max(0, 100 - distance * 10);\n\n    // Time component (less time = more dangerous)\n    score += Math.max(0, 100 - timeToExplosion * 50);\n\n    // Charged bonus (much more dangerous)\n    if (isCharged) score += 50;\n\n    return score;\n}\n\n// Run prediction every 5 ticks (4 times per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 5 === 0) {\n        predictCreeperExplosions();\n    }\n}));",
    "// Analyze creeper behavior patterns and statistics\nclass CreeperAnalyzer {\n    constructor() {\n        this.stats = {\n            totalSpawned: 0,\n            chargedSpawned: 0,\n            ignitedCount: 0,\n            explosions: 0,\n            averageFuseTime: 0,\n            fuseTimeSamples: [],\n            chargingPatterns: new Map()\n        };\n        this.activeCreepers = new Map();\n    }\n\n    onCreeperSpawn(creeper) {\n        this.stats.totalSpawned++;\n        if (creeper.isCharged()) {\n            this.stats.chargedSpawned++;\n        }\n\n        const uuid = creeper.getUUID();\n        this.activeCreepers.set(uuid, {\n            creeper: creeper,\n            spawnTime: Client.getTime(),\n            initialCharged: creeper.isCharged(),\n            fuseStartTime: null,\n            ignitionSource: null\n        });\n\n        Chat.log(`&eCreeper spawned (${creeper.isCharged() ? 'charged' : 'normal'})`);\n    }\n\n    onCreeperUpdate(creeper) {\n        const uuid = creeper.getUUID();\n        const creeperData = this.activeCreepers.get(uuid);\n\n        if (!creeperData) {\n            this.onCreeperSpawn(creeper);\n            return;\n        }\n\n        const isIgnited = creeper.isIgnited();\n        const fuseTime = creeper.getFuseTime();\n        const fuseChange = creeper.getFuseChange();\n\n        // Track ignition events\n        if (isIgnited && !creeperData.wasIgnited) {\n            creeperData.wasIgnited = true;\n            creeperData.fuseStartTime = Client.getTime();\n            this.stats.ignitedCount++;\n\n            Chat.log(`&cCreeper ignited! Fuse time: ${creeper.getMaxFuseTime()} ticks`);\n        }\n\n        // Track fuse progression\n        if (isIgnited && fuseTime > 0) {\n            const currentTick = Client.getTime();\n            if (!creeperData.fuseSamples) {\n                creeperData.fuseSamples = [];\n            }\n\n            creeperData.fuseSamples.push({\n                tick: currentTick,\n                fuseTime: fuseTime,\n                fuseChange: fuseChange\n            });\n\n            // Detect charging patterns\n            if (fuseChange !== 0) {\n                const pattern = creeperData.chargingPatterns || [];\n                pattern.push({\n                    tick: currentTick,\n                    change: fuseChange,\n                    time: currentTick - (creeperData.fuseStartTime || currentTick)\n                });\n                creeperData.chargingPatterns = pattern;\n            }\n        }\n\n        // Check for explosion completion\n        if (creeperData.wasIgnited && !isIgnited && creeper.getFuseTime() === 0) {\n            this.onCreeperExplode(creeper, creeperData);\n        }\n    }\n\n    onCreeperExplode(creeper, creeperData) {\n        this.stats.explosions++;\n\n        if (creeperData.fuseSamples && creeperData.fuseSamples.length > 0) {\n            const finalFuseTime = creeperData.fuseSamples[creeperData.fuseSamples.length - 1].fuseTime;\n            this.stats.fuseTimeSamples.push(finalFuseTime);\n            this.updateAverageFuseTime();\n        }\n\n        const totalTime = Client.getTime() - creeperData.spawnTime;\n        Chat.log(`&cCreeper exploded! Total lifetime: ${(totalTime/20).toFixed(1)}s`);\n\n        this.activeCreepers.delete(creeper.getUUID());\n    }\n\n    updateAverageFuseTime() {\n        if (this.stats.fuseTimeSamples.length > 0) {\n            const sum = this.stats.fuseTimeSamples.reduce((a, b) => a + b, 0);\n            this.stats.averageFuseTime = sum / this.stats.fuseTimeSamples.length;\n        }\n    }\n\n    generateReport() {\n        const chargedPercentage = this.stats.totalSpawned > 0 ?\n            (this.stats.chargedSpawned / this.stats.totalSpawned * 100).toFixed(1) : 0;\n\n        const explosionRate = this.stats.totalSpawned > 0 ?\n            (this.stats.explosions / this.stats.totalSpawned * 100).toFixed(1) : 0;\n\n        Chat.log(\"=== Creeper Analysis Report ===\");\n        Chat.log(`Total creepers spawned: ${this.stats.totalSpawned}`);\n        Chat.log(`Charged creepers: ${this.stats.chargedSpawned} (${chargedPercentage}%)`);\n        Chat.log(`Ignited creepers: ${this.stats.ignitedCount}`);\n        Chat.log(`Explosions recorded: ${this.stats.explosions} (${explosionRate}%)`);\n\n        if (this.stats.averageFuseTime > 0) {\n            Chat.log(`Average fuse time: ${this.stats.averageFuseTime.toFixed(1)} ticks (${(this.stats.averageFuseTime/20).toFixed(2)}s)`);\n        }\n\n        Chat.log(`Currently active creepers: ${this.activeCreepers.size}`);\n    }\n\n    update() {\n        const entities = World.getEntities();\n        const currentUUIDs = new Set();\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:creeper\")) {\n                const creeper = entity.asCreeper();\n                const uuid = creeper.getUUID();\n                currentUUIDs.add(uuid);\n\n                this.onCreeperUpdate(creeper);\n            }\n        });\n\n        // Remove despawned creepers\n        for (const [uuid, creeperData] of this.activeCreepers) {\n            if (!currentUUIDs.has(uuid)) {\n                Chat.log(`&7Creeper despawned (lived ${((Client.getTime() - creeperData.spawnTime)/20).toFixed(1)}s)`);\n                this.activeCreepers.delete(uuid);\n            }\n        }\n    }\n}\n\n// Initialize analyzer\nconst analyzer = new CreeperAnalyzer();\n\n// Update analysis every 20 ticks (once per second)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 20 === 0) {\n        analyzer.update();\n    }\n}));\n\n// Generate report every 5 minutes\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % (20 * 60 * 5) === 0) {\n        analyzer.generateReport();\n    }\n}));\n\nChat.log(\"&aCreeper Behavior Analyzer activated\");"
  ]
}