{
  "name": "VexEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.mob.VexEntityHelper",
  "extends": "MobEntityHelper<VexEntity>",
  "since": "JsMacros 1.8.4",
  "description": "Represents a vex entity in the world. VexEntityHelper provides access to vex-specific properties and behaviors, particularly their charging attack state.",
  "overview": "Vex are formidable flying enemies that serve as minions to evokers during raids or in woodland mansions. These small, winged creatures wield iron swords and can move freely through blocks, making them particularly dangerous as they bypass conventional defenses. Their signature charging attack allows them to rapidly close distance to their targets, making traditional combat strategies less effective.\n\nThis class extends `MobEntityHelper` and inherits all methods for health, AI control, movement, and other mob properties, while adding vex-specific functionality for monitoring their charging behavior and attack patterns.",
  "constructors": [],
  "methods": [
    {
      "name": "isCharging",
      "signature": "isCharging()",
      "returnType": "boolean",
      "description": "Checks if the vex is currently in its charging attack state. Vexes charge to rapidly close distance to their target.",
      "parameters": [],
      "static": false,
      "examples": []
    }
  ],
  "usageExamples": [
    "// Comprehensive vex threat detection and defense system\nclass VexDefenseMonitor {\n    constructor() {\n        this.activeVexes = new Map();\n        this.alertCooldowns = new Map();\n        this.chargePredictions = [];\n        this.defenseRecommendations = new Map();\n    }\n\n    monitorVex(vexEntity) {\n        const vex = vexEntity.as(\"minecraft:vex\");\n        if (!vex) return;\n\n        const uuid = vexEntity.getUUID();\n        const player = Player.getPlayer();\n        const isCharging = vex.isCharging();\n        const isAttacking = vex.isAttacking();\n        const distance = player.distanceTo(vexEntity);\n        const health = vexEntity.asLiving().getHealth();\n        const maxHealth = vexEntity.asLiving().getMaxHealth();\n        const pos = vexEntity.getPos();\n        const currentTime = Client.getTime();\n\n        // Store vex data\n        if (!this.activeVexes.has(uuid)) {\n            this.activeVexes.set(uuid, {\n                entity: vexEntity,\n                name: vexEntity.getName().getString(),\n                firstSeen: currentTime,\n                lastChargeState: isCharging,\n                chargeHistory: [],\n                attackCount: 0,\n                lastPlayerDistance: distance,\n                threatLevel: \"UNKNOWN\",\n                chargeCount: 0,\n                defenseInitiated: false\n            });\n\n            Chat.log(`&c‚ö° Vex detected: ${vexEntity.getName().getString()}`);\n            Chat.log(`  Position: [${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}]`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Health: ${health.toFixed(1)}/${maxHealth.toFixed(1)}`);\n        }\n\n        const vexData = this.activeVexes.get(uuid);\n\n        // Track charge state changes\n        if (vexData.lastChargeState !== isCharging) {\n            vexData.lastChargeState = isCharging;\n\n            if (isCharging) {\n                this.handleChargeStart(vexData, distance, currentTime);\n            } else {\n                this.handleChargeEnd(vexData, currentTime);\n            }\n        }\n\n        // Track attack behavior\n        if (isAttacking && !vexData.lastAttacking) {\n            this.handleAttackStart(vexData, distance);\n        } else if (!isAttacking && vexData.lastAttacking) {\n            this.handleAttackEnd(vexData);\n        }\n        vexData.lastAttacking = isAttacking;\n\n        // Update threat assessment\n        this.updateThreatAssessment(vexData, isCharging, isAttacking, distance, health, maxHealth);\n\n        // Provide real-time defense recommendations\n        if (distance <= 16) {\n            this.provideDefenseAssistance(vexData, isCharging, distance, pos);\n        }\n\n        // Track charge history\n        vexData.chargeHistory.push({\n            isCharging: isCharging,\n            distance: distance,\n            time: currentTime\n        });\n\n        // Clean old history (keep last 30 seconds)\n        const cutoffTime = currentTime - 600;\n        vexData.chargeHistory = vexData.chargeHistory.filter(entry => entry.time > cutoffTime);\n\n        // Update distance tracking\n        vexData.lastPlayerDistance = distance;\n    }\n\n    handleChargeStart(vexData, distance, currentTime) {\n        vexData.chargeCount++;\n        const urgency = distance <= 8 ? \"IMMEDIATE\" : distance <= 16 ? \"URGENT\" : \"MONITOR\";\n\n        Chat.log(`&c‚ö° ${vexData.name} STARTED CHARGING!`);\n        Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n        Chat.log(`  Urgency: ${urgency}`);\n        Chat.log(`  Charge count: ${vexData.chargeCount}`);\n\n        // Predict charge trajectory and impact\n        this.predictChargeImpact(vexData, distance);\n\n        // Send immediate alert based on distance\n        if (distance <= 8) {\n            this.sendCriticalAlert(\"VEX CHARGE - IMMEDIATE DODGE REQUIRED!\", \"critical\");\n        } else if (distance <= 16) {\n            this.sendCriticalAlert(\"Vex charging incoming - prepare evasion!\", \"danger\");\n        } else {\n            this.sendCriticalAlert(\"Vex charge detected - monitor approach\", \"warning\");\n        }\n\n        // Activate defense systems\n        this.activateDefenseProtocol(vexData, distance);\n    }\n\n    handleChargeEnd(vexData, currentTime) {\n        Chat.log(`&a‚úÖ ${vexData.name} charge completed`);\n        Chat.log(`  Charge duration: ${((currentTime - vexData.chargeStartTime) / 20).toFixed(1)}s`);\n\n        // Check if player needs to counter-attack\n        const distance = Player.getPlayer().distanceTo(vexData.entity);\n        if (distance <= 6) {\n            Chat.log(`  &e‚öîÔ∏è Counter-attack opportunity - vex is close!`);\n        }\n\n        // Reset defense state\n        vexData.defenseInitiated = false;\n    }\n\n    handleAttackStart(vexData, distance) {\n        vexData.attackCount++;\n        Chat.log(`&c‚öîÔ∏è ${vexData.name} started attacking (attack #${vexData.attackCount})`);\n\n        if (distance <= 4) {\n            Chat.log(`  &cüíÄ POINT BLANK ATTACK - Extreme danger!`);\n            this.sendCriticalAlert(\"VEX MELEE ATTACK - BLOCK OR DODGE!\", \"critical\");\n        }\n    }\n\n    handleAttackEnd(vexData) {\n        Chat.log(`&a${vexData.name} attack completed`);\n\n        // Suggest counter-attack window\n        const distance = Player.getPlayer().distanceTo(vexData.entity);\n        if (distance <= 6 && distance > 2) {\n            Chat.log(`  ‚öîÔ∏è Counter-attack window - vex is in optimal range!`);\n        }\n    }\n\n    predictChargeImpact(vexData, distance) {\n        const chargeSpeed = 8.0; // Vex charge speed in blocks/second (approximate)\n        const timeToImpact = distance / chargeSpeed;\n\n        Chat.log(`&6‚è±Ô∏è Charge impact prediction: ${timeToImpact.toFixed(1)} seconds`);\n\n        if (timeToImpact <= 0.5) {\n            Chat.log(`  &cüíÄ IMPACT IMMINENT - No time to evade!`);\n            this.scheduleImmediateDefense();\n        } else if (timeToImpact <= 1.0) {\n            Chat.log(`  &e‚ö†Ô∏è Limited time - Immediate evasive action required!`);\n            this.scheduleUrgentDefense(timeToImpact);\n        } else {\n            Chat.log(`  &büí° Time available - Prepare defense strategy`);\n            this.scheduleStrategicDefense(timeToImpact);\n        }\n\n        vexData.chargeStartTime = Client.getTime();\n    }\n\n    activateDefenseProtocol(vexData, distance) {\n        if (vexData.defenseInitiated) return;\n\n        vexData.defenseInitiated = true;\n\n        Chat.log(`&büõ°Ô∏è Activating defense protocol against ${vexData.name}`);\n\n        // Provide specific defense recommendations based on distance\n        if (distance <= 6) {\n            this.provideImmediateDefense(vexData);\n        } else if (distance <= 12) {\n            this.provideTacticalDefense(vexData);\n        } else {\n            this.provideStrategicDefense(vexData);\n        }\n    }\n\n    provideImmediateDefense(vexData) {\n        Chat.log(`&cüö® IMMEDIATE DEFENSE ACTIONS:`);\n        Chat.log(`  ‚Üí Shield block NOW if available`);\n        Chat.log(`  ‚Üí Jump backward to create distance`);\n        Chat.log(`  ‚Üí Use knockback weapons if possible`);\n        Chat.log(`  ‚Üí Activate defensive items (totems, potions)`);\n\n        this.scheduleImmediateDefense();\n    }\n\n    provideTacticalDefense(vexData) {\n        Chat.log(`&eüéØ TACTICAL DEFENSE:`);\n        Chat.log(`  ‚Üí Move perpendicular to charge direction`);\n        Chat.log(`  ‚Üí Prepare shield for incoming attack`);\n        Chat.log(`  ‚Üí Consider attack during recovery window`);\n        Chat.log(`  ‚Üí Use environmental obstacles as cover`);\n\n        this.scheduleUrgentDefense(1.5);\n    }\n\n    provideStrategicDefense(vexData) {\n        Chat.log(`&büí° STRATEGIC DEFENSE:`);\n        Chat.log(`  ‚Üí Identify optimal evasion path`);\n        Chat.log(`  ‚Üí Prepare weapons for counter-attack`);\n        Chat.log(`  ‚Üí Create barriers if possible`);\n        Chat.log(`  ‚Üí Use elevation to advantage`);\n\n        this.scheduleStrategicDefense(2.0);\n    }\n\n    scheduleImmediateDefense() {\n        setTimeout(() => {\n            Chat.actionbar(\"&cüõ°Ô∏è SHIELD NOW - Block incoming charge!\");\n        }, 100);\n    }\n\n    scheduleUrgentDefense(timeToImpact) {\n        const warningTime = Math.max(100, (timeToImpact - 0.5) * 1000);\n\n        setTimeout(() => {\n            Chat.actionbar(\"&e‚ö° PREPARE EVASION - Charge incoming!\");\n        }, warningTime);\n    }\n\n    scheduleStrategicDefense(timeToImpact) {\n        const warningTime = Math.max(100, (timeToImpact - 1.0) * 1000);\n\n        setTimeout(() => {\n            Chat.actionbar(\"&büéØ Ready defenses - Vex approaching!\");\n        }, warningTime);\n    }\n\n    updateThreatAssessment(vexData, isCharging, isAttacking, distance, health, maxHealth) {\n        let threatScore = 0;\n\n        // Base threat by distance\n        if (distance <= 4) threatScore += 40;\n        else if (distance <= 8) threatScore += 30;\n        else if (distance <= 16) threatScore += 20;\n        else if (distance <= 24) threatScore += 10;\n\n        // Combat state threat\n        if (isCharging) threatScore += 35;\n        if (isAttacking) threatScore += 25;\n\n        // Health threat (healthier vexes are more dangerous)\n        const healthPercent = (health / maxHealth) * 100;\n        threatScore += healthPercent * 0.2;\n\n        // Multiple charge threat\n        if (vexData.chargeCount >= 3) threatScore += 20;\n        else if (vexData.chargeCount >= 2) threatScore += 10;\n\n        // Update threat level\n        let newThreatLevel;\n        if (threatScore >= 80) newThreatLevel = \"CRITICAL\";\n        else if (threatScore >= 60) newThreatLevel = \"HIGH\";\n        else if (threatScore >= 40) newThreatLevel = \"MEDIUM\";\n        else if (threatScore >= 20) newThreatLevel = \"LOW\";\n        else newThreatLevel = \"MINIMAL\";\n\n        if (newThreatLevel !== vexData.threatLevel) {\n            const oldLevel = vexData.threatLevel;\n            vexData.threatLevel = newThreatLevel;\n\n            Chat.log(`&6${vexData.name} threat level: ${oldLevel} ‚Üí ${newThreatLevel} (${threatScore.toFixed(0)}%)`);\n\n            if (newThreatLevel === \"CRITICAL\") {\n                this.sendCriticalAlert(\"CRITICAL THREAT LEVEL - Maximum defense required!\", \"critical\");\n            }\n        }\n    }\n\n    provideDefenseAssistance(vexData, isCharging, distance, vexPos) {\n        const playerPos = Player.getPlayer().getPos();\n\n        // Calculate optimal evasion direction\n        const evasionVector = this.calculateOptimalEvasion(vexPos, playerPos, isCharging);\n\n        if (isCharging && distance <= 12) {\n            const urgency = distance <= 6 ? \"IMMEDIATE\" : \"URGENT\";\n            Chat.actionbar(`&c${urgency} EVASION: Move ${evasionVector.direction}`);\n        }\n\n        // Environmental defense suggestions\n        this.analyzeEnvironmentalDefenses(vexPos, playerPos, distance);\n\n        // Combat recommendations\n        if (!isCharging && distance <= 8) {\n            this.provideCombatOpportunity(vexData, distance);\n        }\n    }\n\n    calculateOptimalEvasion(vexPos, playerPos, isCharging) {\n        // Calculate vector from vex to player\n        const vexToPlayer = {\n            x: playerPos.x - vexPos.x,\n            y: playerPos.y - vexPos.y,\n            z: playerPos.z - vexPos.z\n        };\n\n        // Normalize and get perpendicular directions for evasion\n        const length = Math.sqrt(vexToPlayer.x * vexToPlayer.x + vexToPlayer.z * vexToPlayer.z);\n\n        if (length > 0) {\n            // Perpendicular vectors (90 degrees to attack direction)\n            const perp1 = {\n                x: -vexToPlayer.z / length,\n                z: vexToPlayer.x / length\n            };\n\n            const perp2 = {\n                x: vexToPlayer.z / length,\n                z: -vexToPlayer.x / length\n            };\n\n            // Choose best evasion direction based on available space\n            const bestDirection = this.selectBestEvasionDirection(playerPos, perp1, perp2);\n\n            return {\n                direction: bestDirection,\n                vector: bestDirection === \"left\" ? perp1 : perp2\n            };\n        }\n\n        return { direction: \"away\", vector: { x: 0, z: 1 } };\n    }\n\n    selectBestEvasionDirection(playerPos, dir1, dir2) {\n        // Simple heuristic - check which direction has more open space\n        const checkDistance = 3;\n\n        let dir1Clear = true;\n        let dir2Clear = true;\n\n        for (let i = 1; i <= checkDistance; i++) {\n            const pos1 = World.getBlock(\n                Math.floor(playerPos.x + dir1.x * i),\n                Math.floor(playerPos.y),\n                Math.floor(playerPos.z + dir1.z * i)\n            );\n\n            const pos2 = World.getBlock(\n                Math.floor(playerPos.x + dir2.x * i),\n                Math.floor(playerPos.y),\n                Math.floor(playerPos.z + dir2.z * i)\n            );\n\n            if (pos1 && !pos1.getBlockState().isAir()) dir1Clear = false;\n            if (pos2 && !pos2.getBlockState().isAir()) dir2Clear = false;\n        }\n\n        if (dir1Clear && !dir2Clear) return \"left\";\n        if (!dir1Clear && dir2Clear) return \"right\";\n        if (dir1Clear && dir2Clear) return Math.random() > 0.5 ? \"left\" : \"right\";\n        return \"away\";\n    }\n\n    analyzeEnvironmentalDefenses(vexPos, playerPos, distance) {\n        // Check for barriers and cover\n        const barriers = this.findNearbyBarriers(playerPos, 8);\n\n        if (barriers.length > 0) {\n            Chat.log(`&aüõ°Ô∏è Environmental defenses available:`);\n            barriers.forEach(barrier => {\n                const barrierDistance = Math.sqrt(\n                    Math.pow(barrier.x - playerPos.x, 2) +\n                    Math.pow(barrier.z - playerPos.z, 2)\n                );\n                Chat.log(`  ‚Ä¢ Barrier at [${barrier.x}, ${barrier.y}, ${barrier.z}] (${barrierDistance.toFixed(1)}m)`);\n            });\n        } else {\n            Chat.log(`&e‚ö†Ô∏è No immediate barriers detected - rely on evasion`);\n        }\n\n        // Check for water (slows vexes slightly)\n        const nearbyWater = this.findNearbyWater(playerPos, 6);\n        if (nearbyWater) {\n            Chat.log(`&6üíß Water nearby - can slow vex movement`);\n        }\n    }\n\n    findNearbyBarriers(pos, radius) {\n        const barriers = [];\n\n        for (let x = -radius; x <= radius; x += 2) {\n            for (let z = -radius; z <= radius; z += 2) {\n                for (let y = -1; y <= 3; y++) {\n                    const checkX = Math.floor(pos.x + x);\n                    const checkY = Math.floor(pos.y + y);\n                    const checkZ = Math.floor(pos.z + z);\n\n                    const block = World.getBlock(checkX, checkY, checkZ);\n                    if (block && !block.getBlockState().isAir() &&\n                        !block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                        barriers.push({ x: checkX, y: checkY, z: checkZ });\n                    }\n                }\n            }\n        }\n\n        return barriers;\n    }\n\n    findNearbyWater(pos, radius) {\n        for (let x = -radius; x <= radius; x++) {\n            for (let z = -radius; z <= radius; z++) {\n                const block = World.getBlock(\n                    Math.floor(pos.x + x),\n                    Math.floor(pos.y),\n                    Math.floor(pos.z + z)\n                );\n\n                if (block && block.getBlockState().getBlock().getTranslationKey().includes(\"water\")) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    provideCombatOpportunity(vexData, distance) {\n        Chat.log(`&a‚öîÔ∏è Combat opportunity detected:`);\n        Chat.log(`  ‚Ä¢ Vex is not charging - optimal attack window`);\n        Chat.log(`  ‚Ä¢ Distance: ${distance.toFixed(1)} blocks (good range)`);\n        Chat.log(`  ‚Ä¢ Health: ${vexData.entity.asLiving().getHealth().toFixed(1)}/${vexData.entity.asLiving().getMaxHealth().toFixed(1)}`);\n\n        if (distance <= 4) {\n            Chat.log(`  &cüíÄ Point blank range - high risk, high reward`);\n        } else if (distance <= 8) {\n            Chat.log(`  &eüéØ Optimal combat range - balanced risk/reward`);\n        }\n    }\n\n    sendCriticalAlert(message, type) {\n        const currentTime = Client.getTime();\n        const alertKey = `vex_critical_${type}`;\n        const lastAlert = this.alertCooldowns.get(alertKey) || 0;\n\n        if (currentTime - lastAlert < 30) return; // 1.5 second cooldown\n\n        const prefix = {\n            \"critical\": \"&cüíÄ \",\n            \"danger\": \"&4‚öîÔ∏è \",\n            \"warning\": \"&e‚ö†Ô∏è \"\n        }[type] || \"&b‚ÑπÔ∏è \";\n\n        Chat.actionbar(`${prefix}${message}`);\n        this.alertCooldowns.set(alertKey, currentTime);\n\n        // Title for critical alerts\n        if (type === \"critical\") {\n            Chat.title(prefix + \"VEX THREAT\", message, 0, 1, 0);\n        }\n    }\n\n    generateReport() {\n        if (this.activeVexes.size === 0) {\n            Chat.log(\"No vex data available\");\n            return;\n        }\n\n        Chat.log(`&6=== Vex Defense Report ===`);\n\n        let totalCharges = 0;\n        let criticalThreats = 0;\n        let activeCombat = 0;\n\n        for (const [uuid, vexData] of this.activeVexes) {\n            const currentVex = vexData.entity.as(\"minecraft:vex\");\n            const isCharging = currentVex.isCharging();\n            const isAttacking = currentVex.isAttacking();\n            const distance = Player.getPlayer().distanceTo(vexData.entity);\n\n            if (isCharging || isAttacking) activeCombat++;\n            if (vexData.threatLevel === \"CRITICAL\") criticalThreats++;\n            totalCharges += vexData.chargeCount;\n\n            Chat.log(`\\n${vexData.name}:`);\n            Chat.log(`  Current State: ${isCharging ? \"‚ö° Charging\" : isAttacking ? \"‚öîÔ∏è Attacking\" : \"üòå Idle\"}`);\n            Chat.log(`  Threat Level: ${vexData.threatLevel}`);\n            Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Total Charges: ${vexData.chargeCount}`);\n            Chat.log(`  Total Attacks: ${vexData.attackCount}`);\n        }\n\n        Chat.log(`\\n=== Summary ===`);\n        Chat.log(`Active Vexes: ${this.activeVexes.size}`);\n        Chat.log(`Currently Charging: ${Array.from(this.activeVexes.values()).filter(v => v.entity.as(\"minecraft:vex\").isCharging()).length}`);\n        Chat.log(`In Combat: ${activeCombat}`);\n        Chat.log(`Critical Threats: ${criticalThreats}`);\n        Chat.log(`Total Charges Detected: ${totalCharges}`);\n\n        if (criticalThreats > 0) {\n            Chat.log(`\\n&cüö® CRITICAL: ${criticalThreats} vexes pose immediate threats!`);\n        }\n    }\n}\n\nconst vexDefenseMonitor = new VexDefenseMonitor();\n\n// Monitor vexes every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const monitoringRange = 32;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= monitoringRange && entity.is(\"minecraft:vex\")) {\n            vexDefenseMonitor.monitorVex(entity);\n        }\n    });\n}));\n\n// Defense report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.v\" && e.action === 1) { // V key\n        vexDefenseMonitor.generateReport();\n    }\n}));",
    "// Track vex behavior patterns and charge statistics\nclass VexBehaviorAnalyzer {\n    constructor() {\n        this.vexStats = new Map();\n        this.globalStats = {\n            totalVexesSeen: 0,\n            totalCharges: 0,\n            totalAttacks: 0,\n            chargesPerVex: [],\n            attackPatterns: new Map()\n        };\n    }\n\n    analyzeVexBehavior(vexEntity) {\n        const vex = vexEntity.as(\"minecraft:vex\");\n        if (!vex) return;\n\n        const uuid = vexEntity.getUUID();\n        const isCharging = vex.isCharging();\n        const isAttacking = vex.isAttacking();\n        const currentTime = Client.getTime();\n\n        if (!this.vexStats.has(uuid)) {\n            this.vexStats.set(uuid, {\n                entity: vexEntity,\n                name: vexEntity.getName().getString(),\n                firstSeen: currentTime,\n                lastChargeState: false,\n                lastAttackState: false,\n                chargeStartTime: null,\n                totalChargeTime: 0,\n                chargeCount: 0,\n                attackCount: 0,\n                chargeDurations: [],\n                attackTimestamps: [],\n                maxChargeDistance: 0,\n                behaviors: []\n            });\n\n            this.globalStats.totalVexesSeen++;\n            Chat.log(`&6üìä Started tracking vex: ${vexEntity.getName().getString()}`);\n        }\n\n        const stats = this.vexStats.get(uuid);\n\n        // Track charging behavior\n        if (isCharging && !stats.lastChargeState) {\n            // Charge started\n            stats.chargeCount++;\n            stats.chargeStartTime = currentTime;\n            this.globalStats.totalCharges++;\n\n            const distance = Player.getPlayer().distanceTo(vexEntity);\n            stats.maxChargeDistance = Math.max(stats.maxChargeDistance, distance);\n\n            Chat.log(`&e‚ö° Vex ${stats.name} started charging (charge #${stats.chargeCount})`);\n\n        } else if (!isCharging && stats.lastChargeState && stats.chargeStartTime) {\n            // Charge ended\n            const chargeDuration = currentTime - stats.chargeStartTime;\n            stats.chargeDurations.push(chargeDuration);\n            stats.totalChargeTime += chargeDuration;\n\n            Chat.log(`&a‚úÖ Vex ${stats.name} stopped charging (duration: ${(chargeDuration/20).toFixed(1)}s)`);\n        }\n\n        // Track attacking behavior\n        if (isAttacking && !stats.lastAttackState) {\n            stats.attackCount++;\n            stats.attackTimestamps.push(currentTime);\n            this.globalStats.totalAttacks++;\n\n            Chat.log(`&c‚öîÔ∏è Vex ${stats.name} attacked (attack #${stats.attackCount})`);\n        }\n\n        // Record behavior state\n        stats.behaviors.push({\n            timestamp: currentTime,\n            isCharging: isCharging,\n            isAttacking: isAttacking,\n            health: vexEntity.asLiving().getHealth(),\n            distance: Player.getPlayer().distanceTo(vexEntity)\n        });\n\n        // Clean old behaviors (keep last 2 minutes)\n        const cutoffTime = currentTime - 2400;\n        stats.behaviors = stats.behaviors.filter(b => b.timestamp > cutoffTime);\n\n        stats.lastChargeState = isCharging;\n        stats.lastAttackState = isAttacking;\n    }\n\n    generateBehaviorReport() {\n        if (this.vexStats.size === 0) {\n            Chat.log(\"No vex behavior data available\");\n            return;\n        }\n\n        Chat.log(`&6=== Vex Behavior Analysis ===`);\n\n        let totalChargeTime = 0;\n        let totalChargeDuration = 0;\n        let vexWithCharges = 0;\n        let vexWithAttacks = 0;\n\n        for (const [uuid, stats] of this.vexStats) {\n            const avgChargeDuration = stats.chargeDurations.length > 0 ?\n                stats.chargeDurations.reduce((a, b) => a + b, 0) / stats.chargeDurations.length : 0;\n\n            const chargePercentage = stats.chargeCount > 0 ?\n                (stats.totalChargeTime / (Client.getTime() - stats.firstSeen)) * 100 : 0;\n\n            Chat.log(`\\n${stats.name}:`);\n            Chat.log(`  Tracked for: ${((Client.getTime() - stats.firstSeen) / 20).toFixed(1)}s`);\n            Chat.log(`  Total charges: ${stats.chargeCount}`);\n            Chat.log(`  Total attacks: ${stats.attackCount}`);\n            Chat.log(`  Average charge duration: ${(avgChargeDuration/20).toFixed(1)}s`);\n            Chat.log(`  Charge percentage: ${chargePercentage.toFixed(1)}%`);\n            Chat.log(`  Max charge distance: ${stats.maxChargeDistance.toFixed(1)} blocks`);\n            Chat.log(`  Current health: ${stats.entity.asLiving().getHealth().toFixed(1)}/${stats.entity.asLiving().getMaxHealth().toFixed(1)}`);\n\n            if (stats.chargeCount > 0) vexWithCharges++;\n            if (stats.attackCount > 0) vexWithAttacks++;\n\n            totalChargeTime += stats.totalChargeTime;\n            totalChargeDuration += avgChargeDuration;\n        }\n\n        Chat.log(`\\n=== Global Statistics ===`);\n        Chat.log(`Total vexes tracked: ${this.globalStats.totalVexesSeen}`);\n        Chat.log(`Currently tracking: ${this.vexStats.size}`);\n        Chat.log(`Vexes that charged: ${vexWithCharges}/${this.vexStats.size} (${((vexWithCharges/this.vexStats.size)*100).toFixed(1)}%)`);\n        Chat.log(`Vexes that attacked: ${vexWithAttacks}/${this.vexStats.size} (${((vexWithAttacks/this.vexStats.size)*100).toFixed(1)}%)`);\n        Chat.log(`Total charges detected: ${this.globalStats.totalCharges}`);\n        Chat.log(`Total attacks detected: ${this.globalStats.totalAttacks}`);\n        Chat.log(`Average charge duration: ${this.vexStats.size > 0 ? (totalChargeDuration/this.vexStats.size/20).toFixed(1) : 0}s`);\n        Chat.log(`Total charging time: ${(totalChargeTime/20).toFixed(1)}s`);\n\n        // Behavioral patterns\n        this.analyzeBehaviorPatterns();\n    }\n\n    analyzeBehaviorPatterns() {\n        Chat.log(`\\n=== Behavioral Patterns ===`);\n\n        const chargeFrequencies = [];\n        const attackFrequencies = [];\n\n        for (const stats of this.vexStats.values()) {\n            const trackingDuration = (Client.getTime() - stats.firstSeen) / 20; // seconds\n            if (trackingDuration > 0) {\n                chargeFrequencies.push(stats.chargeCount / trackingDuration * 60); // charges per minute\n                attackFrequencies.push(stats.attackCount / trackingDuration * 60); // attacks per minute\n            }\n        }\n\n        if (chargeFrequencies.length > 0) {\n            const avgChargeFreq = chargeFrequencies.reduce((a, b) => a + b, 0) / chargeFrequencies.length;\n            const avgAttackFreq = attackFrequencies.reduce((a, b) => a + b, 0) / attackFrequencies.length;\n\n            Chat.log(`Average charge frequency: ${avgChargeFreq.toFixed(1)} charges/minute`);\n            Chat.log(`Average attack frequency: ${avgAttackFreq.toFixed(1)} attacks/minute`);\n\n            // Classify behavior patterns\n            const aggressiveVexes = chargeFrequencies.filter(f => f > avgChargeFreq * 1.5).length;\n            const passiveVexes = chargeFrequencies.filter(f => f < avgChargeFreq * 0.5).length;\n\n            Chat.log(`Highly aggressive vexes: ${aggressiveVexes}/${chargeFrequencies.length}`);\n            Chat.log(`Passive vexes: ${passiveVexes}/${chargeFrequencies.length}`);\n\n            if (aggressiveVexes > chargeFrequencies.length * 0.3) {\n                Chat.log(`&c‚ö†Ô∏è High aggression detected - multiple vexes are extremely aggressive`);\n            }\n        }\n    }\n}\n\nconst vexAnalyzer = new VexBehaviorAnalyzer();\n\n// Analyze vexes every tick\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const analysisRange = 32;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= analysisRange && entity.is(\"minecraft:vex\")) {\n            vexAnalyzer.analyzeVexBehavior(entity);\n        }\n    });\n}));\n\n// Analysis report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.b\" && e.action === 1) { // B key\n        vexAnalyzer.generateBehaviorReport();\n    }\n}));",
    "// Advanced vex charge detection and countermeasure system\nclass VexChargeCountermeasure {\n    constructor() {\n        this.chargeWarnings = new Map();\n        this.countermeasures = [];\n        this.evasionHistory = [];\n        this.successfulDodges = 0;\n        this.chargeHits = 0;\n    }\n\n    detectAndCounterCharge(vexEntity) {\n        const vex = vexEntity.as(\"minecraft:vex\");\n        if (!vex) return;\n\n        const uuid = vexEntity.getUUID();\n        const isCharging = vex.isCharging();\n        const distance = Player.getPlayer().distanceTo(vexEntity);\n        const currentTime = Client.getTime();\n\n        if (!this.chargeWarnings.has(uuid)) {\n            this.chargeWarnings.set(uuid, {\n                lastChargeState: false,\n                chargeStartTime: null,\n                evasionTriggered: false,\n                predictedImpact: null,\n                countermeasureActive: false\n            });\n        }\n\n        const warning = this.chargeWarnings.get(uuid);\n\n        // Detect charge start\n        if (isCharging && !warning.lastChargeState) {\n            this.initiateCountermeasure(vexEntity, distance);\n            warning.chargeStartTime = currentTime;\n            warning.lastChargeState = true;\n\n        } else if (!isCharging && warning.lastChargeState) {\n            // Charge ended\n            this.evaluateCountermeasureSuccess(uuid, distance);\n            warning.lastChargeState = false;\n            warning.evasionTriggered = false;\n            warning.countermeasureActive = false;\n        }\n\n        // Update countermeasure if active\n        if (warning.countermeasureActive && isCharging) {\n            this.updateCountermeasure(vexEntity, distance, currentTime);\n        }\n    }\n\n    initiateCountermeasure(vexEntity, distance) {\n        const uuid = vexEntity.getUUID();\n        const warning = this.chargeWarnings.get(uuid);\n        const vexPos = vexEntity.getPos();\n        const playerPos = Player.getPlayer().getPos();\n\n        Chat.log(`&cüö® INITIATING COUNTERMEASURE against ${vexEntity.getName().getString()}`);\n        Chat.log(`  Distance: ${distance.toFixed(1)} blocks`);\n\n        // Calculate charge trajectory and optimal evasion\n        const evasionPlan = this.calculateEvasionPlan(vexPos, playerPos, distance);\n\n        // Set predicted impact time and position\n        const chargeSpeed = 8.0; // blocks per second\n        const timeToImpact = distance / chargeSpeed;\n\n        warning.predictedImpact = {\n            time: Client.getTime() + (timeToImpact * 20), // convert to ticks\n            position: this.predictChargeImpactPosition(vexPos, playerPos, timeToImpact),\n            evasionPlan: evasionPlan\n        };\n\n        warning.countermeasureActive = true;\n\n        Chat.log(`  Predicted impact: ${timeToImpact.toFixed(1)}s`);\n        Chat.log(`  Evasion strategy: ${evasionPlan.type}`);\n\n        // Execute countermeasure based on urgency\n        if (timeToImpact <= 0.8) {\n            this.executeEmergencyEvasion(evasionPlan);\n        } else if (timeToImpact <= 1.5) {\n            this.executeTacticalEvasion(evasionPlan, timeToImpact);\n        } else {\n            this.executeStrategicEvasion(evasionPlan, timeToImpact);\n        }\n    }\n\n    calculateEvasionPlan(vexPos, playerPos, distance) {\n        const vexToPlayer = {\n            x: playerPos.x - vexPos.x,\n            z: playerPos.z - vexPos.z\n        };\n\n        const angle = Math.atan2(vexToPlayer.z, vexToPlayer.x);\n        const distance = Math.sqrt(vexToPlayer.x * vexToPlayer.x + vexToPlayer.z * vexToPlayer.z);\n\n        // Multiple evasion strategies based on distance and environment\n        const strategies = [];\n\n        // Perpendicular evasion (most reliable)\n        strategies.push({\n            type: \"PERPENDICULAR\",\n            direction: {\n                x: -Math.sin(angle),\n                z: Math.cos(angle)\n            },\n            reliability: 0.85\n        });\n\n        // Diagonal evasion\n        strategies.push({\n            type: \"DIAGONAL\",\n            direction: {\n                x: -Math.sin(angle) * 0.7 + Math.cos(angle) * 0.3,\n                z: Math.cos(angle) * 0.7 - Math.sin(angle) * 0.3\n            },\n            reliability: 0.70\n        });\n\n        // Vertical evasion (jump)\n        strategies.push({\n            type: \"VERTICAL\",\n            direction: { x: 0, z: 0 },\n            reliability: 0.60\n        });\n\n        // Choose best strategy based on environment\n        const bestStrategy = this.selectOptimalStrategy(playerPos, strategies, distance);\n\n        return bestStrategy;\n    }\n\n    selectOptimalStrategy(playerPos, strategies, distance) {\n        // Evaluate each strategy based on available space and obstacles\n        let bestStrategy = strategies[0];\n        let bestScore = 0;\n\n        for (const strategy of strategies) {\n            let score = strategy.reliability * 100;\n\n            // Check for obstacles in evasion direction\n            if (strategy.type !== \"VERTICAL\") {\n                const clearPath = this.checkEvasionPath(playerPos, strategy.direction, distance);\n                score += clearPath ? 20 : -30;\n            }\n\n            // Distance-based scoring\n            if (distance <= 4) {\n                // Close range - prefer vertical (jump)\n                if (strategy.type === \"VERTICAL\") score += 30;\n            } else if (distance <= 10) {\n                // Medium range - prefer perpendicular\n                if (strategy.type === \"PERPENDICULAR\") score += 20;\n            }\n\n            if (score > bestScore) {\n                bestScore = score;\n                bestStrategy = strategy;\n            }\n        }\n\n        return bestStrategy;\n    }\n\n    checkEvasionPath(pos, direction, distance) {\n        const checkDistance = Math.min(distance, 5);\n\n        for (let i = 1; i <= checkDistance; i++) {\n            const checkX = Math.floor(pos.x + direction.x * i);\n            const checkZ = Math.floor(pos.z + direction.z * i);\n            const checkY = Math.floor(pos.y);\n\n            const block = World.getBlock(checkX, checkY, checkZ);\n            if (block && !block.getBlockState().isAir()) {\n                return false; // Obstacle detected\n            }\n        }\n\n        return true; // Path is clear\n    }\n\n    predictChargeImpactPosition(vexPos, playerPos, timeToImpact) {\n        // Predict where the vex will be at impact time\n        // This is a simplified prediction - in reality, vex pathfinding is complex\n\n        const vexToPlayer = {\n            x: playerPos.x - vexPos.x,\n            y: playerPos.y - vexPos.y,\n            z: playerPos.z - vexPos.z\n        };\n\n        const distance = Math.sqrt(\n            vexToPlayer.x * vexToPlayer.x +\n            vexToPlayer.y * vexToPlayer.y +\n            vexToPlayer.z * vexToPlayer.z\n        );\n\n        const chargeDistance = Math.min(8.0 * timeToImpact, distance); // vex max speed ~8 blocks/s\n\n        const normalized = {\n            x: vexToPlayer.x / distance,\n            y: vexToPlayer.y / distance,\n            z: vexToPlayer.z / distance\n        };\n\n        return {\n            x: vexPos.x + normalized.x * chargeDistance,\n            y: vexPos.y + normalized.y * chargeDistance,\n            z: vexPos.z + normalized.z * chargeDistance\n        };\n    }\n\n    executeEmergencyEvasion(evasionPlan) {\n        Chat.actionbar(\"&cüíÄ EMERGENCY EVASION - EXECUTING NOW!\");\n\n        if (evasionPlan.type === \"VERTICAL\") {\n            // Immediate jump\n            Chat.actionbar(\"&6‚¨ÜÔ∏è JUMP NOW!\");\n            // Note: Actual jump execution would require player movement APIs\n        } else {\n            // Immediate lateral movement\n            const direction = evasionPlan.direction.x > 0 ? \"RIGHT\" : \"LEFT\";\n            Chat.actionbar(`&c‚¨ÖÔ∏è STRAFE ${direction} NOW!`);\n        }\n\n        this.recordEvasionAttempt(\"EMERGENCY\", evasionPlan.type);\n    }\n\n    executeTacticalEvasion(evasionPlan, timeToImpact) {\n        const evasionDelay = (timeToImpact - 0.5) * 1000; // Evade 0.5s before impact\n\n        setTimeout(() => {\n            Chat.actionbar(`&e‚ö° TACTICAL EVASION - ${evasionPlan.type} maneuver!`);\n\n            if (evasionPlan.type === \"VERTICAL\") {\n                Chat.actionbar(\"&6ü¶ò TIMED JUMP\");\n            } else {\n                const direction = evasionPlan.direction.x > 0 ? \"RIGHT\" : \"LEFT\";\n                Chat.actionbar(`&e‚û°Ô∏è TIMED STRAFE ${direction}`);\n            }\n\n            this.recordEvasionAttempt(\"TACTICAL\", evasionPlan.type);\n        }, evasionDelay);\n    }\n\n    executeStrategicEvasion(evasionPlan, timeToImpact) {\n        const evasionDelay = (timeToImpact - 1.0) * 1000; // Evade 1s before impact\n\n        setTimeout(() => {\n            Chat.actionbar(`&büí° STRATEGIC EVASION - ${evasionPlan.type} approach`);\n\n            // Additional preparation time for strategic positioning\n            setTimeout(() => {\n                if (evasionPlan.type === \"VERTICAL\") {\n                    Chat.actionbar(\"&6üéØ PREPARE JUMP POSITION\");\n                } else {\n                    Chat.actionbar(\"&büéØ PREPARE EVASION PATH\");\n                }\n            }, 200);\n\n            this.recordEvasionAttempt(\"STRATEGIC\", evasionPlan.type);\n        }, evasionDelay);\n    }\n\n    updateCountermeasure(vexEntity, distance, currentTime) {\n        const uuid = vexEntity.getUUID();\n        const warning = this.chargeWarnings.get(uuid);\n\n        if (!warning.predictedImpact) return;\n\n        const timeToImpact = (warning.predictedImpact.time - currentTime) / 20;\n\n        // Update warnings as impact approaches\n        if (timeToImpact <= 0.5 && !warning.evasionTriggered) {\n            Chat.actionbar(\"&c‚ö†Ô∏è IMPACT IMMINENT - EVASION REQUIRED!\");\n            warning.evasionTriggered = true;\n        } else if (timeToImpact <= 1.0 && timeToImpact > 0.5) {\n            Chat.actionbar(`&e‚ö° Charge impact in ${timeToImpact.toFixed(1)}s`);\n        }\n    }\n\n    evaluateCountermeasureSuccess(uuid, distance) {\n        const warning = this.chargeWarnings.get(uuid);\n\n        if (!warning.predictedImpact) return;\n\n        const actualTimeToImpact = Client.getTime() - warning.chargeStartTime;\n        const predictedTimeToImpact = (warning.predictedImpact.time - warning.chargeStartTime) / 20;\n\n        // Check if player was hit (simplified check)\n        const wasHit = distance <= 2;\n\n        if (wasHit) {\n            this.chargeHits++;\n            Chat.log(`&cüíÄ Vex charge HIT - Distance: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Actual time: ${actualTimeToImpact/20}s, Predicted: ${predictedTimeToImpact.toFixed(1)}s`);\n        } else {\n            this.successfulDodges++;\n            Chat.log(`&a‚úÖ Vex charge DODGED successfully!`);\n            Chat.log(`  Distance at end: ${distance.toFixed(1)} blocks`);\n            Chat.log(`  Evasion type: ${warning.predictedImpact.evasionPlan.type}`);\n\n            this.recordEvasionSuccess(warning.predictedImpact.evasionPlan.type);\n        }\n    }\n\n    recordEvasionAttempt(urgency, strategy) {\n        this.evasionHistory.push({\n            timestamp: Client.getTime(),\n            urgency: urgency,\n            strategy: strategy,\n            success: null // Will be determined later\n        });\n    }\n\n    recordEvasionSuccess(strategy) {\n        const lastAttempt = this.evasionHistory\n            .reverse()\n            .find(attempt => attempt.strategy === strategy && attempt.success === null);\n\n        if (lastAttempt) {\n            lastAttempt.success = true;\n        }\n    }\n\n    generateCountermeasureReport() {\n        Chat.log(`&6=== Vex Countermeasure Report ===`);\n\n        const totalCharges = this.successfulDodges + this.chargeHits;\n        const dodgeRate = totalCharges > 0 ? (this.successfulDodges / totalCharges) * 100 : 0;\n\n        Chat.log(`Total charges encountered: ${totalCharges}`);\n        Chat.log(`Successful dodges: ${this.successfulDodges}`);\n        Chat.log(`Hits taken: ${this.chargeHits}`);\n        Chat.log(`Dodge rate: ${dodgeRate.toFixed(1)}%`);\n\n        // Strategy effectiveness\n        const strategyStats = this.calculateStrategyEffectiveness();\n\n        if (strategyStats.size > 0) {\n            Chat.log(`\\n=== Strategy Effectiveness ===`);\n            strategyStats.forEach((stats, strategy) => {\n                const effectiveness = stats.total > 0 ? (stats.successful / stats.total) * 100 : 0;\n                Chat.log(`${strategy}: ${effectiveness.toFixed(1)}% success rate (${stats.successful}/${stats.total})`);\n            });\n        }\n\n        // Recent evasion history\n        const recentEvasions = this.evasionHistory.slice(-10);\n        if (recentEvasions.length > 0) {\n            Chat.log(`\\n=== Recent Evasion History ===`);\n            recentEvasions.forEach((attempt, index) => {\n                const result = attempt.success === null ? \"Unknown\" :\n                               attempt.success ? \"‚úÖ Success\" : \"‚ùå Failed\";\n                const timeAgo = ((Client.getTime() - attempt.timestamp) / 20).toFixed(1);\n                Chat.log(`${index + 1}. ${attempt.urgency} ${attempt.strategy} - ${result} (${timeAgo}s ago)`);\n            });\n        }\n\n        // Recommendations\n        this.generateCountermeasureRecommendations(dodgeRate, strategyStats);\n    }\n\n    calculateStrategyEffectiveness() {\n        const stats = new Map();\n\n        this.evasionHistory.forEach(attempt => {\n            if (!stats.has(attempt.strategy)) {\n                stats.set(attempt.strategy, { total: 0, successful: 0 });\n            }\n\n            const strategyStats = stats.get(attempt.strategy);\n            strategyStats.total++;\n\n            if (attempt.success === true) {\n                strategyStats.successful++;\n            }\n        });\n\n        return stats;\n    }\n\n    generateCountermeasureRecommendations(dodgeRate, strategyStats) {\n        Chat.log(`\\n=== Recommendations ===`);\n\n        if (dodgeRate < 50) {\n            Chat.log(`&c‚ö†Ô∏è LOW DODGE RATE (${dodgeRate.toFixed(1)}%) - Consider:`);\n            Chat.log(`  ‚Ä¢ Practice evasion timing`);\n            Chat.log(`  ‚Ä¢ Use shield blocks more frequently`);\n            Chat.log(`  ‚Ä¢ Maintain greater distance from vexes`);\n        } else if (dodgeRate >= 80) {\n            Chat.log(`&a‚úÖ EXCELLENT DODGE RATE (${dodgeRate.toFixed(1)}%) - Keep up the good work!`);\n        } else {\n            Chat.log(`&eüí° MODERATE DODGE RATE (${dodgeRate.toFixed(1)}%) - Room for improvement`);\n        }\n\n        // Strategy recommendations\n        let bestStrategy = null;\n        let bestEffectiveness = 0;\n\n        strategyStats.forEach((stats, strategy) => {\n            const effectiveness = stats.total > 0 ? (stats.successful / stats.total) * 100 : 0;\n            if (effectiveness > bestEffectiveness && stats.total >= 3) {\n                bestEffectiveness = effectiveness;\n                bestStrategy = strategy;\n            }\n        });\n\n        if (bestStrategy) {\n            Chat.log(`\\nMost effective strategy: ${bestStrategy} (${bestEffectiveness.toFixed(1)}% success rate)`);\n\n            if (bestStrategy === \"PERPENDICULAR\") {\n                Chat.log(`‚Ä¢ Continue using lateral evasion movements`);\n            } else if (bestStrategy === \"VERTICAL\") {\n                Chat.log(`‚Ä¢ Jump timing is working well - maintain this strategy`);\n            } else {\n                Chat.log(`‚Ä¢ Continue with your current successful approach`);\n            }\n        }\n    }\n}\n\nconst vexCountermeasure = new VexChargeCountermeasure();\n\n// Monitor vexes for countermeasure opportunities\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((e) => {\n    const player = Player.getPlayer();\n    if (!player) return;\n\n    const entities = World.getEntities();\n    const countermeasureRange = 20;\n\n    entities.forEach(entity => {\n        const distance = player.distanceTo(entity);\n        if (distance <= countermeasureRange && entity.is(\"minecraft:vex\")) {\n            vexCountermeasure.detectAndCounterCharge(entity);\n        }\n    });\n}));\n\n// Countermeasure report command\nevents.on(\"Key\", JavaWrapper.methodToJavaAsync((e) => {\n    if (e.key === \"key.keyboard.c\" && e.action === 1) { // C key\n        vexCountermeasure.generateCountermeasureReport();\n    }\n}));"
  ]
}