{
  "name": "TameableEntityHelper",
  "fullClassName": "xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.passive.TameableEntityHelper",
  "extends": "AnimalEntityHelper<TameableEntity>",
  "since": "1.8.4",
  "description": "The TameableEntityHelper class provides specialized access to tameable entities in Minecraft, offering methods to monitor and interact with taming-related behaviors such as ownership, taming status, and sitting behavior.",
  "overview": "This class extends AnimalEntityHelper and inherits all functionality for animals including breeding, food preferences, and basic animal behaviors.\n\nThis helper is particularly useful for creating scripts that manage tameable animals like wolves, cats, parrots, and horses, monitor their taming progress, track ownership, or coordinate the behavior of tamed companion animals.",
  "constructors": [],
  "methods": [
    {
      "name": "isTamed",
      "signature": "public boolean isTamed()",
      "returnType": "boolean",
      "description": "Returns the permanent taming status of the entity. This is different from temporary states and persists across game sessions.",
      "parameters": [],
      "static": false,
      "examples": [
        "// Comprehensive tameable pet management and monitoring system\nclass PetManagementSystem {\n    constructor() {\n        this.pets = new Map();           // All tracked pets\n        this.myPets = new Set();         // Player's pet UUIDs\n        this.statistics = {\n            totalTracked: 0,\n            myPets: 0,\n            othersPets: 0,\n            wildPets: 0,\n            sittingPets: 0,\n            standingPets: 0\n        };\n        this.lastReport = 0;\n    }\n\n    analyzeTameableEntity(entity) {\n        try {\n            const tameable = entity.asTameable();\n            if (!tameable) return null;\n\n            const uuid = entity.getUUID();\n            const name = entity.getName().getString();\n            const type = entity.getType();\n            const isTamed = tameable.isTamed();\n            const isSitting = tameable.isSitting();\n            const ownerUuid = tameable.getOwner();\n            const player = Player.getPlayer();\n            const playerUuid = player ? player.getUUID() : null;\n            const isMine = ownerUuid === playerUuid;\n            const distance = player ? player.distanceTo(entity) : 0;\n\n            return {\n                entity: entity,\n                tameable: tameable,\n                uuid: uuid,\n                name: name,\n                type: type,\n                isTamed: isTamed,\n                isSitting: isSitting,\n                ownerUuid: ownerUuid,\n                isMine: isMine,\n                distance: distance,\n                lastSeen: Client.getTime(),\n                position: entity.getPos(),\n                health: entity.asLiving ? entity.asLiving().getHealth() : null\n            };\n        } catch (e) {\n            return null;\n        }\n    }\n\n    addOrUpdatePet(petData) {\n        if (!petData) return;\n\n        const existing = this.pets.get(petData.uuid);\n\n        if (existing) {\n            // Update existing pet data\n            existing.lastSeen = petData.lastSeen;\n            existing.position = petData.position;\n            existing.distance = petData.distance;\n            existing.health = petData.health;\n            existing.isSitting = petData.isSitting;\n\n            // Check for status changes\n            if (existing.isSitting !== petData.isSitting) {\n                const action = petData.isSitting ? \"sat down\" : \"stood up\";\n                Chat.log(`&6${petData.name} ${action}!`);\n            }\n        } else {\n            // New pet discovered\n            this.pets.set(petData.uuid, petData);\n\n            let message = \"\";\n            if (petData.isMine) {\n                message = `&aFound your pet: ${petData.name}`;\n                this.myPets.add(petData.uuid);\n            } else if (petData.isTamed) {\n                message = `&7Found someone's pet: ${petData.name}`;\n            } else {\n                message = `&eFound wild ${petData.type.replace('minecraft:', '')}: ${petData.name}`;\n            }\n\n            Chat.log(message);\n        }\n\n        // Update statistics\n        this.updateStatistics();\n    }\n\n    updateStatistics() {\n        this.statistics.totalTracked = this.pets.size;\n        this.statistics.myPets = this.myPets.size;\n\n        let othersCount = 0;\n        let wildCount = 0;\n        let sittingCount = 0;\n        let standingCount = 0;\n\n        for (const petData of this.pets.values()) {\n            if (petData.isTamed) {\n                if (petData.isMine) {\n                    // Already counted in myPets\n                } else {\n                    othersCount++;\n                }\n            } else {\n                wildCount++;\n            }\n\n            if (petData.isSitting) {\n                sittingCount++;\n            } else {\n                standingCount++;\n            }\n        }\n\n        this.statistics.othersPets = othersCount;\n        this.statistics.wildPets = wildCount;\n        this.statistics.sittingPets = sittingCount;\n        this.statistics.standingPets = standingCount;\n    }\n\n    update() {\n        const entities = World.getEntities(50); // 50 block radius\n        const currentPetUuids = new Set();\n\n        entities.forEach(entity => {\n            // Check for tameable entities\n            if (entity.is(\"minecraft:wolf\", \"minecraft:cat\", \"minecraft:parrot\")) {\n                const petData = this.analyzeTameableEntity(entity);\n                if (petData) {\n                    currentPetUuids.add(petData.uuid);\n                    this.addOrUpdatePet(petData);\n\n                    // Visual highlighting based on ownership\n                    if (petData.distance <= 20) {\n                        if (petData.isMine) {\n                            entity.setGlowing(true);\n                            entity.setGlowingColor(petData.isSitting ? 0xFFFF00 : 0x00FF00);\n                        } else if (petData.isTamed) {\n                            entity.setGlowing(true);\n                            entity.setGlowingColor(0x808080);\n                        } else {\n                            entity.setGlowing(true);\n                            entity.setGlowingColor(0xFFA500);\n                        }\n                    }\n                }\n            }\n        });\n\n        // Remove pets that are no longer in range\n        for (const [uuid, petData] of this.pets) {\n            if (!currentPetUuids.has(uuid)) {\n                this.pets.delete(uuid);\n                this.myPets.delete(uuid);\n            }\n        }\n\n        this.updateStatistics();\n\n        // Show status update every 30 seconds\n        const currentTime = Client.getTime();\n        if (currentTime - this.lastReport > 20 * 30) {\n            this.showStatusUpdate();\n            this.lastReport = currentTime;\n        }\n    }\n\n    showStatusUpdate() {\n        if (this.statistics.totalTracked === 0) {\n            return;\n        }\n\n        Chat.log(`&7=== Pet Status (${this.statistics.totalTracked} tracked) ===`);\n\n        if (this.statistics.myPets > 0) {\n            Chat.log(`&aYour pets: ${this.statistics.myPets} (${this.statistics.sittingPets} sitting, ${this.statistics.standingPets} following)`);\n        }\n\n        if (this.statistics.othersPets > 0) {\n            Chat.log(`&7Others' pets: ${this.statistics.othersPets}`);\n        }\n\n        if (this.statistics.wildPets > 0) {\n            Chat.log(`&eWild animals: ${this.statistics.wildPets}`);\n        }\n    }\n\n    findMyPets() {\n        if (this.statistics.myPets === 0) {\n            Chat.log(\"&eYou don't have any pets in the current range\");\n            return;\n        }\n\n        Chat.log(`&a=== Your Pets (${this.statistics.myPets}) ===`);\n\n        let count = 1;\n        for (const petData of this.pets.values()) {\n            if (petData.isMine) {\n                const status = petData.isSitting ? \"&6ðŸª‘ Sitting\" : \"&aðŸš¶ Following\";\n                const health = petData.health ? ` (HP: ${petData.health.toFixed(1)})` : \"\";\n\n                Chat.log(`${count}. ${petData.name} ${status}${health} - ${petData.distance.toFixed(1)}m away`);\n\n                // Make them glow more brightly for easier finding\n                petData.entity.setGlowing(true);\n                petData.entity.setGlowingColor(0x00FFFF);\n\n                count++;\n            }\n        }\n\n        Chat.log(\"&aYour pets have been highlighted with bright cyan for easy spotting!\");\n    }\n\n    generateDetailedReport() {\n        if (this.statistics.totalTracked === 0) {\n            Chat.log(\"No pets currently tracked in range.\");\n            return;\n        }\n\n        Chat.log(\"=== Detailed Pet Report ===\");\n        Chat.log(`Total pets tracked: ${this.statistics.totalTracked}`);\n\n        // Group by ownership\n        const myPetList = [];\n        const othersPetList = [];\n        const wildPetList = [];\n\n        for (const petData of this.pets.values()) {\n            if (petData.isMine) {\n                myPetList.push(petData);\n            } else if (petData.isTamed) {\n                othersPetList.push(petData);\n            } else {\n                wildPetList.push(petData);\n            }\n        }\n\n        // My pets\n        if (myPetList.length > 0) {\n            Chat.log(`\\n&a=== Your Pets (${myPetList.length}) ===`);\n            myPetList.forEach(pet => {\n                const status = pet.isSitting ? \"Sitting\" : \"Following\";\n                const health = pet.health ? ` (HP: ${pet.health.toFixed(1)}/${pet.entity.asLiving().getMaxHealth().toFixed(1)})` : \"\";\n                Chat.log(`  ${pet.name} - ${status}${health} - ${pet.distance.toFixed(1)}m`);\n                Chat.log(`    Location: [${pet.position.x.toFixed(0)}, ${pet.position.y.toFixed(0)}, ${pet.position.z.toFixed(0)}]`);\n            });\n        }\n\n        // Others' pets\n        if (othersPetList.length > 0) {\n            Chat.log(`\\n&7=== Others' Pets (${othersPetList.length}) ===`);\n            othersPetList.forEach(pet => {\n                const status = pet.isSitting ? \"Sitting\" : \"Following\";\n                Chat.log(`  ${pet.name} - ${status} - ${pet.distance.toFixed(1)}m`);\n            });\n        }\n\n        // Wild animals\n        if (wildPetList.length > 0) {\n            Chat.log(`\\n&e=== Wild Animals (${wildPetList.length}) ===`);\n            const typeCounts = new Map();\n            wildPetList.forEach(pet => {\n                const type = pet.type.replace('minecraft:', '');\n                typeCounts.set(type, (typeCounts.get(type) || 0) + 1);\n            });\n\n            for (const [type, count] of typeCounts) {\n                Chat.log(`  ${type}: ${count}`);\n            }\n        }\n    }\n\n    commandPets(command) {\n        if (this.statistics.myPets === 0) {\n            Chat.log(\"&eYou don't have any pets to command\");\n            return;\n        }\n\n        const commands = command.toLowerCase().split(' ');\n        const mainCommand = commands[0];\n\n        Chat.log(`&6=== Pet Command: ${mainCommand} ===`);\n\n        let affectedCount = 0;\n\n        for (const petData of this.pets.values()) {\n            if (petData.isMine) {\n                let shouldHighlight = false;\n                let color = 0x00FF00; // Default green\n\n                switch (mainCommand) {\n                    case \"sit\":\n                        if (!petData.isSitting) {\n                            Chat.log(`  ${petData.name}: Sitting down`);\n                            color = 0xFFFF00; // Yellow for sitting\n                            shouldHighlight = true;\n                            affectedCount++;\n                        }\n                        break;\n\n                    case \"stand\":\n                    case \"follow\":\n                        if (petData.isSitting) {\n                            Chat.log(`  ${petData.name}: Standing up to follow`);\n                            color = 0x00FF00; // Green for following\n                            shouldHighlight = true;\n                            affectedCount++;\n                        }\n                        break;\n\n                    case \"status\":\n                        const status = petData.isSitting ? \"Sitting\" : \"Following\";\n                        const health = petData.health ? ` (HP: ${petData.health.toFixed(1)})` : \"\";\n                        Chat.log(`  ${petData.name}: ${status}${health} - ${petData.distance.toFixed(1)}m`);\n                        color = petData.isSitting ? 0xFFFF00 : 0x00FF00;\n                        shouldHighlight = true;\n                        affectedCount++;\n                        break;\n\n                    case \"call\":\n                        if (petData.distance > 10) {\n                            Chat.log(`  ${petData.name}: Called from ${petData.distance.toFixed(1)}m`);\n                            color = 0x00FFFF; // Cyan for called\n                            shouldHighlight = true;\n                            affectedCount++;\n                        } else {\n                            Chat.log(`  ${petData.name}: Already nearby (${petData.distance.toFixed(1)}m)`);\n                        }\n                        break;\n\n                    default:\n                        Chat.log(`  ${petData.name}: Unknown command \"${mainCommand}\"`);\n                }\n\n                if (shouldHighlight) {\n                    petData.entity.setGlowing(true);\n                    petData.entity.setGlowingColor(color);\n                }\n            }\n        }\n\n        if (affectedCount === 0 && mainCommand !== \"status\") {\n            Chat.log(\"&7No pets needed to be commanded\");\n        } else {\n            Chat.actionbar(`&aCommand affected ${affectedCount} pet${affectedCount !== 1 ? 's' : ''}`);\n        }\n    }\n}\n\n// Initialize the pet management system\nconst petManager = new PetManagementSystem();\n\n// Update every 10 ticks (0.5 seconds) for real-time tracking\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    if (Client.getTime() % 10 === 0) {\n        petManager.update();\n    }\n}));",
        "// Advanced breeding compatibility checker for tameable pets\nclass PetBreedingChecker {\n    constructor() {\n        this.tamedPets = [];\n        this.breedingPairs = [];\n        this.lastScan = 0;\n        this.foodPreferences = {\n            \"minecraft:wolf\": [\"minecraft:bone\", \"minecraft:porkchop\", \"minecraft:beef\", \"minecraft:chicken\", \"minecraft:rabbit\"],\n            \"minecraft:cat\": [\"minecraft:cod\", \"minecraft:salmon\", \"minecraft:tropical_fish\"],\n            \"minecraft:parrot\": [\"minecraft:wheat_seeds\", \"minecraft:melon_seeds\", \"minecraft:pumpkin_seeds\", \"minecraft:beetroot_seeds\"]\n        };\n    }\n\n    scanForBreedingPairs() {\n        const entities = World.getEntities(40);\n        this.tamedPets = [];\n        this.breedingPairs = [];\n\n        entities.forEach(entity => {\n            if (entity.is(\"minecraft:wolf\", \"minecraft:cat\", \"minecraft:parrot\")) {\n                try {\n                    const tameable = entity.asTameable();\n                    const animal = entity.asAnimal();\n\n                    if (tameable && animal && tameable.isTamed() && !tameable.isSitting()) {\n                        const player = Player.getPlayer();\n                        const isMine = player && tameable.isOwner(player);\n\n                        this.tamedPets.push({\n                            entity: entity,\n                            tameable: tameable,\n                            animal: animal,\n                            name: entity.getName().getString(),\n                            type: entity.getType(),\n                            uuid: entity.getUUID(),\n                            isMine: isMine,\n                            distance: player ? player.distanceTo(entity) : 0,\n                            canBreed: true,\n                            position: entity.getPos()\n                        });\n                    }\n                } catch (e) {\n                    // Skip if entities can't be cast properly\n                }\n            }\n        });\n\n        // Find breeding pairs\n        for (let i = 0; i < this.tamedPets.length; i++) {\n            for (let j = i + 1; j < this.tamedPets.length; j++) {\n                const pet1 = this.tamedPets[i];\n                const pet2 = this.tamedPets[j];\n\n                // Check if they can breed (same type, not related, etc.)\n                if (pet1.type === pet2.type && pet1.animal.canBreedWith(pet2.animal)) {\n                    const distance = pet1.position.distanceTo(pet2.position);\n                    const bothMine = pet1.isMine && pet2.isMine;\n\n                    this.breedingPairs.push({\n                        pet1: pet1,\n                        pet2: pet2,\n                        distance: distance,\n                        bothMine: bothMine,\n                        breedingFood: this.foodPreferences[pet1.type] || []\n                    });\n                }\n            }\n        }\n\n        this.lastScan = Client.getTime();\n    }\n\n    checkBreedingFood() {\n        const player = Player.getPlayer();\n        if (!player) return { hasFood: false, foodType: null };\n\n        const mainHand = player.getMainHand();\n        const offHand = player.getOffHand();\n\n        let breedingFood = [];\n\n        // Collect all breeding foods from pet types\n        for (const pet of this.tamedPets) {\n            const foods = this.foodPreferences[pet.type] || [];\n            breedingFood.push(...foods);\n        }\n\n        // Remove duplicates\n        breedingFood = [...new Set(breedingFood)];\n\n        // Check if player has any breeding food\n        if (mainHand && breedingFood.includes(mainHand.getId())) {\n            return { hasFood: true, foodType: mainHand.getId(), hand: \"main\" };\n        }\n\n        if (offHand && breedingFood.includes(offHand.getId())) {\n            return { hasFood: true, foodType: offHand.getId(), hand: \"off\" };\n        }\n\n        return { hasFood: false, foodType: null, breedingFood: breedingFood };\n    }\n\n    generateBreedingReport() {\n        Chat.log(\"=== Pet Breeding Analysis ===\");\n        Chat.log(`Scanned ${this.tamedPets.length} tamed pets available for breeding`);\n        Chat.log(`Found ${this.breedingPairs.length} potential breeding pairs`);\n\n        const foodStatus = this.checkBreedingFood();\n        const player = Player.getPlayer();\n\n        if (this.breedingPairs.length === 0) {\n            Chat.log(\"\\n&eNo breeding pairs currently available\");\n\n            if (this.tamedPets.length < 2) {\n                Chat.log(\"Reason: Not enough tamed pets\");\n            } else {\n                Chat.log(\"Possible reasons:\");\n                Chat.log(\"- Pets are too far apart (>8 blocks)\");\n                Chat.log(\"- Pets are related (can't breed family)\");\n                Chat.log(\"- Pet breeding cooldown not finished\");\n                Chat.log(\"- One or both pets are sitting\");\n            }\n\n            if (!foodStatus.hasFood) {\n                Chat.log(`\\n&7You'll need breeding food for the pet types you have`);\n                if (foodStatus.breedingFood.length > 0) {\n                    Chat.log(\"Required foods: \" + foodStatus.breedingFood.join(\", \"));\n                }\n            }\n            return;\n        }\n\n        // Show breeding pairs\n        Chat.log(`\\n&a=== Breeding Pairs (${this.breedingPairs.length}) ===`);\n\n        let myPairs = 0;\n        let othersPairs = 0;\n\n        this.breedingPairs.forEach((pair, index) => {\n            const icon = pair.bothMine ? \"ðŸ’š\" : \"ðŸ’™\";\n            const ownership = pair.bothMine ? \" (Both yours!)\" : \"\";\n            const distanceColor = pair.distance <= 8 ? \"&a\" : \"&e\";\n\n            Chat.log(`${index + 1}. ${icon} ${pair.pet1.name} + ${pair.pet2.name}${ownership}`);\n            Chat.log(`   Distance: ${distanceColor}${pair.distance.toFixed(1)} blocks${pair.distance <= 8 ? \" âœ“\" : \" (too far)\"}`);\n\n            if (pair.bothMine) {\n                myPairs++;\n            } else {\n                othersPairs++;\n            }\n        });\n\n        // Food status\n        Chat.log(`\\n&6=== Breeding Food Status ===`);\n        if (foodStatus.hasFood) {\n            const foodName = foodStatus.foodType.replace('minecraft:', '').replace('_', ' ');\n            const capitalizedFood = foodName.charAt(0).toUpperCase() + foodName.slice(1);\n            Chat.log(`&aâœ“ Holding breeding food: ${capitalizedFood} (${foodStatus.hand} hand)`);\n\n            if (myPairs > 0) {\n                Chat.log(`&aReady to breed ${myPairs} of your pet pairs!`);\n            }\n        } else {\n            Chat.log(`&eâœ— Not holding breeding food`);\n            if (foodStatus.breedingFood.length > 0) {\n                Chat.log(`&7Needed foods: ${foodStatus.breedingFood.join(\", \")}`);\n            }\n        }\n\n        // Ownership summary\n        Chat.log(`\\n&7=== Ownership Summary ===`);\n        Chat.log(`Your breeding pairs: ${myPairs}`);\n        Chat.log(`Others' breeding pairs: ${othersPairs}`);\n\n        if (myPairs > 0) {\n            Chat.log(`&aYou have ${myPairs} breeding pair${myPairs > 1 ? 's' : ''} available!`);\n        }\n\n        // Highlight ready pairs\n        this.highlightBreedingPairs();\n    }\n\n    highlightBreedingPairs() {\n        const foodStatus = this.checkBreedingFood();\n\n        this.breedingPairs.forEach(pair => {\n            let shouldHighlight = false;\n            let color = 0x808080; // Default gray\n\n            if (pair.bothMine && foodStatus.hasFood && pair.distance <= 8) {\n                // Perfect conditions - green\n                color = 0x00FF00;\n                shouldHighlight = true;\n            } else if (pair.bothMine && pair.distance <= 8) {\n                // Your pets, close enough, but no food - yellow\n                color = 0xFFFF00;\n                shouldHighlight = true;\n            } else if (pair.bothMine) {\n                // Your pets but too far - orange\n                color = 0xFF8800;\n                shouldHighlight = true;\n            } else if (pair.distance <= 8) {\n                // Others' pets, close enough - light blue\n                color = 0x00CCFF;\n                shouldHighlight = true;\n            }\n\n            if (shouldHighlight) {\n                pair.pet1.entity.setGlowing(true);\n                pair.pet1.entity.setGlowingColor(color);\n                pair.pet2.entity.setGlowing(true);\n                pair.pet2.entity.setGlowingColor(color);\n            }\n        });\n    }\n\n    findNearestBreedingPair() {\n        if (this.breedingPairs.length === 0) {\n            Chat.log(\"&eNo breeding pairs available\");\n            return null;\n        }\n\n        // Find closest pair that belongs to the player\n        let nearestPair = null;\n        let minDistance = Infinity;\n\n        this.breedingPairs.forEach(pair => {\n            if (pair.bothMine) {\n                const avgDistance = (pair.pet1.distance + pair.pet2.distance) / 2;\n                if (avgDistance < minDistance) {\n                    minDistance = avgDistance;\n                    nearestPair = pair;\n                }\n            }\n        });\n\n        if (nearestPair) {\n            Chat.log(`&aNearest your breeding pair: ${nearestPair.pet1.name} + ${nearestPair.pet2.name}`);\n            Chat.log(`&7Average distance: ${minDistance.toFixed(1)} blocks`);\n\n            // Highlight with special color\n            nearestPair.pet1.entity.setGlowing(true);\n            nearestPair.pet1.entity.setGlowingColor(0xFF00FF); // Magenta\n            nearestPair.pet2.entity.setGlowing(true);\n            nearestPair.pet2.entity.setGlowingColor(0xFF00FF);\n\n            return nearestPair;\n        } else {\n            Chat.log(\"&eYou don't have any breeding pairs\");\n            return null;\n        }\n    }\n\n    update() {\n        // Scan every 3 seconds (60 ticks)\n        if (Client.getTime() - this.lastScan > 60) {\n            this.scanForBreedingPairs();\n        }\n\n        // Update highlights\n        this.highlightBreedingPairs();\n    }\n}\n\n// Initialize breeding checker\nconst breedingChecker = new PetBreedingChecker();\n\n// Update every second (20 ticks)\nevents.on(\"Tick\", JavaWrapper.methodToJavaAsync((event) => {\n    breedingChecker.update();\n}));"
      ]
    },
    {
      "name": "isSitting",
      "signature": "public boolean isSitting()",
      "returnType": "boolean",
      "description": "Indicates whether the entity has been commanded to sit. Tamed animals in sitting position will not follow their owners or move around.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "getOwner",
      "signature": "public java.util.UUID getOwner()",
      "returnType": "java.util.UUID",
      "description": "Returns the UUID of the entity's owner. For wild animals, this returns null. The UUID can be compared with player UUIDs to determine ownership.",
      "parameters": [],
      "static": false,
      "examples": []
    },
    {
      "name": "isOwner",
      "signature": "public boolean isOwner(EntityHelper entity)",
      "returnType": "boolean",
      "description": "A convenient method to check ownership against a specific entity, typically the player. This is safer than manual UUID comparison.",
      "parameters": [
        {
          "name": "entity",
          "type": "EntityHelper",
          "description": "The entity to check ownership against (usually a player)."
        }
      ],
      "static": false,
      "examples": []
    }
  ]
}